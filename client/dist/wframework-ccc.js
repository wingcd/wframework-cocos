var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __glob = (map) => (path4) => {
  var fn = map[path4];
  if (fn) return fn();
  throw new Error("Module not found in bundle: " + path4);
};
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod2) => function __require() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};

// assets/scripts/framework/activity/controller/ActivityController.ts
var ActivityController_exports = {};
__export(ActivityController_exports, {
  ActivityController: () => ActivityController
});
var ActivityController;
var init_ActivityController = __esm({
  "assets/scripts/framework/activity/controller/ActivityController.ts"() {
    ActivityController = class _ActivityController {
      constructor() {
        this._controllers = [];
        this._controllerMap = {};
        this._timer = -1;
        this._delayTime = 3;
      }
      static get inst() {
        if (!this._inst) {
          this._inst = new _ActivityController();
        }
        return this._inst;
      }
      start() {
        this._timer = 0;
      }
      async register(controller, now = false) {
        if (!controller) return;
        if (this._controllerMap[controller.name]) {
          console.warn("ActivityController register repeat: " + controller.name);
          return;
        }
        this._controllers.push(controller);
        this._controllerMap[controller.name] = controller;
        if (now) {
          controller.doRegist();
        }
      }
      ready() {
        for (let i = 0; i < this._controllers.length; i++) {
          this._controllers[i].doRegist();
        }
      }
      getController(name) {
        return this._controllerMap[name];
      }
      update(dt, secondTick) {
        if (this._timer < 0) return;
        this._timer += dt;
        if (this._timer < this._delayTime) return;
        if (!secondTick) return;
        for (let i = 0; i < this._controllers.length; i++) {
          this._controllers[i].update(dt, secondTick);
        }
      }
    };
  }
});

// assets/scripts/framework/common/EventHandler.ts
var EventHandler_exports = {};
__export(EventHandler_exports, {
  EventHandler: () => EventHandler
});
var Handler, EventHandler;
var init_EventHandler = __esm({
  "assets/scripts/framework/common/EventHandler.ts"() {
    Handler = class {
    };
    EventHandler = class {
      constructor() {
        this._handlers = [];
      }
      _add(runner, thisObj, once) {
        if (!runner) {
          console.warn("add none runner to event handler");
          return;
        }
        let handler = new Handler();
        handler.caller = thisObj;
        handler.runner = runner;
        handler.once = once;
        this._handlers.push(handler);
      }
      add(runner, thisObj) {
        this._add(runner, thisObj);
      }
      set(runner, thisObj) {
        this.remove(runner, thisObj);
        this.add(runner, thisObj);
      }
      once(runner, thisObj) {
        this._add(runner, thisObj, true);
      }
      remove(runner, thisObj) {
        let temp = this._handlers.slice();
        for (let i = 0; i < this._handlers.length; i++) {
          let handler = this._handlers[i];
          let sameRunner = handler.runner == runner;
          if (sameRunner) {
            if (!thisObj || handler.caller == thisObj) {
              let idx = temp.indexOf(handler);
              if (idx >= 0) {
                temp.splice(idx, 1);
              }
            }
          }
        }
        this._handlers = temp;
      }
      clear() {
        this._handlers.length = 0;
      }
      fire(...args) {
        let handlers = this._handlers.slice();
        for (let i = 0; i < handlers.length; i++) {
          let handler = handlers[i];
          if (handler.once) {
            let idx = this._handlers.indexOf(handler);
            this._handlers.splice(idx, 1);
          }
          handler.runner.call(handler.caller, ...args);
        }
      }
    };
  }
});

// assets/scripts/framework/common/PoolManager.ts
var PoolManager_exports = {};
__export(PoolManager_exports, {
  PoolManager: () => PoolManager
});
var PoolManager;
var init_PoolManager = __esm({
  "assets/scripts/framework/common/PoolManager.ts"() {
    PoolManager = class {
      constructor(defaultType) {
        this._defaultKey = "default";
        this._types = /* @__PURE__ */ new Map();
        this._items = /* @__PURE__ */ new Map();
        if (defaultType) {
          this.register(this._defaultKey, defaultType);
        }
      }
      getKey(type, key) {
        return key != void 0 ? `${type}|${key}` : `${type}`;
      }
      register(type, classType, count = 0, data) {
        this._types.set(type, classType);
        classType.__pool_type__ = type;
        let keyStr = this.getKey(type, data);
        if (!this._items.has(keyStr)) {
          this._items.set(keyStr, this.createItems(classType, count, keyStr, data));
        }
      }
      createItems(classType, count, keyStr, data) {
        let items = [];
        while (count > 0) {
          let item = new classType();
          if (item.createFromPool) {
            item.createFromPool(data);
          }
          item.__pool_key__ = keyStr;
          items.push(item);
          count--;
        }
        return items;
      }
      getFreeCount(cls, data) {
        let type = cls.__pool_type__;
        let keyStr = this.getKey(type, data);
        let pool = this._items[keyStr];
        if (!pool) {
          return 0;
        }
        return pool.length;
      }
      get(cls, data) {
        cls = cls || this._types.get(this._defaultKey);
        let type = cls.__pool_type__;
        return this.getByType(type, data);
      }
      async getAsync(cls, data) {
        cls = cls || this._types.get(this._defaultKey);
        let type = cls.__pool_type__;
        return await this.getByTypeAsync(type, data);
      }
      async getByKeyAsync(key) {
        return await this.getAsync(null, key);
      }
      getByKey(key) {
        return this.get(null, key);
      }
      async getByTypeAsync(type, data) {
        if (type == null) {
          console.warn(`\u7F13\u5B58\u9519\u8BEF\uFF1A\u5C1D\u8BD5\u7F13\u5B58\u975E\u6C60\u5316\u6570\u636E`);
          return;
        }
        let keyStr = this.getKey(type, data);
        let pool = this._items[keyStr];
        if (!pool) {
          pool = this._items[keyStr] = [];
        }
        if (pool.length > 0) {
          let item2 = pool.pop();
          item2.fromPool && item2.fromPool();
          return item2;
        }
        let cls = this._types.get(type);
        let item = new cls();
        if (item.createFromPool) {
          await item.createFromPool(data);
        }
        item.__pool_key__ = data;
        item.fromPool && item.fromPool();
        return item;
      }
      getByType(type, data) {
        if (type == null) {
          console.warn(`\u7F13\u5B58\u9519\u8BEF\uFF1A\u7F13\u5B58\u975E\u6C60\u5316\u6570\u636E`);
          return;
        }
        let keyStr = this.getKey(type, data);
        let pool = this._items[keyStr];
        if (!pool) {
          pool = this._items[keyStr] = [];
        }
        if (pool.length > 0) {
          let item2 = pool.pop();
          item2.fromPool && item2.fromPool();
          return item2;
        }
        let cls = this._types.get(type);
        let item = new cls();
        if (item.createFromPool) {
          item.createFromPool(data);
        }
        item.__pool_key__ = data;
        item.fromPool && item.fromPool();
        return item;
      }
      put(item) {
        if (!item) {
          console.warn(`\u7F13\u5B58\u9519\u8BEF\uFF1A\u7F13\u5B58\u7A7A\u6570\u636E`);
          return;
        }
        let type = item.constructor.__pool_type__;
        if (type == null) {
          console.warn(`\u7F13\u5B58\u9519\u8BEF\uFF1A\u7F13\u5B58\u975E\u6C60\u5316\u6570\u636E`);
          return;
        }
        let keyStr = this.getKey(type, item.__pool_key__);
        let pool = this._items[keyStr];
        if (!pool) {
          console.error(`\u7F13\u5B58\u9519\u8BEF\uFF1A\u672A\u6CE8\u518C\u7F13\u5B58\u7C7B\u578B${keyStr}`);
          return;
        }
        item.toPool && item.toPool();
        pool.push(item);
      }
      registDefault(cls, count = 0, data) {
        this.register(this._defaultKey, cls, count, data);
      }
    };
  }
});

// assets/scripts/framework/view/Container.ts
var Container_exports = {};
__export(Container_exports, {
  default: () => Container
});
var _Container, Container;
var init_Container = __esm({
  "assets/scripts/framework/view/Container.ts"() {
    init_EventCenter();
    _Container = class _Container {
      constructor() {
        this.children = [];
        this._destoried = false;
        this._isCreated = false;
        this._isShown = false;
        this.enableWating = true;
      }
      get component() {
        return null;
      }
      get destoried() {
        return this._destoried;
      }
      get isCreated() {
        return this._isCreated;
      }
      beginCreate() {
        this._isCreated = false;
      }
      endCreate() {
        this._isCreated = true;
      }
      endShown() {
        this._isShown = true;
      }
      addView(view5) {
        if (_Container.showDebug)
          console.error("check point addview", view5.component.name);
        view5.parent = this;
        this.children.push(view5);
      }
      removeView(view5) {
        view5.parent = null;
        this.children = this.children.filter((item) => item !== view5);
      }
      on(type, listener, target) {
        this.component.node.on(type, listener, target);
      }
      once(type, listener, target) {
        this.component.node.once(type, listener, target);
      }
      off(type, listener, target) {
        this.component.node.off(type, listener, target);
      }
      emit(type, ...data) {
        this.component.node.emit(type, ...data);
      }
      onEventCenter(type, listener) {
        EventCenter.I.on(type, listener, this);
      }
      offEventCenter(type, listener) {
        EventCenter.I.off(type, listener, this);
      }
      emitEventCenter(type, ...data) {
        EventCenter.I.emit(type, ...data);
      }
      onceEventCenter(type, listener) {
        EventCenter.I.once(type, listener, this);
      }
      clearEventCenter() {
        EventCenter.I.clear(this);
      }
    };
    _Container.showDebug = false;
    Container = _Container;
  }
});

// assets/scripts/framework/platform/PlatformSDK.ts
var PlatformSDK_exports = {};
__export(PlatformSDK_exports, {
  PlatformSDK: () => PlatformSDK
});
var WX, inMiniGame, PlatformSDK;
var init_PlatformSDK = __esm({
  "assets/scripts/framework/platform/PlatformSDK.ts"() {
    inMiniGame = typeof wx !== "undefined";
    if (inMiniGame) {
      WX = wx;
    }
    PlatformSDK = {
      inMiniGame,
      ...WX
      // 以下是自定义的接口
    };
  }
});

// assets/scripts/framework/utils/UtilsHelper.ts
var UtilsHelper_exports = {};
__export(UtilsHelper_exports, {
  EPlatform: () => EPlatform,
  UtilsHelper: () => UtilsHelper
});
var import_cc, import_env, EPlatform, _UtilsHelper, UtilsHelper;
var init_UtilsHelper = __esm({
  "assets/scripts/framework/utils/UtilsHelper.ts"() {
    import_cc = require("cc");
    import_env = require("cc/env");
    init_PlatformSDK();
    init_CoroutineUtils();
    EPlatform = /* @__PURE__ */ ((EPlatform3) => {
      EPlatform3[EPlatform3["Windows"] = 0] = "Windows";
      EPlatform3[EPlatform3["Android"] = 1] = "Android";
      EPlatform3[EPlatform3["iOS"] = 2] = "iOS";
      return EPlatform3;
    })(EPlatform || {});
    _UtilsHelper = class _UtilsHelper {
      static tryPraseBoolean(val, defVal) {
        return val != null ? val : defVal;
      }
      static instance(type, ...args) {
        return new type(...args);
      }
      static getPlatform() {
        if (!navigator || !navigator.userAgent) {
          return 0 /* Windows */;
        }
        var u = navigator.userAgent;
        var isAndroid = u.indexOf("Android") > -1 || u.indexOf("Adr") > -1;
        if (isAndroid) {
          return 1 /* Android */;
        }
        var isiOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/);
        if (isiOS) {
          return 2 /* iOS */;
        }
        var isWindows = u.match(/.*Windows.*/gi);
        if (isWindows) {
          return 0 /* Windows */;
        }
      }
      static getGID() {
        return _UtilsHelper._gid++;
      }
      static setChildLayer(node, layer, depth = 0) {
        if (depth == 0) {
          if (layer) {
            node["_old_lyr_"] = node.layer;
            node.layer = layer;
          } else {
            node.layer = node["_old_lyr_"];
            delete node["_old_lyr_"];
          }
        }
        let children = node.children;
        for (let i = 0; i < children.length; i++) {
          let child = children[i];
          if (layer) {
            child["_old_lyr_"] = child.layer;
            child.layer = layer;
          } else {
            child.layer = child["_old_lyr_"];
            delete child["_old_lyr_"];
          }
          this.setChildLayer(child, layer, depth + 1);
        }
      }
      static toWxFile(arrayBuffer, size, type = "png") {
        let canvas = wx.createCanvas();
        let width = canvas.width = Math.floor(size.width);
        let height = canvas.height = Math.floor(size.height);
        let ctx = canvas.getContext("2d");
        let imageU8Data = new Uint8Array(arrayBuffer);
        let rowBytes = width * 4;
        let rowBytesh = height * 4;
        for (let row = 0; row < rowBytesh; row++) {
          let sRow = height - 1 - row;
          let imageData = ctx.createImageData(width, 1);
          let start = sRow * rowBytes;
          for (let i = 0; i < rowBytes; i++) {
            imageData.data[i] = imageU8Data[start + i];
          }
          ctx.putImageData(imageData, 0, row);
        }
        if (type == "png" && canvas.style) {
          canvas.style.backgroundColor = null;
        }
        let tempFilePath = canvas.toTempFilePathSync({
          x: 0,
          y: 0,
          width,
          height,
          destWidth: width,
          destHeight: height
        });
        return tempFilePath;
      }
      static copyTo(from, to) {
        if (!from) {
          return;
        }
        let keys = Object.keys(from);
        keys.forEach((key) => {
          let field = from[key];
          if (Array.isArray(field)) {
            to[key] = [];
            for (let i = 0; i < field.length; i++) {
              let item = field[i];
              if (item && typeof item == "object") {
                to[key][i] = {};
                this.copyTo(item, to[key][i]);
              } else {
                to[key][i] = item;
              }
            }
          } else if (field && typeof field === "object") {
            if (!to[key]) to[key] = {};
            this.copyTo(field, to[key]);
          } else {
            to[key] = field;
          }
        });
        return to;
      }
      /** 复制一份非引用的新数据 */
      static clone(obj) {
        return JSON.parse(JSON.stringify(obj));
      }
      static async playAnimation(anim, name) {
        let next = false;
        anim.once(import_cc.Animation.EventType.FINISHED, () => {
          next = true;
        }, this);
        if (typeof name == "string") {
          anim.play(name);
        } else {
          anim.play(anim.clips[name].name);
        }
        await CoroutineUtils.until(() => next);
      }
      static async playEffect(skeleton, name, loop = false, trackIndex = 0, timeout = 5) {
        let next = false;
        if (typeof name == "string") {
          skeleton.setAnimation(trackIndex, name, loop);
        } else {
          if (!skeleton.skeletonData) {
            console.error("skeleton.skeletonData is null");
            return;
          }
          let anims = skeleton.skeletonData.getAnimsEnum();
          let keys = Object.keys(anims);
          skeleton.setAnimation(trackIndex, keys[name], loop);
        }
        if (!loop) {
          skeleton.setCompleteListener((te) => {
            next = true;
          });
          await CoroutineUtils.until(() => {
            var _a;
            return next || !((_a = skeleton.node) == null ? void 0 : _a.active);
          }, timeout);
        }
      }
      /**
       * 
       * @param skeleton 
       * @param alpha 0-1
       */
      static setEffectAlpha(skeleton, alpha) {
        let color = skeleton.color;
        color.a = alpha * 255;
        skeleton.color = color;
      }
      /**
       * 设置节点下所有特效的透明度
       * @param node 
       * @param alpha 
       */
      static setAllEffectAlpha(node, alpha) {
        for (let child in node.children) {
          let childNode = node.children[child];
          let ske = childNode.getComponent(import_cc.sp.Skeleton);
          if (ske) {
            this.setEffectAlpha(ske, alpha);
          }
          this.setAllEffectAlpha(childNode, alpha);
        }
      }
      static restart() {
        if (import_env.DEBUG) {
          location.reload();
        } else {
          if (PlatformSDK.inMiniGame) {
            PlatformSDK.restartMiniProgram({});
          }
        }
      }
    };
    _UtilsHelper._gid = 0;
    UtilsHelper = _UtilsHelper;
  }
});

// assets/scripts/framework/common/Timer.ts
var Timer_exports = {};
__export(Timer_exports, {
  LaterHandler: () => LaterHandler,
  Timer: () => Timer,
  TimerHandler: () => TimerHandler
});
var import_cc2, ccclass, property, Timer, Handler2, TimerHandler, LaterHandler, _CallLater, CallLater;
var init_Timer = __esm({
  "assets/scripts/framework/common/Timer.ts"() {
    import_cc2 = require("cc");
    init_UtilsHelper();
    ({ ccclass, property } = import_cc2._decorator);
    Timer = class extends import_cc2.Component {
      constructor() {
        super();
        this.scale = 1;
        this.currTimer = Date.now();
        this.unscaleTimer = Date.now();
        this.currFrame = 0;
        this._delta = 0;
        this._unscaleDelta = 0;
        this._lastTimer = Date.now();
        this._map = [];
        this._handlers = [];
        this._temp = [];
        this._count = 0;
        this.scale = 1;
        this.currTimer = Date.now();
        this.unscaleTimer = Date.now();
        this.currFrame = 0;
        this._delta = 0;
        this._unscaleDelta = 0;
        this._lastTimer = Date.now();
        this._map = [];
        this._handlers = [];
        this._temp = [];
        this._count = 0;
      }
      static get inst() {
        if (this._inst == null) {
          var node = new import_cc2.Node("Timer");
          import_cc2.director.getScene().addChild(node);
          import_cc2.game.addPersistRootNode(node);
          this._inst = node.addComponent(Timer);
        }
        return this._inst;
      }
      start() {
        let directorTicker = import_cc2.director.tick;
        import_cc2.director.tick = (dt) => {
          try {
            directorTicker.call(import_cc2.director, dt * this.scale);
          } catch (e) {
            console.error(e);
          }
        };
      }
      /**
       * 每帧间隔时间, 包含暂停时间(ms)
       */
      get delta() {
        return this._delta;
      }
      get unscaleDelta() {
        return this._unscaleDelta;
      }
      update(dt) {
        if (this.scale <= 0) {
          this._lastTimer = Date.now();
          this._delta = 0;
          this._unscaleDelta = 0;
          return;
        }
        var frame = this.currFrame = this.currFrame + this.scale;
        var now = Date.now();
        this._unscaleDelta = now - this._lastTimer;
        this.unscaleTimer += this._unscaleDelta;
        var awake = this._unscaleDelta > 3e4;
        this._delta = this._unscaleDelta * this.scale;
        this.currTimer = this.currTimer + this._delta;
        var timer = this.currTimer;
        this._lastTimer = now;
        var handlers = this._handlers;
        this._count = 0;
        for (var i = 0, n = handlers.length; i < n; i++) {
          var handler = handlers[i];
          if (handler.method !== null) {
            var t = handler.useFrame ? frame : timer;
            if (t >= handler.exeTime) {
              if (handler.repeat) {
                if (!handler.jumpFrame || awake) {
                  handler.exeTime += handler.delay;
                  handler.run(false);
                  if (t > handler.exeTime) {
                    handler.exeTime += Math.ceil((t - handler.exeTime) / handler.delay) * handler.delay;
                  }
                } else {
                  while (t >= handler.exeTime) {
                    handler.exeTime += handler.delay;
                    handler.run(false);
                  }
                }
              } else {
                handler.run(true);
              }
            }
          } else {
            this._count++;
          }
        }
        if (this._count > 30 || frame % 200 === 0)
          this._clearHandlers();
        CallLater.inst._update();
      }
      _clearHandlers() {
        var handlers = this._handlers;
        for (var i = 0, n = handlers.length; i < n; i++) {
          var handler = handlers[i];
          if (handler.method !== null)
            this._temp.push(handler);
          else
            this._recoverHandler(handler);
        }
        this._handlers = this._temp;
        handlers.length = 0;
        this._temp = handlers;
      }
      _recoverHandler(handler) {
        if (this._map[handler.key] == handler)
          this._map[handler.key] = null;
        handler.clear();
        Timer._pool.push(handler);
      }
      _create(useFrame, repeat, delay, method, caller, args, coverBefore) {
        if (!delay) {
          method.apply(caller, args);
          return null;
        }
        if (coverBefore) {
          var handler = this._getHandler(method, caller);
          if (handler) {
            handler.repeat = repeat;
            handler.useFrame = useFrame;
            handler.delay = delay;
            handler.caller = caller;
            handler.method = method;
            handler.args = args;
            handler.exeTime = delay + (useFrame ? this.currFrame : this.currTimer + Date.now() - this._lastTimer);
            return handler;
          }
        }
        handler = Timer._pool.length > 0 ? Timer._pool.pop() : new TimerHandler();
        handler.repeat = repeat;
        handler.useFrame = useFrame;
        handler.delay = delay;
        handler.caller = caller;
        handler.method = method;
        handler.args = args;
        handler.exeTime = delay + (useFrame ? this.currFrame : this.currTimer + Date.now() - this._lastTimer);
        this._indexHandler(handler);
        this._handlers.push(handler);
        return handler;
      }
      _indexHandler(handler) {
        var caller = handler.caller;
        var method = handler.method;
        var cid = caller ? caller.$_GID || (caller.$_GID = UtilsHelper.getGID()) : 0;
        var mid = method.$_TID || (method.$_TID = Timer._mid++ * 1e5);
        handler.key = cid + mid;
        this._map[handler.key] = handler;
      }
      /**
       * 一次延迟
       * @param delay 延迟时间，单位毫秒
       * @param caller 
       * @param method 
       * @param args 
       * @param coverBefore 
       */
      once(delay, method, caller, args = null, coverBefore = true) {
        this._create(false, false, delay, method, caller, args, coverBefore);
      }
      /**
       * 循环
       * @param delay  延迟时间，单位毫秒
       * @param method 
       * @param caller 
       * @param args 
       * @param coverBefore 
       * @param jumpFrame 
       */
      loop(delay, method, caller, args = null, coverBefore = true, jumpFrame = false) {
        var handler = this._create(false, true, delay, method, caller, args, coverBefore);
        if (handler)
          handler.jumpFrame = jumpFrame;
      }
      /**
       * 一次帧延迟
       * @param delay  延迟时间，单位毫秒
       * @param method 
       * @param caller 
       * @param args 
       * @param coverBefore 
       */
      frameOnce(delay, method, caller, args = null, coverBefore = true) {
        this._create(true, false, delay, method, caller, args, coverBefore);
      }
      /**
       * 每帧循环
       * @param delay  延迟时间，单位毫秒
       * @param method 
       * @param caller 
       * @param args 
       * @param coverBefore 
       */
      frameLoop(delay, method, caller, args = null, coverBefore = true) {
        this._create(true, true, delay, method, caller, args, coverBefore);
      }
      toString() {
        return " handlers:" + this._handlers.length + " pool:" + Timer._pool.length;
      }
      /**
       * 移除timer
       * @param method 
       * @param caller 
       */
      clear(method, caller) {
        var handler = this._getHandler(method, caller);
        if (handler) {
          this._map[handler.key] = null;
          handler.key = 0;
          handler.clear();
        }
      }
      /**
       * 移除所有timer
       * @param caller 
       * @returns 
       */
      clearAll(caller) {
        if (!caller)
          return;
        for (var i = 0, n = this._handlers.length; i < n; i++) {
          var handler = this._handlers[i];
          if (handler.caller === caller) {
            this._map[handler.key] = null;
            handler.key = 0;
            handler.clear();
          }
        }
      }
      _getHandler(method, caller) {
        var cid = caller ? caller.$_GID || (caller.$_GID = UtilsHelper.getGID()) : 0;
        var mid = method.$_TID || (method.$_TID = Timer._mid++ * 1e5);
        return this._map[cid + mid];
      }
      callLater(method, caller, args = null) {
        CallLater.inst.callLater(method, caller, args);
      }
      runCallLater(method, caller) {
        CallLater.inst.runCallLater(method, caller);
      }
      runTimer(method, caller) {
        var handler = this._getHandler(method, caller);
        if (handler && handler.method != null) {
          this._map[handler.key] = null;
          handler.run(true);
        }
      }
      pause() {
        this.scale = 0;
      }
      resume() {
        this.scale = 1;
      }
    };
    Timer.gSysTimer = null;
    Timer._pool = [];
    Timer._mid = 1;
    Timer = __decorateClass([
      ccclass("Timer")
    ], Timer);
    Handler2 = class {
      constructor() {
        this.repeat = 0;
        this.useFrame = false;
        this.delay = 0;
        this.exeTime = 0;
        this.jumpFrame = false;
        this.key = 0;
        this.caller = null;
        this.method = null;
        this.args = null;
      }
      clear() {
      }
      run(withClear) {
      }
    };
    TimerHandler = class extends Handler2 {
      clear() {
        this.caller = null;
        this.method = null;
        this.args = null;
      }
      run(withClear) {
        var caller = this.caller;
        if (caller && caller.destroyed)
          return this.clear();
        var method = this.method;
        var args = this.args;
        withClear && this.clear();
        if (method == null)
          return;
        args ? method.apply(caller, args) : method.call(caller);
      }
    };
    LaterHandler = class extends Handler2 {
      clear() {
        this.caller = null;
        this.method = null;
        this.args = null;
      }
      run() {
        var caller = this.caller;
        if (caller && caller.destroyed)
          return this.clear();
        var method = this.method;
        var args = this.args;
        if (method == null)
          return;
        args ? method.apply(caller, args) : method.call(caller);
      }
    };
    _CallLater = class _CallLater {
      constructor() {
        this._pool = [];
        this._map = {};
        this._laters = [];
        this._pool = [];
        this._map = {};
        this._laters = [];
      }
      _update() {
        let laters = this._laters;
        let len = laters.length;
        if (len > 0) {
          for (let i = 0, n = len - 1; i <= n; i++) {
            let handler = laters[i];
            this._map[handler.key] = null;
            if (handler.method !== null) {
              handler.run();
              handler.clear();
            }
            this._pool.push(handler);
            i === n && (n = laters.length - 1);
          }
          laters.length = 0;
        }
      }
      _getHandler(method, caller) {
        var cid = caller ? caller.$_GID || (caller.$_GID = UtilsHelper.getGID()) : 0;
        var mid = method.$_TID || (method.$_TID = Timer._mid++);
        return this._map[cid + "." + mid];
      }
      callLater(method, caller, args = null) {
        if (this._getHandler(method, caller) == null) {
          let handler;
          if (this._pool.length)
            handler = this._pool.pop();
          else
            handler = new LaterHandler();
          handler.caller = caller;
          handler.method = method;
          handler.args = args;
          var cid = caller ? caller.$_GID : 0;
          var mid = method["$_TID"];
          handler.key = cid + "." + mid;
          this._map[handler.key] = handler;
          this._laters.push(handler);
        }
      }
      runCallLater(method, caller) {
        var handler = this._getHandler(method, caller);
        if (handler && handler.method != null) {
          this._map[handler.key] = null;
          handler.run();
          handler.clear();
        }
      }
    };
    _CallLater.inst = new _CallLater();
    CallLater = _CallLater;
  }
});

// assets/scripts/framework/utils/CoroutineUtils.ts
var CoroutineUtils_exports = {};
__export(CoroutineUtils_exports, {
  CoroutineUtils: () => CoroutineUtils
});
var import_cc3, CoroutineUtils;
var init_CoroutineUtils = __esm({
  "assets/scripts/framework/utils/CoroutineUtils.ts"() {
    import_cc3 = require("cc");
    init_Timer();
    CoroutineUtils = class {
      /** 等待一帧 */
      static oneframe() {
        return new Promise((resolve, reject) => {
          Timer.inst.frameOnce(1, resolve, this);
        });
      }
      /** 等待帧结束 */
      static endframe() {
        return new Promise((resolve, reject) => {
          import_cc3.director.once(import_cc3.Director.EVENT_END_FRAME, resolve, this);
        });
      }
      /** 等待num帧 */
      static waitframe(num) {
        return new Promise((resolve, reject) => {
          Timer.inst.frameOnce(num, resolve, this);
        });
      }
      /** 等待成功 */
      static until(condition, timeout = 0) {
        let timer = 0;
        return new Promise((resolve, reject) => {
          let func = () => {
            if (condition() || timeout > 0 && timer >= timeout) {
              Timer.inst.clear(func, this);
              resolve();
            }
            timer += Timer.inst.delta / 1e3;
          };
          Timer.inst.frameLoop(1, func, this);
        });
      }
      /** 延迟指定时间（秒） */
      static wait(time = 1) {
        return new Promise((resolve, reject) => {
          Timer.inst.once(time * 1e3, resolve, this);
        });
      }
    };
  }
});

// assets/scripts/framework/common/EventCenter.ts
var EventCenter_exports = {};
__export(EventCenter_exports, {
  EventCenter: () => EventCenter
});
var import_cc4, ccclass2, property2, EventHandler2, EventHandlerPool, EventCenter;
var init_EventCenter = __esm({
  "assets/scripts/framework/common/EventCenter.ts"() {
    import_cc4 = require("cc");
    init_PoolManager();
    init_Container();
    init_CoroutineUtils();
    ({ ccclass: ccclass2, property: property2 } = import_cc4._decorator);
    EventHandler2 = class {
      createFromPool(data) {
      }
      fromPool() {
        this.handler = null;
        this.target = null;
        this.once = false;
      }
      toPool() {
      }
    };
    EventHandlerPool = new PoolManager(EventHandler2);
    EventCenter = class {
      constructor() {
        this._handlers = {};
      }
      /**
       * 监听事件
       * @param {string} eventName 事件名称
       * @param {function} handler 监听函数
       * @param {object} target 监听目标
       */
      on(eventName, handler, target) {
        var handlerList = this._handlers[eventName];
        if (!handlerList) {
          handlerList = [];
          this._handlers[eventName] = handlerList;
        }
        for (var i = 0; i < handlerList.length; i++) {
          if (handlerList[i] && handlerList[i].handler == handler && handlerList[i].target == target) {
            return i;
          }
        }
        var objHandler = EventHandlerPool.get();
        objHandler.handler = handler;
        objHandler.target = target;
        for (var i = 0; i < handlerList.length; i++) {
          if (!handlerList[i]) {
            handlerList[i] = objHandler;
            return i;
          }
        }
        handlerList.push(objHandler);
        return handlerList.length;
      }
      /**
       * 监听事件
       * @param {string} eventName 事件名称
       * @param {function} handler 监听函数
       * @param {object} target 监听目标
       */
      once(eventName, handler, target) {
        var handlerList = this._handlers[eventName];
        if (!handlerList) {
          handlerList = [];
          this._handlers[eventName] = handlerList;
        }
        for (var i = 0; i < handlerList.length; i++) {
          if (handlerList[i] && handlerList[i].handler == handler && handlerList[i].target == target) {
            return i;
          }
        }
        var objHandler = EventHandlerPool.get();
        objHandler.handler = handler;
        objHandler.target = target;
        objHandler.once = true;
        for (var i = 0; i < handlerList.length; i++) {
          if (!handlerList[i]) {
            handlerList[i] = objHandler;
            return i;
          }
        }
        handlerList.push(objHandler);
        return handlerList.length;
      }
      /**
       * 取消监听
       * @param {string} eventName 监听事件
       * @param {function} handler 监听函数
       * @param {object} target 监听目标
       */
      off(eventName, handler, target) {
        var handlerList = this._handlers[eventName];
        if (!handlerList) {
          return;
        }
        for (var i = 0; i < handlerList.length; i++) {
          var oldObj = handlerList[i];
          if (oldObj.handler === handler && (!target || target === oldObj.target)) {
            handlerList.splice(i, 1);
            EventHandlerPool.put(oldObj);
            break;
          }
        }
      }
      clear(target) {
        let keys = Object.keys(this._handlers);
        for (let ki = 0; ki < keys.length; ki++) {
          let key = keys[ki];
          let newHandles = [];
          let handlerList = this._handlers[key].slice();
          for (var i = 0; i < handlerList.length; i++) {
            var oldObj = handlerList[i];
            if (!target || target && target == oldObj.target) {
              EventHandlerPool.put(oldObj);
            } else {
              newHandles.push(oldObj);
            }
          }
          this._handlers[key] = newHandles;
        }
      }
      /**
       * 延迟发送
       * @param eventName 
       * @param delay 延迟时间(单位秒)
       * @param args 
       */
      async emitDelay(eventName, delay, ...args) {
        if (delay && delay > 0) {
          await CoroutineUtils.wait(delay);
        }
        this.emit(eventName, ...args);
      }
      /**
       * 分发事件
       * @param {string} eventName 分发事件名
       * @param  {...any} params 分发事件参数
       */
      emit(eventName, ...args) {
        var handlerList = this._handlers[eventName];
        if (!handlerList) {
          return;
        }
        let handles = handlerList.slice();
        for (let i = 0; i < handles.length; i++) {
          var objHandler = handles[i];
          if (objHandler.target instanceof Container) {
            let cont = objHandler.target;
            if (cont.destoried || !(0, import_cc4.isValid)(cont.component.node)) {
              continue;
            }
          } else if (objHandler.target instanceof import_cc4.Node) {
            if (!(0, import_cc4.isValid)(objHandler.target)) {
              continue;
            }
          } else if (objHandler.target instanceof import_cc4.Component) {
            if (!(0, import_cc4.isValid)(objHandler.target.node)) {
              continue;
            }
          }
          if (objHandler.handler) {
            objHandler.handler.call(objHandler.target, ...args);
            if (objHandler.once) {
              let idx = handlerList.indexOf(objHandler);
              handlerList.splice(idx, 1);
            }
          }
        }
      }
      async waitEventValue(eventName, v) {
        let value;
        while (v != value) {
          value = await this.waitEvent(eventName);
        }
      }
      async waitEvent(eventName) {
        return new Promise((resolve) => {
          this.once(eventName, resolve, this);
        });
      }
      static get I() {
        if (!this._instance) {
          window["EC"] = this;
          this._instance = new EventCenter();
        }
        return this._instance;
      }
    };
    EventCenter = __decorateClass([
      ccclass2("EventCenter")
    ], EventCenter);
  }
});

// node_modules/fairygui-cc/dist/fairygui.mjs
function borrowEvent(type, bubbles) {
  let evt;
  if (eventPool.length) {
    evt = eventPool.pop();
    evt.type = type;
    evt.bubbles = bubbles;
  } else {
    evt = new Event(type, bubbles);
  }
  return evt;
}
function returnEvent(evt) {
  evt.initiator = null;
  evt.unuse();
  eventPool.push(evt);
}
function evaluateEase(easeType, time, duration, overshootOrAmplitude, period) {
  switch (easeType) {
    case EaseType.Linear:
      return time / duration;
    case EaseType.SineIn:
      return -Math.cos(time / duration * _PiOver2) + 1;
    case EaseType.SineOut:
      return Math.sin(time / duration * _PiOver2);
    case EaseType.SineInOut:
      return -0.5 * (Math.cos(Math.PI * time / duration) - 1);
    case EaseType.QuadIn:
      return (time /= duration) * time;
    case EaseType.QuadOut:
      return -(time /= duration) * (time - 2);
    case EaseType.QuadInOut:
      if ((time /= duration * 0.5) < 1)
        return 0.5 * time * time;
      return -0.5 * (--time * (time - 2) - 1);
    case EaseType.CubicIn:
      return (time /= duration) * time * time;
    case EaseType.CubicOut:
      return (time = time / duration - 1) * time * time + 1;
    case EaseType.CubicInOut:
      if ((time /= duration * 0.5) < 1)
        return 0.5 * time * time * time;
      return 0.5 * ((time -= 2) * time * time + 2);
    case EaseType.QuartIn:
      return (time /= duration) * time * time * time;
    case EaseType.QuartOut:
      return -((time = time / duration - 1) * time * time * time - 1);
    case EaseType.QuartInOut:
      if ((time /= duration * 0.5) < 1)
        return 0.5 * time * time * time * time;
      return -0.5 * ((time -= 2) * time * time * time - 2);
    case EaseType.QuintIn:
      return (time /= duration) * time * time * time * time;
    case EaseType.QuintOut:
      return (time = time / duration - 1) * time * time * time * time + 1;
    case EaseType.QuintInOut:
      if ((time /= duration * 0.5) < 1)
        return 0.5 * time * time * time * time * time;
      return 0.5 * ((time -= 2) * time * time * time * time + 2);
    case EaseType.ExpoIn:
      return time == 0 ? 0 : Math.pow(2, 10 * (time / duration - 1));
    case EaseType.ExpoOut:
      if (time == duration)
        return 1;
      return -Math.pow(2, -10 * time / duration) + 1;
    case EaseType.ExpoInOut:
      if (time == 0)
        return 0;
      if (time == duration)
        return 1;
      if ((time /= duration * 0.5) < 1)
        return 0.5 * Math.pow(2, 10 * (time - 1));
      return 0.5 * (-Math.pow(2, -10 * --time) + 2);
    case EaseType.CircIn:
      return -(Math.sqrt(1 - (time /= duration) * time) - 1);
    case EaseType.CircOut:
      return Math.sqrt(1 - (time = time / duration - 1) * time);
    case EaseType.CircInOut:
      if ((time /= duration * 0.5) < 1)
        return -0.5 * (Math.sqrt(1 - time * time) - 1);
      return 0.5 * (Math.sqrt(1 - (time -= 2) * time) + 1);
    case EaseType.ElasticIn:
      var s0;
      if (time == 0)
        return 0;
      if ((time /= duration) == 1)
        return 1;
      if (period == 0)
        period = duration * 0.3;
      if (overshootOrAmplitude < 1) {
        overshootOrAmplitude = 1;
        s0 = period / 4;
      } else
        s0 = period / _TwoPi * Math.asin(1 / overshootOrAmplitude);
      return -(overshootOrAmplitude * Math.pow(2, 10 * (time -= 1)) * Math.sin((time * duration - s0) * _TwoPi / period));
    case EaseType.ElasticOut:
      var s1;
      if (time == 0)
        return 0;
      if ((time /= duration) == 1)
        return 1;
      if (period == 0)
        period = duration * 0.3;
      if (overshootOrAmplitude < 1) {
        overshootOrAmplitude = 1;
        s1 = period / 4;
      } else
        s1 = period / _TwoPi * Math.asin(1 / overshootOrAmplitude);
      return overshootOrAmplitude * Math.pow(2, -10 * time) * Math.sin((time * duration - s1) * _TwoPi / period) + 1;
    case EaseType.ElasticInOut:
      var s;
      if (time == 0)
        return 0;
      if ((time /= duration * 0.5) == 2)
        return 1;
      if (period == 0)
        period = duration * (0.3 * 1.5);
      if (overshootOrAmplitude < 1) {
        overshootOrAmplitude = 1;
        s = period / 4;
      } else
        s = period / _TwoPi * Math.asin(1 / overshootOrAmplitude);
      if (time < 1)
        return -0.5 * (overshootOrAmplitude * Math.pow(2, 10 * (time -= 1)) * Math.sin((time * duration - s) * _TwoPi / period));
      return overshootOrAmplitude * Math.pow(2, -10 * (time -= 1)) * Math.sin((time * duration - s) * _TwoPi / period) * 0.5 + 1;
    case EaseType.BackIn:
      return (time /= duration) * time * ((overshootOrAmplitude + 1) * time - overshootOrAmplitude);
    case EaseType.BackOut:
      return (time = time / duration - 1) * time * ((overshootOrAmplitude + 1) * time + overshootOrAmplitude) + 1;
    case EaseType.BackInOut:
      if ((time /= duration * 0.5) < 1)
        return 0.5 * (time * time * (((overshootOrAmplitude *= 1.525) + 1) * time - overshootOrAmplitude));
      return 0.5 * ((time -= 2) * time * (((overshootOrAmplitude *= 1.525) + 1) * time + overshootOrAmplitude) + 2);
    case EaseType.BounceIn:
      return bounce_easeIn(time, duration);
    case EaseType.BounceOut:
      return bounce_easeOut(time, duration);
    case EaseType.BounceInOut:
      return bounce_easeInOut(time, duration);
    default:
      return -(time /= duration) * (time - 2);
  }
}
function bounce_easeIn(time, duration) {
  return 1 - bounce_easeOut(duration - time, duration);
}
function bounce_easeOut(time, duration) {
  if ((time /= duration) < 1 / 2.75) {
    return 7.5625 * time * time;
  }
  if (time < 2 / 2.75) {
    return 7.5625 * (time -= 1.5 / 2.75) * time + 0.75;
  }
  if (time < 2.5 / 2.75) {
    return 7.5625 * (time -= 2.25 / 2.75) * time + 0.9375;
  }
  return 7.5625 * (time -= 2.625 / 2.75) * time + 0.984375;
}
function bounce_easeInOut(time, duration) {
  if (time < duration * 0.5) {
    return bounce_easeIn(time * 2, duration) * 0.5;
  }
  return bounce_easeOut(time * 2 - duration, duration) * 0.5 + 0.5;
}
function getFontByName(name) {
  return _fontRegistry[name];
}
function createGear(owner, index) {
  let ret = new GearClasses[index]();
  ret._owner = owner;
  return ret;
}
function updateScaler() {
  let size = import_cc5.screen.windowSize;
  size.width /= import_cc5.view.getScaleX();
  size.height /= import_cc5.view.getScaleY();
  UIContentScaler.rootSize.set(size);
  var ss = Math.max(import_cc5.view.getScaleX(), import_cc5.view.getScaleY());
  UIContentScaler.scaleFactor = ss;
  if (ss >= 3.5)
    UIContentScaler.scaleLevel = 3;
  else if (ss >= 2.5)
    UIContentScaler.scaleLevel = 2;
  else if (ss >= 1.5)
    UIContentScaler.scaleLevel = 1;
  else
    UIContentScaler.scaleLevel = 0;
}
function toGrayedColor(c) {
  let v = c.r * 0.299 + c.g * 0.587 + c.b * 0.114;
  return new import_cc5.Color(v, v, v, c.a);
}
function createAction(type) {
  switch (type) {
    case 0:
      return new PlayTransitionAction();
    case 1:
      return new ChangePageAction();
  }
  return null;
}
function easeFunc(t, d) {
  return (t = t / d - 1) * t * t + 1;
}
function distance(x1, y1, x2, y2) {
  return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}
var import_cc5, import_env2, ButtonMode, AutoSizeType, AlignType, VertAlignType, LoaderFillType, ListLayoutType, ListSelectionMode, OverflowType, PackageItemType, ObjectType, ProgressTitleType, ScrollBarDisplayType, ScrollType, FlipType, ChildrenRenderOrder, GroupLayoutType, PopupDirection, RelationType, FillMethod, FillOrigin, ObjectPropID, BlendMode, BlendModeUtils, factors, Event, eventPool, EaseType, GearBase, GearTweenConfig, GearAnimation, GearColor, GearDisplay, GearDisplay2, GearFontSize, GearIcon, Pool, _PiOver2, _TwoPi, TweenValue, s_vec2$5, GTweener, TweenManager, _activeTweens, _tweenerPool, _totalActiveTweens, _root, GTween, GearLook, GearSize, GearText, GearXY, RelationItem, RelationDef, Relations, UIConfig, _fontRegistry, GObject, GObjectPartner, GearClasses, s_vec2$4, s_vec3$1, s_rect$1, sGlobalDragStart, sGlobalRect, s_dragging, s_dragQuery, Decls$1, constructingDepth, GGroup, GGraph, Image, GImage, MovieClip, GMovieClip, UIContentScaler, RefMannager, PackageItem, TranslationHelper, ByteBuffer, PixelHitTest, PixelHitTestData, ChildHitArea, __awaiter$1, PathUtils, UIPackage, ItemTypeToAssetType, _instById, _instByName, _branch, _vars, Decls, UBBParser, defaultParser, GTextField, __awaiter, RichTextImageAtlas, imageAtlas, GRichTextField, InputProcessor, TouchInfo, s_vec3, s_vec3_2, ControllerAction, PlayTransitionAction, ChangePageAction, _nextPageId, Controller, Margin, ScrollPane, _gestureFlag, TWEEN_TIME_GO, TWEEN_TIME_DEFAULT, PULL_RATIO, s_vec2$3, s_rect, sEndPos, sOldChange, CurveType, GPathPoint, GPath, Transition, OPTION_IGNORE_DISPLAY_CONTROLLER, OPTION_AUTO_STOP_DISABLED, OPTION_AUTO_STOP_AT_END, ActionType, Item, TweenConfig, GComponent, s_vec2$2, Window, GRoot, GTextInput, MyEditBox, GObjectPool, SpritePool, GLoader, GLoader3D, GLabel, GButton, GList, s_n, GComboBox, GSlider, s_vec2$1, GProgressBar, GScrollBar, s_vec2, GTreeNode, GTree, s_list, UIObjectFactory;
var init_fairygui = __esm({
  "node_modules/fairygui-cc/dist/fairygui.mjs"() {
    import_cc5 = require("cc");
    import_env2 = require("cc/env");
    (function(ButtonMode2) {
      ButtonMode2[ButtonMode2["Common"] = 0] = "Common";
      ButtonMode2[ButtonMode2["Check"] = 1] = "Check";
      ButtonMode2[ButtonMode2["Radio"] = 2] = "Radio";
    })(ButtonMode || (ButtonMode = {}));
    (function(AutoSizeType2) {
      AutoSizeType2[AutoSizeType2["None"] = 0] = "None";
      AutoSizeType2[AutoSizeType2["Both"] = 1] = "Both";
      AutoSizeType2[AutoSizeType2["Height"] = 2] = "Height";
      AutoSizeType2[AutoSizeType2["Shrink"] = 3] = "Shrink";
    })(AutoSizeType || (AutoSizeType = {}));
    (function(AlignType2) {
      AlignType2[AlignType2["Left"] = 0] = "Left";
      AlignType2[AlignType2["Center"] = 1] = "Center";
      AlignType2[AlignType2["Right"] = 2] = "Right";
    })(AlignType || (AlignType = {}));
    (function(VertAlignType2) {
      VertAlignType2[VertAlignType2["Top"] = 0] = "Top";
      VertAlignType2[VertAlignType2["Middle"] = 1] = "Middle";
      VertAlignType2[VertAlignType2["Bottom"] = 2] = "Bottom";
    })(VertAlignType || (VertAlignType = {}));
    (function(LoaderFillType2) {
      LoaderFillType2[LoaderFillType2["None"] = 0] = "None";
      LoaderFillType2[LoaderFillType2["Scale"] = 1] = "Scale";
      LoaderFillType2[LoaderFillType2["ScaleMatchHeight"] = 2] = "ScaleMatchHeight";
      LoaderFillType2[LoaderFillType2["ScaleMatchWidth"] = 3] = "ScaleMatchWidth";
      LoaderFillType2[LoaderFillType2["ScaleFree"] = 4] = "ScaleFree";
      LoaderFillType2[LoaderFillType2["ScaleNoBorder"] = 5] = "ScaleNoBorder";
    })(LoaderFillType || (LoaderFillType = {}));
    (function(ListLayoutType2) {
      ListLayoutType2[ListLayoutType2["SingleColumn"] = 0] = "SingleColumn";
      ListLayoutType2[ListLayoutType2["SingleRow"] = 1] = "SingleRow";
      ListLayoutType2[ListLayoutType2["FlowHorizontal"] = 2] = "FlowHorizontal";
      ListLayoutType2[ListLayoutType2["FlowVertical"] = 3] = "FlowVertical";
      ListLayoutType2[ListLayoutType2["Pagination"] = 4] = "Pagination";
    })(ListLayoutType || (ListLayoutType = {}));
    (function(ListSelectionMode2) {
      ListSelectionMode2[ListSelectionMode2["Single"] = 0] = "Single";
      ListSelectionMode2[ListSelectionMode2["Multiple"] = 1] = "Multiple";
      ListSelectionMode2[ListSelectionMode2["Multiple_SingleClick"] = 2] = "Multiple_SingleClick";
      ListSelectionMode2[ListSelectionMode2["None"] = 3] = "None";
    })(ListSelectionMode || (ListSelectionMode = {}));
    (function(OverflowType2) {
      OverflowType2[OverflowType2["Visible"] = 0] = "Visible";
      OverflowType2[OverflowType2["Hidden"] = 1] = "Hidden";
      OverflowType2[OverflowType2["Scroll"] = 2] = "Scroll";
    })(OverflowType || (OverflowType = {}));
    (function(PackageItemType2) {
      PackageItemType2[PackageItemType2["Image"] = 0] = "Image";
      PackageItemType2[PackageItemType2["MovieClip"] = 1] = "MovieClip";
      PackageItemType2[PackageItemType2["Sound"] = 2] = "Sound";
      PackageItemType2[PackageItemType2["Component"] = 3] = "Component";
      PackageItemType2[PackageItemType2["Atlas"] = 4] = "Atlas";
      PackageItemType2[PackageItemType2["Font"] = 5] = "Font";
      PackageItemType2[PackageItemType2["Swf"] = 6] = "Swf";
      PackageItemType2[PackageItemType2["Misc"] = 7] = "Misc";
      PackageItemType2[PackageItemType2["Unknown"] = 8] = "Unknown";
      PackageItemType2[PackageItemType2["Spine"] = 9] = "Spine";
      PackageItemType2[PackageItemType2["DragonBones"] = 10] = "DragonBones";
    })(PackageItemType || (PackageItemType = {}));
    (function(ObjectType2) {
      ObjectType2[ObjectType2["Image"] = 0] = "Image";
      ObjectType2[ObjectType2["MovieClip"] = 1] = "MovieClip";
      ObjectType2[ObjectType2["Swf"] = 2] = "Swf";
      ObjectType2[ObjectType2["Graph"] = 3] = "Graph";
      ObjectType2[ObjectType2["Loader"] = 4] = "Loader";
      ObjectType2[ObjectType2["Group"] = 5] = "Group";
      ObjectType2[ObjectType2["Text"] = 6] = "Text";
      ObjectType2[ObjectType2["RichText"] = 7] = "RichText";
      ObjectType2[ObjectType2["InputText"] = 8] = "InputText";
      ObjectType2[ObjectType2["Component"] = 9] = "Component";
      ObjectType2[ObjectType2["List"] = 10] = "List";
      ObjectType2[ObjectType2["Label"] = 11] = "Label";
      ObjectType2[ObjectType2["Button"] = 12] = "Button";
      ObjectType2[ObjectType2["ComboBox"] = 13] = "ComboBox";
      ObjectType2[ObjectType2["ProgressBar"] = 14] = "ProgressBar";
      ObjectType2[ObjectType2["Slider"] = 15] = "Slider";
      ObjectType2[ObjectType2["ScrollBar"] = 16] = "ScrollBar";
      ObjectType2[ObjectType2["Tree"] = 17] = "Tree";
      ObjectType2[ObjectType2["Loader3D"] = 18] = "Loader3D";
    })(ObjectType || (ObjectType = {}));
    (function(ProgressTitleType2) {
      ProgressTitleType2[ProgressTitleType2["Percent"] = 0] = "Percent";
      ProgressTitleType2[ProgressTitleType2["ValueAndMax"] = 1] = "ValueAndMax";
      ProgressTitleType2[ProgressTitleType2["Value"] = 2] = "Value";
      ProgressTitleType2[ProgressTitleType2["Max"] = 3] = "Max";
    })(ProgressTitleType || (ProgressTitleType = {}));
    (function(ScrollBarDisplayType2) {
      ScrollBarDisplayType2[ScrollBarDisplayType2["Default"] = 0] = "Default";
      ScrollBarDisplayType2[ScrollBarDisplayType2["Visible"] = 1] = "Visible";
      ScrollBarDisplayType2[ScrollBarDisplayType2["Auto"] = 2] = "Auto";
      ScrollBarDisplayType2[ScrollBarDisplayType2["Hidden"] = 3] = "Hidden";
    })(ScrollBarDisplayType || (ScrollBarDisplayType = {}));
    (function(ScrollType2) {
      ScrollType2[ScrollType2["Horizontal"] = 0] = "Horizontal";
      ScrollType2[ScrollType2["Vertical"] = 1] = "Vertical";
      ScrollType2[ScrollType2["Both"] = 2] = "Both";
    })(ScrollType || (ScrollType = {}));
    (function(FlipType2) {
      FlipType2[FlipType2["None"] = 0] = "None";
      FlipType2[FlipType2["Horizontal"] = 1] = "Horizontal";
      FlipType2[FlipType2["Vertical"] = 2] = "Vertical";
      FlipType2[FlipType2["Both"] = 3] = "Both";
    })(FlipType || (FlipType = {}));
    (function(ChildrenRenderOrder2) {
      ChildrenRenderOrder2[ChildrenRenderOrder2["Ascent"] = 0] = "Ascent";
      ChildrenRenderOrder2[ChildrenRenderOrder2["Descent"] = 1] = "Descent";
      ChildrenRenderOrder2[ChildrenRenderOrder2["Arch"] = 2] = "Arch";
    })(ChildrenRenderOrder || (ChildrenRenderOrder = {}));
    (function(GroupLayoutType2) {
      GroupLayoutType2[GroupLayoutType2["None"] = 0] = "None";
      GroupLayoutType2[GroupLayoutType2["Horizontal"] = 1] = "Horizontal";
      GroupLayoutType2[GroupLayoutType2["Vertical"] = 2] = "Vertical";
    })(GroupLayoutType || (GroupLayoutType = {}));
    (function(PopupDirection2) {
      PopupDirection2[PopupDirection2["Auto"] = 0] = "Auto";
      PopupDirection2[PopupDirection2["Up"] = 1] = "Up";
      PopupDirection2[PopupDirection2["Down"] = 2] = "Down";
    })(PopupDirection || (PopupDirection = {}));
    (function(RelationType2) {
      RelationType2[RelationType2["Left_Left"] = 0] = "Left_Left";
      RelationType2[RelationType2["Left_Center"] = 1] = "Left_Center";
      RelationType2[RelationType2["Left_Right"] = 2] = "Left_Right";
      RelationType2[RelationType2["Center_Center"] = 3] = "Center_Center";
      RelationType2[RelationType2["Right_Left"] = 4] = "Right_Left";
      RelationType2[RelationType2["Right_Center"] = 5] = "Right_Center";
      RelationType2[RelationType2["Right_Right"] = 6] = "Right_Right";
      RelationType2[RelationType2["Top_Top"] = 7] = "Top_Top";
      RelationType2[RelationType2["Top_Middle"] = 8] = "Top_Middle";
      RelationType2[RelationType2["Top_Bottom"] = 9] = "Top_Bottom";
      RelationType2[RelationType2["Middle_Middle"] = 10] = "Middle_Middle";
      RelationType2[RelationType2["Bottom_Top"] = 11] = "Bottom_Top";
      RelationType2[RelationType2["Bottom_Middle"] = 12] = "Bottom_Middle";
      RelationType2[RelationType2["Bottom_Bottom"] = 13] = "Bottom_Bottom";
      RelationType2[RelationType2["Width"] = 14] = "Width";
      RelationType2[RelationType2["Height"] = 15] = "Height";
      RelationType2[RelationType2["LeftExt_Left"] = 16] = "LeftExt_Left";
      RelationType2[RelationType2["LeftExt_Right"] = 17] = "LeftExt_Right";
      RelationType2[RelationType2["RightExt_Left"] = 18] = "RightExt_Left";
      RelationType2[RelationType2["RightExt_Right"] = 19] = "RightExt_Right";
      RelationType2[RelationType2["TopExt_Top"] = 20] = "TopExt_Top";
      RelationType2[RelationType2["TopExt_Bottom"] = 21] = "TopExt_Bottom";
      RelationType2[RelationType2["BottomExt_Top"] = 22] = "BottomExt_Top";
      RelationType2[RelationType2["BottomExt_Bottom"] = 23] = "BottomExt_Bottom";
      RelationType2[RelationType2["Size"] = 24] = "Size";
    })(RelationType || (RelationType = {}));
    (function(FillMethod2) {
      FillMethod2[FillMethod2["None"] = 0] = "None";
      FillMethod2[FillMethod2["Horizontal"] = 1] = "Horizontal";
      FillMethod2[FillMethod2["Vertical"] = 2] = "Vertical";
      FillMethod2[FillMethod2["Radial90"] = 3] = "Radial90";
      FillMethod2[FillMethod2["Radial180"] = 4] = "Radial180";
      FillMethod2[FillMethod2["Radial360"] = 5] = "Radial360";
    })(FillMethod || (FillMethod = {}));
    (function(FillOrigin2) {
      FillOrigin2[FillOrigin2["Top"] = 0] = "Top";
      FillOrigin2[FillOrigin2["Bottom"] = 1] = "Bottom";
      FillOrigin2[FillOrigin2["Left"] = 2] = "Left";
      FillOrigin2[FillOrigin2["Right"] = 3] = "Right";
    })(FillOrigin || (FillOrigin = {}));
    (function(ObjectPropID2) {
      ObjectPropID2[ObjectPropID2["Text"] = 0] = "Text";
      ObjectPropID2[ObjectPropID2["Icon"] = 1] = "Icon";
      ObjectPropID2[ObjectPropID2["Color"] = 2] = "Color";
      ObjectPropID2[ObjectPropID2["OutlineColor"] = 3] = "OutlineColor";
      ObjectPropID2[ObjectPropID2["Playing"] = 4] = "Playing";
      ObjectPropID2[ObjectPropID2["Frame"] = 5] = "Frame";
      ObjectPropID2[ObjectPropID2["DeltaTime"] = 6] = "DeltaTime";
      ObjectPropID2[ObjectPropID2["TimeScale"] = 7] = "TimeScale";
      ObjectPropID2[ObjectPropID2["FontSize"] = 8] = "FontSize";
      ObjectPropID2[ObjectPropID2["Selected"] = 9] = "Selected";
    })(ObjectPropID || (ObjectPropID = {}));
    (function(BlendMode2) {
      BlendMode2[BlendMode2["Normal"] = 0] = "Normal";
      BlendMode2[BlendMode2["None"] = 1] = "None";
      BlendMode2[BlendMode2["Add"] = 2] = "Add";
      BlendMode2[BlendMode2["Multiply"] = 3] = "Multiply";
      BlendMode2[BlendMode2["Screen"] = 4] = "Screen";
      BlendMode2[BlendMode2["Erase"] = 5] = "Erase";
      BlendMode2[BlendMode2["Mask"] = 6] = "Mask";
      BlendMode2[BlendMode2["Below"] = 7] = "Below";
      BlendMode2[BlendMode2["Off"] = 8] = "Off";
      BlendMode2[BlendMode2["Custom1"] = 9] = "Custom1";
      BlendMode2[BlendMode2["Custom2"] = 10] = "Custom2";
      BlendMode2[BlendMode2["Custom3"] = 11] = "Custom3";
    })(BlendMode || (BlendMode = {}));
    BlendModeUtils = class {
      static apply(node, blendMode) {
        let f = factors[blendMode];
        let renderers = node.getComponentsInChildren(import_cc5.UIRenderer);
        renderers.forEach((element) => {
          element.srcBlendFactor = f[0];
          element.dstBlendFactor = f[1];
        });
      }
      static override(blendMode, srcFactor, dstFactor) {
        factors[blendMode][0] = srcFactor;
        factors[blendMode][1] = dstFactor;
      }
    };
    factors = [
      [import_cc5.gfx.BlendFactor.SRC_ALPHA, import_cc5.gfx.BlendFactor.ONE_MINUS_SRC_ALPHA],
      [import_cc5.gfx.BlendFactor.ONE, import_cc5.gfx.BlendFactor.ONE],
      [import_cc5.gfx.BlendFactor.SRC_ALPHA, import_cc5.gfx.BlendFactor.ONE],
      [import_cc5.gfx.BlendFactor.DST_COLOR, import_cc5.gfx.BlendFactor.ONE_MINUS_SRC_ALPHA],
      [import_cc5.gfx.BlendFactor.ONE, import_cc5.gfx.BlendFactor.ONE_MINUS_SRC_COLOR],
      [import_cc5.gfx.BlendFactor.ZERO, import_cc5.gfx.BlendFactor.ONE_MINUS_SRC_ALPHA],
      [import_cc5.gfx.BlendFactor.ZERO, import_cc5.gfx.BlendFactor.SRC_ALPHA],
      [import_cc5.gfx.BlendFactor.ONE_MINUS_DST_ALPHA, import_cc5.gfx.BlendFactor.DST_ALPHA],
      [import_cc5.gfx.BlendFactor.ONE, import_cc5.gfx.BlendFactor.ZERO],
      [import_cc5.gfx.BlendFactor.SRC_ALPHA, import_cc5.gfx.BlendFactor.ONE_MINUS_SRC_ALPHA],
      [import_cc5.gfx.BlendFactor.SRC_ALPHA, import_cc5.gfx.BlendFactor.ONE_MINUS_SRC_ALPHA],
      [import_cc5.gfx.BlendFactor.SRC_ALPHA, import_cc5.gfx.BlendFactor.ONE_MINUS_SRC_ALPHA]
      //custom2
    ];
    Event = class extends import_cc5.Event {
      constructor(type, bubbles) {
        super(type, bubbles);
        this.pos = new import_cc5.Vec2();
        this.touchId = 0;
        this.clickCount = 0;
        this.button = 0;
        this.keyModifiers = 0;
        this.mouseWheelDelta = 0;
      }
      get sender() {
        return GObject.cast(this.currentTarget);
      }
      get isShiftDown() {
        return false;
      }
      get isCtrlDown() {
        return false;
      }
      captureTouch() {
        let obj = GObject.cast(this.currentTarget);
        if (obj)
          this._processor.addTouchMonitor(this.touchId, obj);
      }
    };
    Event.TOUCH_BEGIN = "fui_touch_begin";
    Event.TOUCH_MOVE = "fui_touch_move";
    Event.TOUCH_END = "fui_touch_end";
    Event.CLICK = "fui_click";
    Event.ROLL_OVER = "fui_roll_over";
    Event.ROLL_OUT = "fui_roll_out";
    Event.MOUSE_WHEEL = "fui_mouse_wheel";
    Event.DISPLAY = "fui_display";
    Event.UNDISPLAY = "fui_undisplay";
    Event.GEAR_STOP = "fui_gear_stop";
    Event.LINK = "fui_text_link";
    Event.Submit = "editing-return";
    Event.TEXT_CHANGE = "text-changed";
    Event.STATUS_CHANGED = "fui_status_changed";
    Event.XY_CHANGED = "fui_xy_changed";
    Event.SIZE_CHANGED = "fui_size_changed";
    Event.SIZE_DELAY_CHANGE = "fui_size_delay_change";
    Event.DRAG_START = "fui_drag_start";
    Event.DRAG_MOVE = "fui_drag_move";
    Event.DRAG_END = "fui_drag_end";
    Event.DROP = "fui_drop";
    Event.SCROLL = "fui_scroll";
    Event.SCROLL_END = "fui_scroll_end";
    Event.PULL_DOWN_RELEASE = "fui_pull_down_release";
    Event.PULL_UP_RELEASE = "fui_pull_up_release";
    Event.CLICK_ITEM = "fui_click_item";
    eventPool = new Array();
    (function(EaseType2) {
      EaseType2[EaseType2["Linear"] = 0] = "Linear";
      EaseType2[EaseType2["SineIn"] = 1] = "SineIn";
      EaseType2[EaseType2["SineOut"] = 2] = "SineOut";
      EaseType2[EaseType2["SineInOut"] = 3] = "SineInOut";
      EaseType2[EaseType2["QuadIn"] = 4] = "QuadIn";
      EaseType2[EaseType2["QuadOut"] = 5] = "QuadOut";
      EaseType2[EaseType2["QuadInOut"] = 6] = "QuadInOut";
      EaseType2[EaseType2["CubicIn"] = 7] = "CubicIn";
      EaseType2[EaseType2["CubicOut"] = 8] = "CubicOut";
      EaseType2[EaseType2["CubicInOut"] = 9] = "CubicInOut";
      EaseType2[EaseType2["QuartIn"] = 10] = "QuartIn";
      EaseType2[EaseType2["QuartOut"] = 11] = "QuartOut";
      EaseType2[EaseType2["QuartInOut"] = 12] = "QuartInOut";
      EaseType2[EaseType2["QuintIn"] = 13] = "QuintIn";
      EaseType2[EaseType2["QuintOut"] = 14] = "QuintOut";
      EaseType2[EaseType2["QuintInOut"] = 15] = "QuintInOut";
      EaseType2[EaseType2["ExpoIn"] = 16] = "ExpoIn";
      EaseType2[EaseType2["ExpoOut"] = 17] = "ExpoOut";
      EaseType2[EaseType2["ExpoInOut"] = 18] = "ExpoInOut";
      EaseType2[EaseType2["CircIn"] = 19] = "CircIn";
      EaseType2[EaseType2["CircOut"] = 20] = "CircOut";
      EaseType2[EaseType2["CircInOut"] = 21] = "CircInOut";
      EaseType2[EaseType2["ElasticIn"] = 22] = "ElasticIn";
      EaseType2[EaseType2["ElasticOut"] = 23] = "ElasticOut";
      EaseType2[EaseType2["ElasticInOut"] = 24] = "ElasticInOut";
      EaseType2[EaseType2["BackIn"] = 25] = "BackIn";
      EaseType2[EaseType2["BackOut"] = 26] = "BackOut";
      EaseType2[EaseType2["BackInOut"] = 27] = "BackInOut";
      EaseType2[EaseType2["BounceIn"] = 28] = "BounceIn";
      EaseType2[EaseType2["BounceOut"] = 29] = "BounceOut";
      EaseType2[EaseType2["BounceInOut"] = 30] = "BounceInOut";
      EaseType2[EaseType2["Custom"] = 31] = "Custom";
    })(EaseType || (EaseType = {}));
    GearBase = class _GearBase {
      dispose() {
        if (this._tweenConfig && this._tweenConfig._tweener) {
          this._tweenConfig._tweener.kill();
          this._tweenConfig._tweener = null;
        }
      }
      get controller() {
        return this._controller;
      }
      set controller(val) {
        if (val != this._controller) {
          this._controller = val;
          if (this._controller)
            this.init();
        }
      }
      get tweenConfig() {
        if (!this._tweenConfig)
          this._tweenConfig = new GearTweenConfig();
        return this._tweenConfig;
      }
      get allowTween() {
        return this._tweenConfig && this._tweenConfig.tween && constructingDepth.n == 0 && !_GearBase.disableAllTweenEffect;
      }
      setup(buffer) {
        this._controller = this._owner.parent.getControllerAt(buffer.readShort());
        this.init();
        var i;
        var page;
        var cnt = buffer.readShort();
        if ("pages" in this) {
          this.pages = buffer.readSArray(cnt);
        } else {
          for (i = 0; i < cnt; i++) {
            page = buffer.readS();
            if (page == null)
              continue;
            this.addStatus(page, buffer);
          }
          if (buffer.readBool())
            this.addStatus(null, buffer);
        }
        if (buffer.readBool()) {
          this._tweenConfig = new GearTweenConfig();
          this._tweenConfig.easeType = buffer.readByte();
          this._tweenConfig.duration = buffer.readFloat();
          this._tweenConfig.delay = buffer.readFloat();
        }
        if (buffer.version >= 2) {
          if ("positionsInPercent" in this) {
            if (buffer.readBool()) {
              this.positionsInPercent = true;
              for (i = 0; i < cnt; i++) {
                page = buffer.readS();
                if (page == null)
                  continue;
                this.addExtStatus(page, buffer);
              }
              if (buffer.readBool())
                this.addExtStatus(null, buffer);
            }
          } else if ("condition" in this)
            this.condition = buffer.readByte();
        }
      }
      updateFromRelations(dx, dy) {
      }
      addStatus(pageId, buffer) {
      }
      init() {
      }
      apply() {
      }
      updateState() {
      }
    };
    GearTweenConfig = class {
      constructor() {
        this.tween = true;
        this.easeType = EaseType.QuadOut;
        this.duration = 0.3;
        this.delay = 0;
      }
    };
    GearAnimation = class extends GearBase {
      init() {
        this._default = {
          playing: this._owner.getProp(ObjectPropID.Playing),
          frame: this._owner.getProp(ObjectPropID.Frame)
        };
        this._storage = {};
      }
      addStatus(pageId, buffer) {
        var gv;
        if (!pageId)
          gv = this._default;
        else {
          gv = {};
          this._storage[pageId] = gv;
        }
        gv.playing = buffer.readBool();
        gv.frame = buffer.readInt();
      }
      apply() {
        this._owner._gearLocked = true;
        var gv = this._storage[this._controller.selectedPageId] || this._default;
        this._owner.setProp(ObjectPropID.Playing, gv.playing);
        this._owner.setProp(ObjectPropID.Frame, gv.frame);
        this._owner._gearLocked = false;
      }
      updateState() {
        var gv = this._storage[this._controller.selectedPageId];
        if (!gv) {
          gv = {};
          this._storage[this._controller.selectedPageId] = gv;
        }
        gv.playing = this._owner.getProp(ObjectPropID.Playing);
        gv.frame = this._owner.getProp(ObjectPropID.Frame);
      }
    };
    GearColor = class extends GearBase {
      init() {
        this._default = {
          color: this._owner.getProp(ObjectPropID.Color),
          strokeColor: this._owner.getProp(ObjectPropID.OutlineColor)
        };
        this._storage = {};
      }
      addStatus(pageId, buffer) {
        var gv;
        if (!pageId)
          gv = this._default;
        else {
          gv = {};
          this._storage[pageId] = gv;
        }
        gv.color = buffer.readColor();
        gv.strokeColor = buffer.readColor();
      }
      apply() {
        this._owner._gearLocked = true;
        var gv = this._storage[this._controller.selectedPageId] || this._default;
        this._owner.setProp(ObjectPropID.Color, gv.color);
        this._owner.setProp(ObjectPropID.OutlineColor, gv.strokeColor);
        this._owner._gearLocked = false;
      }
      updateState() {
        var gv = this._storage[this._controller.selectedPageId];
        if (!gv) {
          gv = {};
          this._storage[this._controller.selectedPageId] = gv;
        }
        gv.color = this._owner.getProp(ObjectPropID.Color);
        gv.strokeColor = this._owner.getProp(ObjectPropID.OutlineColor);
      }
    };
    GearDisplay = class extends GearBase {
      constructor() {
        super(...arguments);
        this.pages = null;
        this._visible = 0;
        this._displayLockToken = 1;
      }
      init() {
        this.pages = null;
      }
      addLock() {
        this._visible++;
        return this._displayLockToken;
      }
      releaseLock(token) {
        if (token == this._displayLockToken)
          this._visible--;
      }
      get connected() {
        return this._controller == null || this._visible > 0;
      }
      apply() {
        this._displayLockToken++;
        if (this._displayLockToken <= 0)
          this._displayLockToken = 1;
        if (this.pages == null || this.pages.length == 0 || this.pages.indexOf(this._controller.selectedPageId) != -1)
          this._visible = 1;
        else
          this._visible = 0;
      }
    };
    GearDisplay2 = class extends GearBase {
      constructor() {
        super(...arguments);
        this.pages = null;
        this.condition = 0;
        this._visible = 0;
      }
      init() {
        this.pages = null;
      }
      apply() {
        if (this.pages == null || this.pages.length == 0 || this.pages.indexOf(this._controller.selectedPageId) != -1)
          this._visible = 1;
        else
          this._visible = 0;
      }
      evaluate(connected) {
        var v = this._controller == null || this._visible > 0;
        if (this.condition == 0)
          v = v && connected;
        else
          v = v || connected;
        return v;
      }
    };
    GearFontSize = class extends GearBase {
      constructor() {
        super(...arguments);
        this._default = 0;
      }
      init() {
        this._default = this._owner.getProp(ObjectPropID.FontSize);
        this._storage = {};
      }
      addStatus(pageId, buffer) {
        if (!pageId)
          this._default = buffer.readInt();
        else
          this._storage[pageId] = buffer.readInt();
      }
      apply() {
        this._owner._gearLocked = true;
        var data = this._storage[this._controller.selectedPageId];
        if (data !== void 0)
          this._owner.setProp(ObjectPropID.FontSize, data);
        else
          this._owner.setProp(ObjectPropID.FontSize, this._default);
        this._owner._gearLocked = false;
      }
      updateState() {
        this._storage[this._controller.selectedPageId] = this._owner.getProp(ObjectPropID.FontSize);
      }
    };
    GearIcon = class extends GearBase {
      init() {
        this._default = this._owner.icon;
        this._storage = {};
      }
      addStatus(pageId, buffer) {
        if (!pageId)
          this._default = buffer.readS();
        else
          this._storage[pageId] = buffer.readS();
      }
      apply() {
        this._owner._gearLocked = true;
        var data = this._storage[this._controller.selectedPageId];
        if (data !== void 0)
          this._owner.icon = data;
        else
          this._owner.icon = this._default;
        this._owner._gearLocked = false;
      }
      updateState() {
        this._storage[this._controller.selectedPageId] = this._owner.icon;
      }
    };
    Pool = class {
      constructor(type, init, reset) {
        this.pool = [];
        this._init = init;
        this._reset = reset;
        this._ct = type;
      }
      borrow(...argArray) {
        let ret;
        if (this.pool.length > 0)
          ret = this.pool.pop();
        else
          ret = new this._ct();
        if (this._init)
          this._init(ret, ...argArray);
        return ret;
      }
      returns(element) {
        if (Array.isArray(element)) {
          let count = element.length;
          for (let i = 0; i < count; i++) {
            let element2 = element[i];
            if (this._reset)
              this._reset(element2);
            this.pool.push(element2);
          }
          element.length = 0;
        } else {
          if (this._reset)
            this._reset(element);
          this.pool.push(element);
        }
      }
    };
    _PiOver2 = Math.PI * 0.5;
    _TwoPi = Math.PI * 2;
    TweenValue = class {
      constructor() {
        this.x = this.y = this.z = this.w = 0;
      }
      get color() {
        return (this.w << 24) + (this.x << 16) + (this.y << 8) + this.z;
      }
      set color(value) {
        this.x = (value & 16711680) >> 16;
        this.y = (value & 65280) >> 8;
        this.z = value & 255;
        this.w = (value & 4278190080) >> 24;
      }
      getField(index) {
        switch (index) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          case 3:
            return this.w;
          default:
            throw new Error("Index out of bounds: " + index);
        }
      }
      setField(index, value) {
        switch (index) {
          case 0:
            this.x = value;
            break;
          case 1:
            this.y = value;
            break;
          case 2:
            this.z = value;
            break;
          case 3:
            this.w = value;
            break;
          default:
            throw new Error("Index out of bounds: " + index);
        }
      }
      setZero() {
        this.x = this.y = this.z = this.w = 0;
      }
    };
    s_vec2$5 = new import_cc5.Vec2();
    GTweener = class {
      constructor() {
        this._delay = 0;
        this._duration = 0;
        this._breakpoint = 0;
        this._easeType = 0;
        this._easeOvershootOrAmplitude = 0;
        this._easePeriod = 0;
        this._repeat = 0;
        this._yoyo = false;
        this._timeScale = 1;
        this._snapping = false;
        this._startValue = new TweenValue();
        this._endValue = new TweenValue();
        this._value = new TweenValue();
        this._deltaValue = new TweenValue();
        this._reset();
      }
      get elapsedTime() {
        return this._elapsedTime;
      }
      setDelay(value) {
        this._delay = value;
        return this;
      }
      get delay() {
        return this._delay;
      }
      setDuration(value) {
        this._duration = value;
        return this;
      }
      get duration() {
        return this._duration;
      }
      setBreakpoint(value) {
        this._breakpoint = value;
        return this;
      }
      setEase(value) {
        this._easeType = value;
        return this;
      }
      setEasePeriod(value) {
        this._easePeriod = value;
        return this;
      }
      setEaseOvershootOrAmplitude(value) {
        this._easeOvershootOrAmplitude = value;
        return this;
      }
      setRepeat(repeat, yoyo) {
        this._repeat = repeat;
        this._yoyo = yoyo;
        return this;
      }
      get repeat() {
        return this._repeat;
      }
      setTimeScale(value) {
        this._timeScale = value;
        return this;
      }
      setSnapping(value) {
        this._snapping = value;
        return this;
      }
      setTarget(value, propType) {
        this._target = value;
        this._propType = propType;
        return this;
      }
      get target() {
        return this._target;
      }
      setPath(value) {
        this._path = value;
        return this;
      }
      setUserData(value) {
        this._userData = value;
        return this;
      }
      get userData() {
        return this._userData;
      }
      onUpdate(callback, target) {
        this._onUpdate = callback;
        this._onUpdateCaller = target;
        return this;
      }
      onStart(callback, target) {
        this._onStart = callback;
        this._onStartCaller = target;
        return this;
      }
      onComplete(callback, target) {
        this._onComplete = callback;
        this._onCompleteCaller = target;
        return this;
      }
      get startValue() {
        return this._startValue;
      }
      get endValue() {
        return this._endValue;
      }
      get value() {
        return this._value;
      }
      get deltaValue() {
        return this._deltaValue;
      }
      get normalizedTime() {
        return this._normalizedTime;
      }
      get completed() {
        return this._ended != 0;
      }
      get allCompleted() {
        return this._ended == 1;
      }
      setPaused(paused) {
        this._paused = paused;
        return this;
      }
      /**
       * seek position of the tween, in seconds.
       */
      seek(time) {
        if (this._killed)
          return;
        this._elapsedTime = time;
        if (this._elapsedTime < this._delay) {
          if (this._started)
            this._elapsedTime = this._delay;
          else
            return;
        }
        this.update();
      }
      kill(complete) {
        if (this._killed)
          return;
        if (complete) {
          if (this._ended == 0) {
            if (this._breakpoint >= 0)
              this._elapsedTime = this._delay + this._breakpoint;
            else if (this._repeat >= 0)
              this._elapsedTime = this._delay + this._duration * (this._repeat + 1);
            else
              this._elapsedTime = this._delay + this._duration * 2;
            this.update();
          }
          this.callCompleteCallback();
        }
        this._killed = true;
      }
      _to(start, end, duration) {
        this._valueSize = 1;
        this._startValue.x = start;
        this._endValue.x = end;
        this._value.x = start;
        this._duration = duration;
        return this;
      }
      _to2(start, start2, end, end2, duration) {
        this._valueSize = 2;
        this._startValue.x = start;
        this._endValue.x = end;
        this._startValue.y = start2;
        this._endValue.y = end2;
        this._value.x = start;
        this._value.y = start2;
        this._duration = duration;
        return this;
      }
      _to3(start, start2, start3, end, end2, end3, duration) {
        this._valueSize = 3;
        this._startValue.x = start;
        this._endValue.x = end;
        this._startValue.y = start2;
        this._endValue.y = end2;
        this._startValue.z = start3;
        this._endValue.z = end3;
        this._value.x = start;
        this._value.y = start2;
        this._value.z = start3;
        this._duration = duration;
        return this;
      }
      _to4(start, start2, start3, start4, end, end2, end3, end4, duration) {
        this._valueSize = 4;
        this._startValue.x = start;
        this._endValue.x = end;
        this._startValue.y = start2;
        this._endValue.y = end2;
        this._startValue.z = start3;
        this._endValue.z = end3;
        this._startValue.w = start4;
        this._endValue.w = end4;
        this._value.x = start;
        this._value.y = start2;
        this._value.z = start3;
        this._value.w = start4;
        this._duration = duration;
        return this;
      }
      _toColor(start, end, duration) {
        this._valueSize = 5;
        this._startValue.color = start;
        this._endValue.color = end;
        this._value.color = start;
        this._duration = duration;
        return this;
      }
      _shake(startX, startY, amplitude, duration) {
        this._valueSize = 6;
        this._startValue.x = startX;
        this._startValue.y = startY;
        this._startValue.w = amplitude;
        this._duration = duration;
        return this;
      }
      _init() {
        this._delay = 0;
        this._duration = 0;
        this._breakpoint = -1;
        this._easeType = EaseType.QuadOut;
        this._timeScale = 1;
        this._easePeriod = 0;
        this._easeOvershootOrAmplitude = 1.70158;
        this._snapping = false;
        this._repeat = 0;
        this._yoyo = false;
        this._valueSize = 0;
        this._started = false;
        this._paused = false;
        this._killed = false;
        this._elapsedTime = 0;
        this._normalizedTime = 0;
        this._ended = 0;
      }
      _reset() {
        this._target = null;
        this._propType = null;
        this._userData = null;
        this._path = null;
        this._onStart = this._onUpdate = this._onComplete = null;
        this._onStartCaller = this._onUpdateCaller = this._onCompleteCaller = null;
      }
      _update(dt) {
        if (this._timeScale != 1)
          dt *= this._timeScale;
        if (dt == 0)
          return;
        if (this._ended != 0) {
          this.callCompleteCallback();
          this._killed = true;
          return;
        }
        this._elapsedTime += dt;
        this.update();
        if (this._ended != 0) {
          if (!this._killed) {
            this.callCompleteCallback();
            this._killed = true;
          }
        }
      }
      update() {
        this._ended = 0;
        if (this._valueSize == 0) {
          if (this._elapsedTime >= this._delay + this._duration)
            this._ended = 1;
          return;
        }
        if (!this._started) {
          if (this._elapsedTime < this._delay)
            return;
          this._started = true;
          this.callStartCallback();
          if (this._killed)
            return;
        }
        var reversed = false;
        var tt = this._elapsedTime - this._delay;
        if (this._breakpoint >= 0 && tt >= this._breakpoint) {
          tt = this._breakpoint;
          this._ended = 2;
        }
        if (this._repeat != 0) {
          var round = Math.floor(tt / this._duration);
          tt -= this._duration * round;
          if (this._yoyo)
            reversed = round % 2 == 1;
          if (this._repeat > 0 && this._repeat - round < 0) {
            if (this._yoyo)
              reversed = this._repeat % 2 == 1;
            tt = this._duration;
            this._ended = 1;
          }
        } else if (tt >= this._duration) {
          tt = this._duration;
          this._ended = 1;
        }
        this._normalizedTime = evaluateEase(this._easeType, reversed ? this._duration - tt : tt, this._duration, this._easeOvershootOrAmplitude, this._easePeriod);
        this._value.setZero();
        this._deltaValue.setZero();
        if (this._valueSize == 6) {
          if (this._ended == 0) {
            var r = this._startValue.w * (1 - this._normalizedTime);
            var rx = r * (Math.random() > 0.5 ? 1 : -1);
            var ry = r * (Math.random() > 0.5 ? 1 : -1);
            this._deltaValue.x = rx;
            this._deltaValue.y = ry;
            this._value.x = this._startValue.x + rx;
            this._value.y = this._startValue.y + ry;
          } else {
            this._value.x = this._startValue.x;
            this._value.y = this._startValue.y;
          }
        } else if (this._path) {
          let pt = this._path.getPointAt(this._normalizedTime, s_vec2$5);
          if (this._snapping) {
            pt.x = Math.round(pt.x);
            pt.y = Math.round(pt.y);
          }
          this._deltaValue.x = pt.x - this._value.x;
          this._deltaValue.y = pt.y - this._value.y;
          this._value.x = pt.x;
          this._value.y = pt.y;
        } else {
          let cnt = Math.min(this._valueSize, 4);
          for (var i = 0; i < cnt; i++) {
            var n1 = this._startValue.getField(i);
            var n2 = this._endValue.getField(i);
            var f = n1 + (n2 - n1) * this._normalizedTime;
            if (this._snapping)
              f = Math.round(f);
            this._deltaValue.setField(i, f - this._value.getField(i));
            this._value.setField(i, f);
          }
        }
        if (this._target && this._propType) {
          if (this._propType instanceof Function) {
            switch (this._valueSize) {
              case 1:
                this._propType.call(this._target, this._value.x);
                break;
              case 2:
                this._propType.call(this._target, this._value.x, this._value.y);
                break;
              case 3:
                this._propType.call(this._target, this._value.x, this._value.y, this._value.z);
                break;
              case 4:
                this._propType.call(this._target, this._value.x, this._value.y, this._value.z, this._value.w);
                break;
              case 5:
                this._propType.call(this._target, this._value.color);
                break;
              case 6:
                this._propType.call(this._target, this._value.x, this._value.y);
                break;
            }
          } else {
            if (this._valueSize == 5)
              this._target[this._propType] = this._value.color;
            else
              this._target[this._propType] = this._value.x;
          }
        }
        this.callUpdateCallback();
      }
      callStartCallback() {
        if (this._onStart) {
          try {
            this._onStart.call(this._onStartCaller, this);
          } catch (err) {
            console.log("error in start callback > " + err);
          }
        }
      }
      callUpdateCallback() {
        if (this._onUpdate) {
          try {
            this._onUpdate.call(this._onUpdateCaller, this);
          } catch (err) {
            console.log("error in update callback > " + err);
          }
        }
      }
      callCompleteCallback() {
        if (this._onComplete) {
          try {
            this._onComplete.call(this._onCompleteCaller, this);
          } catch (err) {
            console.log("error in complete callback > " + err);
          }
        }
      }
    };
    TweenManager = class _TweenManager {
      static createTween() {
        if (!_root) {
          _root = new import_cc5.Node("[TweenManager]");
          import_cc5.game.addPersistRootNode(_root);
          import_cc5.director.getScheduler().schedule(_TweenManager.update, _root, 0, import_cc5.macro.REPEAT_FOREVER, 0, false);
        }
        var tweener = _tweenerPool.borrow();
        _activeTweens[_totalActiveTweens++] = tweener;
        return tweener;
      }
      static isTweening(target, propType) {
        if (target == null)
          return false;
        var anyType = !propType;
        for (var i = 0; i < _totalActiveTweens; i++) {
          var tweener = _activeTweens[i];
          if (tweener && tweener.target == target && !tweener._killed && (anyType || tweener._propType == propType))
            return true;
        }
        return false;
      }
      static killTweens(target, completed, propType) {
        if (target == null)
          return false;
        var flag = false;
        var cnt = _totalActiveTweens;
        var anyType = !propType;
        for (var i = 0; i < cnt; i++) {
          var tweener = _activeTweens[i];
          if (tweener && tweener.target == target && !tweener._killed && (anyType || tweener._propType == propType)) {
            tweener.kill(completed);
            flag = true;
          }
        }
        return flag;
      }
      static getTween(target, propType) {
        if (target == null)
          return null;
        var cnt = _totalActiveTweens;
        var anyType = !propType;
        for (var i = 0; i < cnt; i++) {
          var tweener = _activeTweens[i];
          if (tweener && tweener.target == target && !tweener._killed && (anyType || tweener._propType == propType)) {
            return tweener;
          }
        }
        return null;
      }
      static update(dt) {
        let tweens = _activeTweens;
        var cnt = _totalActiveTweens;
        var freePosStart = -1;
        for (var i = 0; i < cnt; i++) {
          var tweener = tweens[i];
          if (tweener == null) {
            if (freePosStart == -1)
              freePosStart = i;
          } else if (tweener._killed) {
            tweener._reset();
            _tweenerPool.returns(tweener);
            tweens[i] = null;
            if (freePosStart == -1)
              freePosStart = i;
          } else {
            if (tweener._target && "isDisposed" in tweener._target && tweener._target.isDisposed)
              tweener._killed = true;
            else if (!tweener._paused)
              tweener._update(dt);
            if (freePosStart != -1) {
              tweens[freePosStart] = tweener;
              tweens[i] = null;
              freePosStart++;
            }
          }
        }
        if (freePosStart >= 0) {
          if (_totalActiveTweens != cnt) {
            var j = cnt;
            cnt = _totalActiveTweens - cnt;
            for (i = 0; i < cnt; i++)
              tweens[freePosStart++] = tweens[j++];
          }
          _totalActiveTweens = freePosStart;
        }
        return false;
      }
    };
    _activeTweens = new Array();
    _tweenerPool = new Pool(GTweener, (e) => e._init(), (e) => e._reset());
    _totalActiveTweens = 0;
    GTween = class {
      static to(start, end, duration) {
        return TweenManager.createTween()._to(start, end, duration);
      }
      static to2(start, start2, end, end2, duration) {
        return TweenManager.createTween()._to2(start, start2, end, end2, duration);
      }
      static to3(start, start2, start3, end, end2, end3, duration) {
        return TweenManager.createTween()._to3(start, start2, start3, end, end2, end3, duration);
      }
      static to4(start, start2, start3, start4, end, end2, end3, end4, duration) {
        return TweenManager.createTween()._to4(start, start2, start3, start4, end, end2, end3, end4, duration);
      }
      static toColor(start, end, duration) {
        return TweenManager.createTween()._toColor(start, end, duration);
      }
      static delayedCall(delay) {
        return TweenManager.createTween().setDelay(delay);
      }
      static shake(startX, startY, amplitude, duration) {
        return TweenManager.createTween()._shake(startX, startY, amplitude, duration);
      }
      static isTweening(target, propType) {
        return TweenManager.isTweening(target, propType);
      }
      static kill(target, complete, propType) {
        TweenManager.killTweens(target, complete, propType);
      }
      static getTween(target, propType) {
        return TweenManager.getTween(target, propType);
      }
    };
    GTween.catchCallbackExceptions = true;
    GearLook = class extends GearBase {
      init() {
        this._default = {
          alpha: this._owner.alpha,
          rotation: this._owner.rotation,
          grayed: this._owner.grayed,
          touchable: this._owner.touchable
        };
        this._storage = {};
      }
      addStatus(pageId, buffer) {
        var gv;
        if (!pageId)
          gv = this._default;
        else {
          gv = {};
          this._storage[pageId] = gv;
        }
        gv.alpha = buffer.readFloat();
        gv.rotation = buffer.readFloat();
        gv.grayed = buffer.readBool();
        gv.touchable = buffer.readBool();
      }
      apply() {
        var gv = this._storage[this._controller.selectedPageId] || this._default;
        if (this.allowTween) {
          this._owner._gearLocked = true;
          this._owner.grayed = gv.grayed;
          this._owner.touchable = gv.touchable;
          this._owner._gearLocked = false;
          if (this._tweenConfig._tweener) {
            if (this._tweenConfig._tweener.endValue.x != gv.alpha || this._tweenConfig._tweener.endValue.y != gv.rotation) {
              this._tweenConfig._tweener.kill(true);
              this._tweenConfig._tweener = null;
            } else
              return;
          }
          var a = gv.alpha != this._owner.alpha;
          var b = gv.rotation != this._owner.rotation;
          if (a || b) {
            if (this._owner.checkGearController(0, this._controller))
              this._tweenConfig._displayLockToken = this._owner.addDisplayLock();
            this._tweenConfig._tweener = GTween.to2(this._owner.alpha, this._owner.rotation, gv.alpha, gv.rotation, this._tweenConfig.duration).setDelay(this._tweenConfig.delay).setEase(this._tweenConfig.easeType).setUserData((a ? 1 : 0) + (b ? 2 : 0)).setTarget(this).onUpdate(this.__tweenUpdate, this).onComplete(this.__tweenComplete, this);
          }
        } else {
          this._owner._gearLocked = true;
          this._owner.grayed = gv.grayed;
          this._owner.alpha = gv.alpha;
          this._owner.rotation = gv.rotation;
          this._owner.touchable = gv.touchable;
          this._owner._gearLocked = false;
        }
      }
      __tweenUpdate(tweener) {
        var flag = tweener.userData;
        this._owner._gearLocked = true;
        if ((flag & 1) != 0)
          this._owner.alpha = tweener.value.x;
        if ((flag & 2) != 0)
          this._owner.rotation = tweener.value.y;
        this._owner._gearLocked = false;
      }
      __tweenComplete() {
        if (this._tweenConfig._displayLockToken != 0) {
          this._owner.releaseDisplayLock(this._tweenConfig._displayLockToken);
          this._tweenConfig._displayLockToken = 0;
        }
        this._tweenConfig._tweener = null;
      }
      updateState() {
        var gv = this._storage[this._controller.selectedPageId];
        if (!gv) {
          gv = {};
          this._storage[this._controller.selectedPageId] = gv;
        }
        gv.alpha = this._owner.alpha;
        gv.rotation = this._owner.rotation;
        gv.grayed = this._owner.grayed;
        gv.touchable = this._owner.touchable;
      }
    };
    GearSize = class extends GearBase {
      init() {
        this._default = {
          width: this._owner.width,
          height: this._owner.height,
          scaleX: this._owner.scaleX,
          scaleY: this._owner.scaleY
        };
        this._storage = {};
      }
      addStatus(pageId, buffer) {
        var gv;
        if (!pageId)
          gv = this._default;
        else {
          gv = {};
          this._storage[pageId] = gv;
        }
        gv.width = buffer.readInt();
        gv.height = buffer.readInt();
        gv.scaleX = buffer.readFloat();
        gv.scaleY = buffer.readFloat();
      }
      apply() {
        var gv = this._storage[this._controller.selectedPageId] || this._default;
        if (this.allowTween) {
          if (this._tweenConfig._tweener) {
            if (this._tweenConfig._tweener.endValue.x != gv.width || this._tweenConfig._tweener.endValue.y != gv.height || this._tweenConfig._tweener.endValue.z != gv.scaleX || this._tweenConfig._tweener.endValue.w != gv.scaleY) {
              this._tweenConfig._tweener.kill(true);
              this._tweenConfig._tweener = null;
            } else
              return;
          }
          var a = gv.width != this._owner.width || gv.height != this._owner.height;
          var b = gv.scaleX != this._owner.scaleX || gv.scaleY != this._owner.scaleY;
          if (a || b) {
            if (this._owner.checkGearController(0, this._controller))
              this._tweenConfig._displayLockToken = this._owner.addDisplayLock();
            this._tweenConfig._tweener = GTween.to4(this._owner.width, this._owner.height, this._owner.scaleX, this._owner.scaleY, gv.width, gv.height, gv.scaleX, gv.scaleY, this._tweenConfig.duration).setDelay(this._tweenConfig.delay).setEase(this._tweenConfig.easeType).setUserData((a ? 1 : 0) + (b ? 2 : 0)).setTarget(this).onUpdate(this.__tweenUpdate, this).onComplete(this.__tweenComplete, this);
          }
        } else {
          this._owner._gearLocked = true;
          this._owner.setSize(gv.width, gv.height, this._owner.checkGearController(1, this._controller));
          this._owner.setScale(gv.scaleX, gv.scaleY);
          this._owner._gearLocked = false;
        }
      }
      __tweenUpdate(tweener) {
        var flag = tweener.userData;
        this._owner._gearLocked = true;
        if ((flag & 1) != 0)
          this._owner.setSize(tweener.value.x, tweener.value.y, this._owner.checkGearController(1, this._controller));
        if ((flag & 2) != 0)
          this._owner.setScale(tweener.value.z, tweener.value.w);
        this._owner._gearLocked = false;
      }
      __tweenComplete() {
        if (this._tweenConfig._displayLockToken != 0) {
          this._owner.releaseDisplayLock(this._tweenConfig._displayLockToken);
          this._tweenConfig._displayLockToken = 0;
        }
        this._tweenConfig._tweener = null;
      }
      updateState() {
        var gv = this._storage[this._controller.selectedPageId];
        if (!gv) {
          gv = {};
          this._storage[this._controller.selectedPageId] = gv;
        }
        gv.width = this._owner.width;
        gv.height = this._owner.height;
        gv.scaleX = this._owner.scaleX;
        gv.scaleY = this._owner.scaleY;
      }
      updateFromRelations(dx, dy) {
        if (this._controller == null || this._storage == null)
          return;
        for (var key in this._storage) {
          var gv = this._storage[key];
          gv.width += dx;
          gv.height += dy;
        }
        this._default.width += dx;
        this._default.height += dy;
        this.updateState();
      }
    };
    GearText = class extends GearBase {
      init() {
        this._default = this._owner.text;
        this._storage = {};
      }
      addStatus(pageId, buffer) {
        if (pageId == null)
          this._default = buffer.readS();
        else
          this._storage[pageId] = buffer.readS();
      }
      apply() {
        this._owner._gearLocked = true;
        var data = this._storage[this._controller.selectedPageId];
        if (data !== void 0)
          this._owner.text = data;
        else
          this._owner.text = this._default;
        this._owner._gearLocked = false;
      }
      updateState() {
        this._storage[this._controller.selectedPageId] = this._owner.text;
      }
    };
    GearXY = class extends GearBase {
      init() {
        this._default = {
          x: this._owner.x,
          y: this._owner.y,
          px: this._owner.x / this._owner.parent.width,
          py: this._owner.y / this._owner.parent.height
        };
        this._storage = {};
      }
      addStatus(pageId, buffer) {
        var gv;
        if (!pageId)
          gv = this._default;
        else {
          gv = {};
          this._storage[pageId] = gv;
        }
        gv.x = buffer.readInt();
        gv.y = buffer.readInt();
      }
      addExtStatus(pageId, buffer) {
        var gv;
        if (!pageId)
          gv = this._default;
        else
          gv = this._storage[pageId];
        gv.px = buffer.readFloat();
        gv.py = buffer.readFloat();
      }
      apply() {
        var pt = this._storage[this._controller.selectedPageId] || this._default;
        var ex;
        var ey;
        if (this.positionsInPercent && this._owner.parent) {
          ex = pt.px * this._owner.parent.width;
          ey = pt.py * this._owner.parent.height;
        } else {
          ex = pt.x;
          ey = pt.y;
        }
        if (this.allowTween) {
          if (this._tweenConfig._tweener) {
            if (this._tweenConfig._tweener.endValue.x != ex || this._tweenConfig._tweener.endValue.y != ey) {
              this._tweenConfig._tweener.kill(true);
              this._tweenConfig._tweener = null;
            } else
              return;
          }
          var ox = this._owner.x;
          var oy = this._owner.y;
          if (ox != ex || oy != ey) {
            if (this._owner.checkGearController(0, this._controller))
              this._tweenConfig._displayLockToken = this._owner.addDisplayLock();
            this._tweenConfig._tweener = GTween.to2(ox, oy, ex, ey, this._tweenConfig.duration).setDelay(this._tweenConfig.delay).setEase(this._tweenConfig.easeType).setTarget(this).onUpdate(this.__tweenUpdate, this).onComplete(this.__tweenComplete, this);
          }
        } else {
          this._owner._gearLocked = true;
          this._owner.setPosition(ex, ey);
          this._owner._gearLocked = false;
        }
      }
      __tweenUpdate(tweener) {
        this._owner._gearLocked = true;
        this._owner.setPosition(tweener.value.x, tweener.value.y);
        this._owner._gearLocked = false;
      }
      __tweenComplete() {
        if (this._tweenConfig._displayLockToken != 0) {
          this._owner.releaseDisplayLock(this._tweenConfig._displayLockToken);
          this._tweenConfig._displayLockToken = 0;
        }
        this._tweenConfig._tweener = null;
      }
      updateState() {
        var pt = this._storage[this._controller.selectedPageId];
        if (!pt) {
          pt = {};
          this._storage[this._controller.selectedPageId] = pt;
        }
        pt.x = this._owner.x;
        pt.y = this._owner.y;
        pt.px = this._owner.x / this._owner.parent.width;
        pt.py = this._owner.y / this._owner.parent.height;
      }
      updateFromRelations(dx, dy) {
        if (this._controller == null || this._storage == null || this.positionsInPercent)
          return;
        for (var key in this._storage) {
          var pt = this._storage[key];
          pt.x += dx;
          pt.y += dy;
        }
        this._default.x += dx;
        this._default.y += dy;
        this.updateState();
      }
    };
    RelationItem = class {
      constructor(owner) {
        this._owner = owner;
        this._defs = new Array();
      }
      get owner() {
        return this._owner;
      }
      set target(value) {
        if (this._target != value) {
          if (this._target)
            this.releaseRefTarget(this._target);
          this._target = value;
          if (this._target)
            this.addRefTarget(this._target);
        }
      }
      get target() {
        return this._target;
      }
      add(relationType, usePercent) {
        if (relationType == RelationType.Size) {
          this.add(RelationType.Width, usePercent);
          this.add(RelationType.Height, usePercent);
          return;
        }
        var length = this._defs.length;
        for (var i = 0; i < length; i++) {
          var def = this._defs[i];
          if (def.type == relationType)
            return;
        }
        this.internalAdd(relationType, usePercent);
      }
      internalAdd(relationType, usePercent) {
        if (relationType == RelationType.Size) {
          this.internalAdd(RelationType.Width, usePercent);
          this.internalAdd(RelationType.Height, usePercent);
          return;
        }
        var info = new RelationDef();
        info.percent = usePercent;
        info.type = relationType;
        info.axis = relationType <= RelationType.Right_Right || relationType == RelationType.Width || relationType >= RelationType.LeftExt_Left && relationType <= RelationType.RightExt_Right ? 0 : 1;
        this._defs.push(info);
      }
      remove(relationType) {
        if (relationType == RelationType.Size) {
          this.remove(RelationType.Width);
          this.remove(RelationType.Height);
          return;
        }
        var dc = this._defs.length;
        for (var k = 0; k < dc; k++) {
          if (this._defs[k].type == relationType) {
            this._defs.splice(k, 1);
            break;
          }
        }
      }
      copyFrom(source) {
        this.target = source.target;
        this._defs.length = 0;
        var length = source._defs.length;
        for (var i = 0; i < length; i++) {
          var info = source._defs[i];
          var info2 = new RelationDef();
          info2.copyFrom(info);
          this._defs.push(info2);
        }
      }
      dispose() {
        if (this._target) {
          this.releaseRefTarget(this._target);
          this._target = null;
        }
      }
      get isEmpty() {
        return this._defs.length == 0;
      }
      applyOnSelfResized(dWidth, dHeight, applyPivot) {
        var ox = this._owner.x;
        var oy = this._owner.y;
        var length = this._defs.length;
        for (var i = 0; i < length; i++) {
          var info = this._defs[i];
          switch (info.type) {
            case RelationType.Center_Center:
              this._owner.x -= (0.5 - (applyPivot ? this._owner.pivotX : 0)) * dWidth;
              break;
            case RelationType.Right_Center:
            case RelationType.Right_Left:
            case RelationType.Right_Right:
              this._owner.x -= (1 - (applyPivot ? this._owner.pivotX : 0)) * dWidth;
              break;
            case RelationType.Middle_Middle:
              this._owner.y -= (0.5 - (applyPivot ? this._owner.pivotY : 0)) * dHeight;
              break;
            case RelationType.Bottom_Middle:
            case RelationType.Bottom_Top:
            case RelationType.Bottom_Bottom:
              this._owner.y -= (1 - (applyPivot ? this._owner.pivotY : 0)) * dHeight;
              break;
          }
        }
        if (ox != this._owner.x || oy != this._owner.y) {
          ox = this._owner.x - ox;
          oy = this._owner.y - oy;
          this._owner.updateGearFromRelations(1, ox, oy);
          if (this._owner.parent) {
            var len = this._owner.parent._transitions.length;
            if (len > 0) {
              for (var i = 0; i < len; ++i) {
                this._owner.parent._transitions[i].updateFromRelations(this._owner.id, ox, oy);
              }
            }
          }
        }
      }
      applyOnXYChanged(info, dx, dy) {
        var tmp;
        switch (info.type) {
          case RelationType.Left_Left:
          case RelationType.Left_Center:
          case RelationType.Left_Right:
          case RelationType.Center_Center:
          case RelationType.Right_Left:
          case RelationType.Right_Center:
          case RelationType.Right_Right:
            this._owner.x += dx;
            break;
          case RelationType.Top_Top:
          case RelationType.Top_Middle:
          case RelationType.Top_Bottom:
          case RelationType.Middle_Middle:
          case RelationType.Bottom_Top:
          case RelationType.Bottom_Middle:
          case RelationType.Bottom_Bottom:
            this._owner.y += dy;
            break;
          case RelationType.Width:
          case RelationType.Height:
            break;
          case RelationType.LeftExt_Left:
          case RelationType.LeftExt_Right:
            if (this._owner != this._target.parent) {
              tmp = this._owner.xMin;
              this._owner.width = this._owner._rawWidth - dx;
              this._owner.xMin = tmp + dx;
            } else
              this._owner.width = this._owner._rawWidth - dx;
            break;
          case RelationType.RightExt_Left:
          case RelationType.RightExt_Right:
            if (this._owner != this._target.parent) {
              tmp = this._owner.xMin;
              this._owner.width = this._owner._rawWidth + dx;
              this._owner.xMin = tmp;
            } else
              this._owner.width = this._owner._rawWidth + dx;
            break;
          case RelationType.TopExt_Top:
          case RelationType.TopExt_Bottom:
            if (this._owner != this._target.parent) {
              tmp = this._owner.yMin;
              this._owner.height = this._owner._rawHeight - dy;
              this._owner.yMin = tmp + dy;
            } else
              this._owner.height = this._owner._rawHeight - dy;
            break;
          case RelationType.BottomExt_Top:
          case RelationType.BottomExt_Bottom:
            if (this._owner != this._target.parent) {
              tmp = this._owner.yMin;
              this._owner.height = this._owner._rawHeight + dy;
              this._owner.yMin = tmp;
            } else
              this._owner.height = this._owner._rawHeight + dy;
            break;
        }
      }
      applyOnSizeChanged(info) {
        var pos = 0, pivot = 0, delta = 0;
        var v, tmp;
        if (info.axis == 0) {
          if (this._target != this._owner.parent) {
            pos = this._target.x;
            if (this._target.pivotAsAnchor)
              pivot = this._target.pivotX;
          }
          if (info.percent) {
            if (this._targetWidth != 0)
              delta = this._target._width / this._targetWidth;
          } else
            delta = this._target._width - this._targetWidth;
        } else {
          if (this._target != this._owner.parent) {
            pos = this._target.y;
            if (this._target.pivotAsAnchor)
              pivot = this._target.pivotY;
          }
          if (info.percent) {
            if (this._targetHeight != 0)
              delta = this._target._height / this._targetHeight;
          } else
            delta = this._target._height - this._targetHeight;
        }
        switch (info.type) {
          case RelationType.Left_Left:
            if (info.percent)
              this._owner.xMin = pos + (this._owner.xMin - pos) * delta;
            else if (pivot != 0)
              this._owner.x += delta * -pivot;
            break;
          case RelationType.Left_Center:
            if (info.percent)
              this._owner.xMin = pos + (this._owner.xMin - pos) * delta;
            else
              this._owner.x += delta * (0.5 - pivot);
            break;
          case RelationType.Left_Right:
            if (info.percent)
              this._owner.xMin = pos + (this._owner.xMin - pos) * delta;
            else
              this._owner.x += delta * (1 - pivot);
            break;
          case RelationType.Center_Center:
            if (info.percent)
              this._owner.xMin = pos + (this._owner.xMin + this._owner._rawWidth * 0.5 - pos) * delta - this._owner._rawWidth * 0.5;
            else
              this._owner.x += delta * (0.5 - pivot);
            break;
          case RelationType.Right_Left:
            if (info.percent)
              this._owner.xMin = pos + (this._owner.xMin + this._owner._rawWidth - pos) * delta - this._owner._rawWidth;
            else if (pivot != 0)
              this._owner.x += delta * -pivot;
            break;
          case RelationType.Right_Center:
            if (info.percent)
              this._owner.xMin = pos + (this._owner.xMin + this._owner._rawWidth - pos) * delta - this._owner._rawWidth;
            else
              this._owner.x += delta * (0.5 - pivot);
            break;
          case RelationType.Right_Right:
            if (info.percent)
              this._owner.xMin = pos + (this._owner.xMin + this._owner._rawWidth - pos) * delta - this._owner._rawWidth;
            else
              this._owner.x += delta * (1 - pivot);
            break;
          case RelationType.Top_Top:
            if (info.percent)
              this._owner.yMin = pos + (this._owner.yMin - pos) * delta;
            else if (pivot != 0)
              this._owner.y += delta * -pivot;
            break;
          case RelationType.Top_Middle:
            if (info.percent)
              this._owner.yMin = pos + (this._owner.yMin - pos) * delta;
            else
              this._owner.y += delta * (0.5 - pivot);
            break;
          case RelationType.Top_Bottom:
            if (info.percent)
              this._owner.yMin = pos + (this._owner.yMin - pos) * delta;
            else
              this._owner.y += delta * (1 - pivot);
            break;
          case RelationType.Middle_Middle:
            if (info.percent)
              this._owner.yMin = pos + (this._owner.yMin + this._owner._rawHeight * 0.5 - pos) * delta - this._owner._rawHeight * 0.5;
            else
              this._owner.y += delta * (0.5 - pivot);
            break;
          case RelationType.Bottom_Top:
            if (info.percent)
              this._owner.yMin = pos + (this._owner.yMin + this._owner._rawHeight - pos) * delta - this._owner._rawHeight;
            else if (pivot != 0)
              this._owner.y += delta * -pivot;
            break;
          case RelationType.Bottom_Middle:
            if (info.percent)
              this._owner.yMin = pos + (this._owner.yMin + this._owner._rawHeight - pos) * delta - this._owner._rawHeight;
            else
              this._owner.y += delta * (0.5 - pivot);
            break;
          case RelationType.Bottom_Bottom:
            if (info.percent)
              this._owner.yMin = pos + (this._owner.yMin + this._owner._rawHeight - pos) * delta - this._owner._rawHeight;
            else
              this._owner.y += delta * (1 - pivot);
            break;
          case RelationType.Width:
            if (this._owner._underConstruct && this._owner == this._target.parent)
              v = this._owner.sourceWidth - this._target.initWidth;
            else
              v = this._owner._rawWidth - this._targetWidth;
            if (info.percent)
              v = v * delta;
            if (this._target == this._owner.parent) {
              if (this._owner.pivotAsAnchor) {
                tmp = this._owner.xMin;
                this._owner.setSize(this._target._width + v, this._owner._rawHeight, true);
                this._owner.xMin = tmp;
              } else
                this._owner.setSize(this._target._width + v, this._owner._rawHeight, true);
            } else
              this._owner.width = this._target._width + v;
            break;
          case RelationType.Height:
            if (this._owner._underConstruct && this._owner == this._target.parent)
              v = this._owner.sourceHeight - this._target.initHeight;
            else
              v = this._owner._rawHeight - this._targetHeight;
            if (info.percent)
              v = v * delta;
            if (this._target == this._owner.parent) {
              if (this._owner.pivotAsAnchor) {
                tmp = this._owner.yMin;
                this._owner.setSize(this._owner._rawWidth, this._target._height + v, true);
                this._owner.yMin = tmp;
              } else
                this._owner.setSize(this._owner._rawWidth, this._target._height + v, true);
            } else
              this._owner.height = this._target._height + v;
            break;
          case RelationType.LeftExt_Left:
            tmp = this._owner.xMin;
            if (info.percent)
              v = pos + (tmp - pos) * delta - tmp;
            else
              v = delta * -pivot;
            this._owner.width = this._owner._rawWidth - v;
            this._owner.xMin = tmp + v;
            break;
          case RelationType.LeftExt_Right:
            tmp = this._owner.xMin;
            if (info.percent)
              v = pos + (tmp - pos) * delta - tmp;
            else
              v = delta * (1 - pivot);
            this._owner.width = this._owner._rawWidth - v;
            this._owner.xMin = tmp + v;
            break;
          case RelationType.RightExt_Left:
            tmp = this._owner.xMin;
            if (info.percent)
              v = pos + (tmp + this._owner._rawWidth - pos) * delta - (tmp + this._owner._rawWidth);
            else
              v = delta * -pivot;
            this._owner.width = this._owner._rawWidth + v;
            this._owner.xMin = tmp;
            break;
          case RelationType.RightExt_Right:
            tmp = this._owner.xMin;
            if (info.percent) {
              if (this._owner == this._target.parent) {
                if (this._owner._underConstruct)
                  this._owner.width = pos + this._target._width - this._target._width * pivot + (this._owner.sourceWidth - pos - this._target.initWidth + this._target.initWidth * pivot) * delta;
                else
                  this._owner.width = pos + (this._owner._rawWidth - pos) * delta;
              } else {
                v = pos + (tmp + this._owner._rawWidth - pos) * delta - (tmp + this._owner._rawWidth);
                this._owner.width = this._owner._rawWidth + v;
                this._owner.xMin = tmp;
              }
            } else {
              if (this._owner == this._target.parent) {
                if (this._owner._underConstruct)
                  this._owner.width = this._owner.sourceWidth + (this._target._width - this._target.initWidth) * (1 - pivot);
                else
                  this._owner.width = this._owner._rawWidth + delta * (1 - pivot);
              } else {
                v = delta * (1 - pivot);
                this._owner.width = this._owner._rawWidth + v;
                this._owner.xMin = tmp;
              }
            }
            break;
          case RelationType.TopExt_Top:
            tmp = this._owner.yMin;
            if (info.percent)
              v = pos + (tmp - pos) * delta - tmp;
            else
              v = delta * -pivot;
            this._owner.height = this._owner._rawHeight - v;
            this._owner.yMin = tmp + v;
            break;
          case RelationType.TopExt_Bottom:
            tmp = this._owner.yMin;
            if (info.percent)
              v = pos + (tmp - pos) * delta - tmp;
            else
              v = delta * (1 - pivot);
            this._owner.height = this._owner._rawHeight - v;
            this._owner.yMin = tmp + v;
            break;
          case RelationType.BottomExt_Top:
            tmp = this._owner.yMin;
            if (info.percent)
              v = pos + (tmp + this._owner._rawHeight - pos) * delta - (tmp + this._owner._rawHeight);
            else
              v = delta * -pivot;
            this._owner.height = this._owner._rawHeight + v;
            this._owner.yMin = tmp;
            break;
          case RelationType.BottomExt_Bottom:
            tmp = this._owner.yMin;
            if (info.percent) {
              if (this._owner == this._target.parent) {
                if (this._owner._underConstruct)
                  this._owner.height = pos + this._target._height - this._target._height * pivot + (this._owner.sourceHeight - pos - this._target.initHeight + this._target.initHeight * pivot) * delta;
                else
                  this._owner.height = pos + (this._owner._rawHeight - pos) * delta;
              } else {
                v = pos + (tmp + this._owner._rawHeight - pos) * delta - (tmp + this._owner._rawHeight);
                this._owner.height = this._owner._rawHeight + v;
                this._owner.yMin = tmp;
              }
            } else {
              if (this._owner == this._target.parent) {
                if (this._owner._underConstruct)
                  this._owner.height = this._owner.sourceHeight + (this._target._height - this._target.initHeight) * (1 - pivot);
                else
                  this._owner.height = this._owner._rawHeight + delta * (1 - pivot);
              } else {
                v = delta * (1 - pivot);
                this._owner.height = this._owner._rawHeight + v;
                this._owner.yMin = tmp;
              }
            }
            break;
        }
      }
      addRefTarget(target) {
        if (target != this._owner.parent)
          target.on(Event.XY_CHANGED, this.__targetXYChanged, this);
        target.on(Event.SIZE_CHANGED, this.__targetSizeChanged, this);
        target.on(Event.SIZE_DELAY_CHANGE, this.__targetSizeWillChange, this);
        this._targetX = this._target.x;
        this._targetY = this._target.y;
        this._targetWidth = this._target._width;
        this._targetHeight = this._target._height;
      }
      releaseRefTarget(target) {
        if (!target.node)
          return;
        target.off(Event.XY_CHANGED, this.__targetXYChanged, this);
        target.off(Event.SIZE_CHANGED, this.__targetSizeChanged, this);
        target.off(Event.SIZE_DELAY_CHANGE, this.__targetSizeWillChange, this);
      }
      __targetXYChanged(evt) {
        if (this._owner.relations.handling != null || this._owner.group != null && this._owner.group._updating) {
          this._targetX = this._target.x;
          this._targetY = this._target.y;
          return;
        }
        this._owner.relations.handling = this._target;
        var ox = this._owner.x;
        var oy = this._owner.y;
        var dx = this._target.x - this._targetX;
        var dy = this._target.y - this._targetY;
        var length = this._defs.length;
        for (var i = 0; i < length; i++) {
          var info = this._defs[i];
          this.applyOnXYChanged(info, dx, dy);
        }
        this._targetX = this._target.x;
        this._targetY = this._target.y;
        if (ox != this._owner.x || oy != this._owner.y) {
          ox = this._owner.x - ox;
          oy = this._owner.y - oy;
          this._owner.updateGearFromRelations(1, ox, oy);
          if (this._owner.parent) {
            var len = this._owner.parent._transitions.length;
            if (len > 0) {
              for (var i = 0; i < len; ++i) {
                this._owner.parent._transitions[i].updateFromRelations(this._owner.id, ox, oy);
              }
            }
          }
        }
        this._owner.relations.handling = null;
      }
      __targetSizeChanged(evt) {
        if (this._owner.relations.handling != null)
          return;
        this._owner.relations.handling = this._target;
        var ox = this._owner.x;
        var oy = this._owner.y;
        var ow = this._owner._rawWidth;
        var oh = this._owner._rawHeight;
        var length = this._defs.length;
        for (var i = 0; i < length; i++) {
          var info = this._defs[i];
          this.applyOnSizeChanged(info);
        }
        this._targetWidth = this._target._width;
        this._targetHeight = this._target._height;
        if (ox != this._owner.x || oy != this._owner.y) {
          ox = this._owner.x - ox;
          oy = this._owner.y - oy;
          this._owner.updateGearFromRelations(1, ox, oy);
          if (this._owner.parent) {
            var len = this._owner.parent._transitions.length;
            if (len > 0) {
              for (var i = 0; i < len; ++i) {
                this._owner.parent._transitions[i].updateFromRelations(this._owner.id, ox, oy);
              }
            }
          }
        }
        if (ow != this._owner._rawWidth || oh != this._owner._rawHeight) {
          ow = this._owner._rawWidth - ow;
          oh = this._owner._rawHeight - oh;
          this._owner.updateGearFromRelations(2, ow, oh);
        }
        this._owner.relations.handling = null;
      }
      __targetSizeWillChange(evt) {
        this._owner.relations.sizeDirty = true;
      }
    };
    RelationDef = class {
      constructor() {
        this.percent = false;
        this.type = 0;
        this.axis = 0;
      }
      copyFrom(source) {
        this.percent = source.percent;
        this.type = source.type;
        this.axis = source.axis;
      }
    };
    Relations = class {
      constructor(owner) {
        this.sizeDirty = false;
        this._owner = owner;
        this._items = new Array();
      }
      add(target, relationType, usePercent) {
        var length = this._items.length;
        for (var i = 0; i < length; i++) {
          var item = this._items[i];
          if (item.target == target) {
            item.add(relationType, usePercent);
            return;
          }
        }
        var newItem = new RelationItem(this._owner);
        newItem.target = target;
        newItem.add(relationType, usePercent);
        this._items.push(newItem);
      }
      remove(target, relationType) {
        relationType = relationType || 0;
        var cnt = this._items.length;
        var i = 0;
        while (i < cnt) {
          var item = this._items[i];
          if (item.target == target) {
            item.remove(relationType);
            if (item.isEmpty) {
              item.dispose();
              this._items.splice(i, 1);
              cnt--;
            } else
              i++;
          } else
            i++;
        }
      }
      contains(target) {
        var length = this._items.length;
        for (var i = 0; i < length; i++) {
          var item = this._items[i];
          if (item.target == target)
            return true;
        }
        return false;
      }
      clearFor(target) {
        var cnt = this._items.length;
        var i = 0;
        while (i < cnt) {
          var item = this._items[i];
          if (item.target == target) {
            item.dispose();
            this._items.splice(i, 1);
            cnt--;
          } else
            i++;
        }
      }
      clearAll() {
        var length = this._items.length;
        for (var i = 0; i < length; i++) {
          var item = this._items[i];
          item.dispose();
        }
        this._items.length = 0;
      }
      copyFrom(source) {
        this.clearAll();
        var arr = source._items;
        var length = arr.length;
        for (var i = 0; i < length; i++) {
          var ri = arr[i];
          var item = new RelationItem(this._owner);
          item.copyFrom(ri);
          this._items.push(item);
        }
      }
      dispose() {
        this.clearAll();
      }
      onOwnerSizeChanged(dWidth, dHeight, applyPivot) {
        if (this._items.length == 0)
          return;
        var length = this._items.length;
        for (var i = 0; i < length; i++) {
          var item = this._items[i];
          item.applyOnSelfResized(dWidth, dHeight, applyPivot);
        }
      }
      ensureRelationsSizeCorrect() {
        if (this._items.length == 0)
          return;
        this.sizeDirty = false;
        var length = this._items.length;
        for (var i = 0; i < length; i++) {
          var item = this._items[i];
          item.target.ensureSizeCorrect();
        }
      }
      get empty() {
        return this._items.length == 0;
      }
      setup(buffer, parentToChild) {
        var cnt = buffer.readByte();
        var target;
        for (var i = 0; i < cnt; i++) {
          var targetIndex = buffer.readShort();
          if (targetIndex == -1)
            target = this._owner.parent;
          else if (parentToChild)
            target = this._owner.getChildAt(targetIndex);
          else
            target = this._owner.parent.getChildAt(targetIndex);
          var newItem = new RelationItem(this._owner);
          newItem.target = target;
          this._items.push(newItem);
          var cnt2 = buffer.readByte();
          for (var j = 0; j < cnt2; j++) {
            var rt = buffer.readByte();
            var usePercent = buffer.readBool();
            newItem.internalAdd(rt, usePercent);
          }
        }
      }
    };
    UIConfig = class {
      constructor() {
      }
    };
    UIConfig.defaultFont = "Arial";
    UIConfig.modalLayerColor = new import_cc5.Color(51, 51, 51, 51);
    UIConfig.buttonSoundVolumeScale = 1;
    UIConfig.defaultScrollStep = 25;
    UIConfig.defaultScrollDecelerationRate = 0.967;
    UIConfig.defaultScrollBarDisplay = ScrollBarDisplayType.Visible;
    UIConfig.defaultScrollTouchEffect = true;
    UIConfig.defaultScrollBounceEffect = true;
    UIConfig.defaultComboBoxVisibleItemCount = 10;
    UIConfig.touchScrollSensitivity = 20;
    UIConfig.touchDragSensitivity = 10;
    UIConfig.clickDragSensitivity = 2;
    UIConfig.bringWindowToFrontOnClick = true;
    UIConfig.frameTimeForAsyncUIConstruction = 2e-3;
    UIConfig.linkUnderline = true;
    UIConfig.defaultUILayer = import_cc5.Layers.Enum.UI_2D;
    UIConfig.enableDelayLoad = true;
    UIConfig.autoReleaseAssets = false;
    _fontRegistry = {};
    GObject = class _GObject {
      constructor() {
        this._x = 0;
        this._y = 0;
        this._alpha = 1;
        this._visible = true;
        this._touchable = true;
        this._skewX = 0;
        this._skewY = 0;
        this._sortingOrder = 0;
        this._internalVisible = true;
        this.sourceWidth = 0;
        this.sourceHeight = 0;
        this.initWidth = 0;
        this.initHeight = 0;
        this.minWidth = 0;
        this.minHeight = 0;
        this.maxWidth = 0;
        this.maxHeight = 0;
        this._width = 0;
        this._height = 0;
        this._rawWidth = 0;
        this._rawHeight = 0;
        this._underConstruct = false;
        this._sizePercentInGroup = 0;
        this._node = new import_cc5.Node();
        this._uiTrans = this._node.addComponent(import_cc5.UITransform);
        this._uiOpacity = this.node.addComponent(import_cc5.UIOpacity);
        this._node["$gobj"] = this;
        this._node.layer = UIConfig.defaultUILayer;
        this._uiTrans.setAnchorPoint(0, 1);
        this._node.on(import_cc5.Node.EventType.ANCHOR_CHANGED, this.handleAnchorChanged, this);
        this._id = this._node.uuid;
        this._name = "";
        this._relations = new Relations(this);
        this._gears = new Array(10);
        this._blendMode = BlendMode.Normal;
        this._partner = this._node.addComponent(GObjectPartner);
      }
      get id() {
        return this._id;
      }
      get name() {
        return this._name;
      }
      set name(value) {
        this._name = value;
        this._node.name = value;
      }
      get x() {
        return this._x;
      }
      set x(value) {
        this.setPosition(value, this._y);
      }
      get y() {
        return this._y;
      }
      set y(value) {
        this.setPosition(this._x, value);
      }
      setPosition(xv, yv) {
        if (this._x != xv || this._y != yv) {
          var dx = xv - this._x;
          var dy = yv - this._y;
          this._x = xv;
          this._y = yv;
          this.handlePositionChanged();
          if (this instanceof GGroup)
            this.moveChildren(dx, dy);
          this.updateGear(1);
          if (this._parent && !("setVirtual" in this._parent)) {
            this._parent.setBoundsChangedFlag();
            if (this._group)
              this._group.setBoundsChangedFlag(true);
            this._node.emit(Event.XY_CHANGED, this);
          }
          if (_GObject.draggingObject == this && !s_dragging)
            this.localToGlobalRect(0, 0, this._width, this._height, sGlobalRect);
        }
      }
      get xMin() {
        return this._pivotAsAnchor ? this._x - this._width * this._uiTrans.anchorX : this._x;
      }
      set xMin(value) {
        if (this._pivotAsAnchor)
          this.setPosition(value + this._width * this._uiTrans.anchorX, this._y);
        else
          this.setPosition(value, this._y);
      }
      get yMin() {
        return this._pivotAsAnchor ? this._y - this._height * (1 - this._uiTrans.anchorY) : this._y;
      }
      set yMin(value) {
        if (this._pivotAsAnchor)
          this.setPosition(this._x, value + this._height * (1 - this._uiTrans.anchorY));
        else
          this.setPosition(this._x, value);
      }
      get pixelSnapping() {
        return this._pixelSnapping;
      }
      set pixelSnapping(value) {
        if (this._pixelSnapping != value) {
          this._pixelSnapping = value;
          this.handlePositionChanged();
        }
      }
      center(restraint) {
        var r;
        if (this._parent)
          r = this.parent;
        else
          r = Decls$1.GRoot.inst;
        this.setPosition((r.width - this._width) / 2, (r.height - this._height) / 2);
        if (restraint) {
          this.addRelation(r, RelationType.Center_Center);
          this.addRelation(r, RelationType.Middle_Middle);
        }
      }
      get width() {
        this.ensureSizeCorrect();
        if (this._relations.sizeDirty)
          this._relations.ensureRelationsSizeCorrect();
        return this._width;
      }
      set width(value) {
        this.setSize(value, this._rawHeight);
      }
      get height() {
        this.ensureSizeCorrect();
        if (this._relations.sizeDirty)
          this._relations.ensureRelationsSizeCorrect();
        return this._height;
      }
      set height(value) {
        this.setSize(this._rawWidth, value);
      }
      setSize(wv, hv, ignorePivot) {
        if (this._rawWidth != wv || this._rawHeight != hv) {
          this._rawWidth = wv;
          this._rawHeight = hv;
          if (wv < this.minWidth)
            wv = this.minWidth;
          if (hv < this.minHeight)
            hv = this.minHeight;
          if (this.maxWidth > 0 && wv > this.maxWidth)
            wv = this.maxWidth;
          if (this.maxHeight > 0 && hv > this.maxHeight)
            hv = this.maxHeight;
          var dWidth = wv - this._width;
          var dHeight = hv - this._height;
          this._width = wv;
          this._height = hv;
          this.handleSizeChanged();
          if ((this._uiTrans.anchorX != 0 || this._uiTrans.anchorY != 1) && !this._pivotAsAnchor && !ignorePivot)
            this.setPosition(this.x - this._uiTrans.anchorX * dWidth, this.y - (1 - this._uiTrans.anchorY) * dHeight);
          else
            this.handlePositionChanged();
          if (this instanceof GGroup)
            this.resizeChildren(dWidth, dHeight);
          this.updateGear(2);
          if (this._parent) {
            this._relations.onOwnerSizeChanged(dWidth, dHeight, this._pivotAsAnchor || !ignorePivot);
            this._parent.setBoundsChangedFlag();
            if (this._group)
              this._group.setBoundsChangedFlag();
          }
          this._node.emit(Event.SIZE_CHANGED, this);
        }
      }
      makeFullScreen() {
        this.setSize(Decls$1.GRoot.inst.width, Decls$1.GRoot.inst.height);
      }
      ensureSizeCorrect() {
      }
      get actualWidth() {
        return this.width * Math.abs(this._node.scale.x);
      }
      get actualHeight() {
        return this.height * Math.abs(this._node.scale.y);
      }
      get scaleX() {
        return this._node.scale.x;
      }
      set scaleX(value) {
        this.setScale(value, this._node.scale.y);
      }
      get scaleY() {
        return this._node.scale.y;
      }
      set scaleY(value) {
        this.setScale(this._node.scale.x, value);
      }
      setScale(sx, sy) {
        if (this._node.scale.x != sx || this._node.scale.y != sy) {
          this._node.setScale(sx, sy);
          this.updateGear(2);
        }
      }
      get skewX() {
        return this._skewX;
      }
      get pivotX() {
        return this._uiTrans.anchorX;
      }
      set pivotX(value) {
        this._uiTrans.anchorX = value;
      }
      get pivotY() {
        return 1 - this._uiTrans.anchorY;
      }
      set pivotY(value) {
        this._uiTrans.anchorY = 1 - value;
      }
      setPivot(xv, yv, asAnchor) {
        if (this._uiTrans.anchorX != xv || this._uiTrans.anchorY != 1 - yv) {
          this._pivotAsAnchor = asAnchor;
          this._uiTrans.setAnchorPoint(xv, 1 - yv);
        } else if (this._pivotAsAnchor != asAnchor) {
          this._pivotAsAnchor = asAnchor;
          this.handlePositionChanged();
        }
      }
      get pivotAsAnchor() {
        return this._pivotAsAnchor;
      }
      get touchable() {
        return this._touchable;
      }
      set touchable(value) {
        if (this._touchable != value) {
          this._touchable = value;
          this.updateGear(3);
        }
      }
      get grayed() {
        return this._grayed;
      }
      set grayed(value) {
        if (this._grayed != value) {
          this._grayed = value;
          this.handleGrayedChanged();
          this.updateGear(3);
        }
      }
      get enabled() {
        return !this._grayed && this._touchable;
      }
      set enabled(value) {
        this.grayed = !value;
        this.touchable = value;
      }
      get rotation() {
        return -this._node.angle;
      }
      set rotation(value) {
        value = -value;
        if (this._node.angle != value) {
          this._node.angle = value;
          this.updateGear(3);
        }
      }
      get alpha() {
        return this._alpha;
      }
      set alpha(value) {
        if (this._alpha != value) {
          this._alpha = value;
          this._uiOpacity.opacity = this._alpha * 255;
          if (this instanceof GGroup)
            this.handleAlphaChanged();
          this.updateGear(3);
        }
      }
      get visible() {
        return this._visible;
      }
      set visible(value) {
        if (this._visible != value) {
          this._visible = value;
          this.handleVisibleChanged();
          if (this._group && this._group.excludeInvisibles)
            this._group.setBoundsChangedFlag();
        }
      }
      get _finalVisible() {
        return this._visible && this._internalVisible && (!this._group || this._group._finalVisible);
      }
      get internalVisible3() {
        return this._visible && this._internalVisible;
      }
      get sortingOrder() {
        return this._sortingOrder;
      }
      set sortingOrder(value) {
        if (value < 0)
          value = 0;
        if (this._sortingOrder != value) {
          var old = this._sortingOrder;
          this._sortingOrder = value;
          if (this._parent)
            this._parent.childSortingOrderChanged(this, old, this._sortingOrder);
        }
      }
      requestFocus() {
      }
      get tooltips() {
        return this._tooltips;
      }
      set tooltips(value) {
        if (this._tooltips) {
          this._node.off(Event.ROLL_OVER, this.onRollOver, this);
          this._node.off(Event.ROLL_OUT, this.onRollOut, this);
        }
        this._tooltips = value;
        if (this._tooltips) {
          this._node.on(Event.ROLL_OVER, this.onRollOver, this);
          this._node.on(Event.ROLL_OUT, this.onRollOut, this);
        }
      }
      get blendMode() {
        return this._blendMode;
      }
      set blendMode(value) {
        if (this._blendMode != value) {
          this._blendMode = value;
          BlendModeUtils.apply(this._node, value);
        }
      }
      get onStage() {
        return this._node && this._node.activeInHierarchy;
      }
      get resourceURL() {
        if (this.packageItem)
          return "ui://" + this.packageItem.owner.id + this.packageItem.id;
        else
          return null;
      }
      set group(value) {
        if (this._group != value) {
          if (this._group)
            this._group.setBoundsChangedFlag();
          this._group = value;
          if (this._group)
            this._group.setBoundsChangedFlag();
        }
      }
      get group() {
        return this._group;
      }
      getGear(index) {
        var gear = this._gears[index];
        if (!gear)
          this._gears[index] = gear = createGear(this, index);
        return gear;
      }
      updateGear(index) {
        if (this._underConstruct || this._gearLocked)
          return;
        var gear = this._gears[index];
        if (gear && gear.controller)
          gear.updateState();
      }
      checkGearController(index, c) {
        return this._gears[index] && this._gears[index].controller == c;
      }
      updateGearFromRelations(index, dx, dy) {
        if (this._gears[index])
          this._gears[index].updateFromRelations(dx, dy);
      }
      addDisplayLock() {
        var gearDisplay = this._gears[0];
        if (gearDisplay && gearDisplay.controller) {
          var ret = gearDisplay.addLock();
          this.checkGearDisplay();
          return ret;
        } else
          return 0;
      }
      releaseDisplayLock(token) {
        var gearDisplay = this._gears[0];
        if (gearDisplay && gearDisplay.controller) {
          gearDisplay.releaseLock(token);
          this.checkGearDisplay();
        }
      }
      checkGearDisplay() {
        if (this._handlingController)
          return;
        var connected = this._gears[0] == null || this._gears[0].connected;
        if (this._gears[8])
          connected = this._gears[8].evaluate(connected);
        if (connected != this._internalVisible) {
          this._internalVisible = connected;
          this.handleVisibleChanged();
          if (this._group && this._group.excludeInvisibles)
            this._group.setBoundsChangedFlag();
        }
      }
      get gearXY() {
        return this.getGear(1);
      }
      get gearSize() {
        return this.getGear(2);
      }
      get gearLook() {
        return this.getGear(3);
      }
      get relations() {
        return this._relations;
      }
      addRelation(target, relationType, usePercent) {
        this._relations.add(target, relationType, usePercent);
      }
      removeRelation(target, relationType) {
        this._relations.remove(target, relationType);
      }
      get node() {
        return this._node;
      }
      get parent() {
        return this._parent;
      }
      removeFromParent() {
        if (this._parent)
          this._parent.removeChild(this);
      }
      findParent() {
        if (this._parent)
          return this._parent;
        let pn = this._node.parent;
        while (pn) {
          let gobj = pn["$gobj"];
          if (gobj)
            return gobj;
          pn = pn.parent;
        }
        return null;
      }
      get asCom() {
        return this;
      }
      static cast(obj) {
        return obj["$gobj"];
      }
      get text() {
        return null;
      }
      set text(value) {
      }
      get icon() {
        return null;
      }
      set icon(value) {
      }
      get treeNode() {
        return this._treeNode;
      }
      get isDisposed() {
        return this._node == null;
      }
      dispose() {
        let n = this._node;
        if (!n)
          return;
        this.removeFromParent();
        this._relations.dispose();
        this._node = null;
        n.destroy();
        for (var i = 0; i < 10; i++) {
          var gear = this._gears[i];
          if (gear)
            gear.dispose();
        }
      }
      onEnable() {
      }
      onDisable() {
      }
      onUpdate() {
      }
      onDestroy() {
      }
      onClick(listener, target) {
        this._node.on(Event.CLICK, listener, target);
      }
      onceClick(listener, target) {
        this._node.once(Event.CLICK, listener, target);
      }
      offClick(listener, target) {
        this._node.off(Event.CLICK, listener, target);
      }
      clearClick() {
        this._node.off(Event.CLICK);
      }
      hasClickListener() {
        return this._node.hasEventListener(Event.CLICK);
      }
      on(type, listener, target) {
        if (type == Event.DISPLAY || type == Event.UNDISPLAY)
          this._partner._emitDisplayEvents = true;
        this._node.on(type, listener, target);
      }
      once(type, listener, target) {
        if (type == Event.DISPLAY || type == Event.UNDISPLAY)
          this._partner._emitDisplayEvents = true;
        this._node.once(type, listener, target);
      }
      off(type, listener, target) {
        this._node.off(type, listener, target);
      }
      get draggable() {
        return this._draggable;
      }
      set draggable(value) {
        if (this._draggable != value) {
          this._draggable = value;
          this.initDrag();
        }
      }
      get dragBounds() {
        return this._dragBounds;
      }
      set dragBounds(value) {
        this._dragBounds = value;
      }
      startDrag(touchId) {
        if (!this._node.activeInHierarchy)
          return;
        this.dragBegin(touchId);
      }
      stopDrag() {
        this.dragEnd();
      }
      get dragging() {
        return _GObject.draggingObject == this;
      }
      localToGlobal(ax, ay, result) {
        ax = ax || 0;
        ay = ay || 0;
        s_vec3$1.x = ax;
        s_vec3$1.y = -ay;
        if (!this._pivotAsAnchor) {
          s_vec3$1.x -= this._uiTrans.anchorX * this._width;
          s_vec3$1.y += (1 - this._uiTrans.anchorY) * this._height;
        }
        this._uiTrans.convertToWorldSpaceAR(s_vec3$1, s_vec3$1);
        s_vec3$1.y = Decls$1.GRoot.inst.height - s_vec3$1.y;
        result = result || new import_cc5.Vec2();
        result.x = s_vec3$1.x;
        result.y = s_vec3$1.y;
        return result;
      }
      globalToLocal(ax, ay, result) {
        ax = ax || 0;
        ay = ay || 0;
        s_vec3$1.x = ax;
        s_vec3$1.y = Decls$1.GRoot.inst.height - ay;
        this._uiTrans.convertToNodeSpaceAR(s_vec3$1, s_vec3$1);
        if (!this._pivotAsAnchor) {
          s_vec3$1.x += this._uiTrans.anchorX * this._width;
          s_vec3$1.y -= (1 - this._uiTrans.anchorY) * this._height;
        }
        result = result || new import_cc5.Vec2();
        result.x = s_vec3$1.x;
        result.y = -s_vec3$1.y;
        return result;
      }
      localToGlobalRect(ax, ay, aw, ah, result) {
        ax = ax || 0;
        ay = ay || 0;
        aw = aw || 0;
        ah = ah || 0;
        result = result || new import_cc5.Rect();
        var pt = this.localToGlobal(ax, ay);
        result.x = pt.x;
        result.y = pt.y;
        pt = this.localToGlobal(ax + aw, ay + ah, pt);
        result.xMax = pt.x;
        result.yMax = pt.y;
        return result;
      }
      globalToLocalRect(ax, ay, aw, ah, result) {
        ax = ax || 0;
        ay = ay || 0;
        aw = aw || 0;
        ah = ah || 0;
        result = result || new import_cc5.Rect();
        var pt = this.globalToLocal(ax, ay);
        result.x = pt.x;
        result.y = pt.y;
        pt = this.globalToLocal(ax + aw, ay + ah, pt);
        result.xMax = pt.x;
        result.yMax = pt.y;
        return result;
      }
      handleControllerChanged(c) {
        this._handlingController = true;
        for (var i = 0; i < 10; i++) {
          var gear = this._gears[i];
          if (gear && gear.controller == c)
            gear.apply();
        }
        this._handlingController = false;
        this.checkGearDisplay();
      }
      handleAnchorChanged() {
        this.handlePositionChanged();
      }
      handlePositionChanged() {
        var xv = this._x;
        var yv = -this._y;
        if (!this._pivotAsAnchor) {
          xv += this._uiTrans.anchorX * this._width;
          yv -= (1 - this._uiTrans.anchorY) * this._height;
        }
        if (this._pixelSnapping) {
          xv = Math.round(xv);
          yv = Math.round(yv);
        }
        this._node.setPosition(xv, yv);
      }
      handleSizeChanged() {
        this._uiTrans.setContentSize(this._width, this._height);
      }
      handleGrayedChanged() {
      }
      handleVisibleChanged() {
        this._node.active = this._finalVisible;
        if (this instanceof GGroup)
          this.handleVisibleChanged();
        if (this._parent)
          this._parent.setBoundsChangedFlag();
      }
      hitTest(globalPt, forTouch) {
        if (forTouch == null)
          forTouch = true;
        if (forTouch && (this._touchDisabled || !this._touchable || !this._node.activeInHierarchy))
          return null;
        if (!this._hitTestPt)
          this._hitTestPt = new import_cc5.Vec2();
        this.globalToLocal(globalPt.x, globalPt.y, this._hitTestPt);
        if (this._pivotAsAnchor) {
          this._hitTestPt.x += this._uiTrans.anchorX * this._width;
          this._hitTestPt.y += (1 - this._uiTrans.anchorY) * this._height;
        }
        return this._hitTest(this._hitTestPt, globalPt);
      }
      _hitTest(pt, globalPt) {
        if (pt.x >= 0 && pt.y >= 0 && pt.x < this._width && pt.y < this._height)
          return this;
        else
          return null;
      }
      getProp(index) {
        switch (index) {
          case ObjectPropID.Text:
            return this.text;
          case ObjectPropID.Icon:
            return this.icon;
          case ObjectPropID.Color:
            return null;
          case ObjectPropID.OutlineColor:
            return null;
          case ObjectPropID.Playing:
            return false;
          case ObjectPropID.Frame:
            return 0;
          case ObjectPropID.DeltaTime:
            return 0;
          case ObjectPropID.TimeScale:
            return 1;
          case ObjectPropID.FontSize:
            return 0;
          case ObjectPropID.Selected:
            return false;
          default:
            return void 0;
        }
      }
      setProp(index, value) {
        switch (index) {
          case ObjectPropID.Text:
            this.text = value;
            break;
          case ObjectPropID.Icon:
            this.icon = value;
            break;
        }
      }
      constructFromResource() {
      }
      setup_beforeAdd(buffer, beginPos) {
        buffer.seek(beginPos, 0);
        buffer.skip(5);
        var f1;
        var f2;
        this._id = buffer.readS();
        this.name = buffer.readS();
        f1 = buffer.readInt();
        f2 = buffer.readInt();
        this.setPosition(f1, f2);
        if (buffer.readBool()) {
          this.initWidth = buffer.readInt();
          this.initHeight = buffer.readInt();
          this.setSize(this.initWidth, this.initHeight, true);
        }
        if (buffer.readBool()) {
          this.minWidth = buffer.readInt();
          this.maxWidth = buffer.readInt();
          this.minHeight = buffer.readInt();
          this.maxHeight = buffer.readInt();
        }
        if (buffer.readBool()) {
          f1 = buffer.readFloat();
          f2 = buffer.readFloat();
          this.setScale(f1, f2);
        }
        if (buffer.readBool()) {
          f1 = buffer.readFloat();
          f2 = buffer.readFloat();
        }
        if (buffer.readBool()) {
          f1 = buffer.readFloat();
          f2 = buffer.readFloat();
          this.setPivot(f1, f2, buffer.readBool());
        }
        f1 = buffer.readFloat();
        if (f1 != 1)
          this.alpha = f1;
        f1 = buffer.readFloat();
        if (f1 != 0)
          this.rotation = f1;
        if (!buffer.readBool())
          this.visible = false;
        if (!buffer.readBool())
          this.touchable = false;
        if (buffer.readBool())
          this.grayed = true;
        this.blendMode = buffer.readByte();
        buffer.readByte();
        var str = buffer.readS();
        if (str != null)
          this.data = str;
      }
      setup_afterAdd(buffer, beginPos) {
        buffer.seek(beginPos, 1);
        var str = buffer.readS();
        if (str != null)
          this.tooltips = str;
        var groupId = buffer.readShort();
        if (groupId >= 0)
          this.group = this.parent.getChildAt(groupId);
        buffer.seek(beginPos, 2);
        var cnt = buffer.readShort();
        for (var i = 0; i < cnt; i++) {
          var nextPos = buffer.readShort();
          nextPos += buffer.position;
          var gear = this.getGear(buffer.readByte());
          gear.setup(buffer);
          buffer.position = nextPos;
        }
      }
      //toolTips support
      onRollOver() {
        Decls$1.GRoot.inst.showTooltips(this.tooltips);
      }
      onRollOut() {
        Decls$1.GRoot.inst.hideTooltips();
      }
      //drag support
      //-------------------------------------------------------------------
      initDrag() {
        if (this._draggable) {
          this.on(Event.TOUCH_BEGIN, this.onTouchBegin_0, this);
          this.on(Event.TOUCH_MOVE, this.onTouchMove_0, this);
          this.on(Event.TOUCH_END, this.onTouchEnd_0, this);
        } else {
          this.off(Event.TOUCH_BEGIN, this.onTouchBegin_0, this);
          this.off(Event.TOUCH_MOVE, this.onTouchMove_0, this);
          this.off(Event.TOUCH_END, this.onTouchEnd_0, this);
        }
      }
      dragBegin(touchId) {
        if (_GObject.draggingObject) {
          let tmp = _GObject.draggingObject;
          tmp.stopDrag();
          _GObject.draggingObject = null;
          tmp._node.emit(Event.DRAG_END);
        }
        if (touchId == void 0)
          touchId = Decls$1.GRoot.inst.inputProcessor.getAllTouches()[0];
        sGlobalDragStart.set(Decls$1.GRoot.inst.getTouchPosition(touchId));
        this.localToGlobalRect(0, 0, this._width, this._height, sGlobalRect);
        _GObject.draggingObject = this;
        this._dragTesting = false;
        Decls$1.GRoot.inst.inputProcessor.addTouchMonitor(touchId, this);
        this.on(Event.TOUCH_MOVE, this.onTouchMove_0, this);
        this.on(Event.TOUCH_END, this.onTouchEnd_0, this);
      }
      dragEnd() {
        if (_GObject.draggingObject == this) {
          this._dragTesting = false;
          _GObject.draggingObject = null;
        }
        s_dragQuery = false;
      }
      onTouchBegin_0(evt) {
        if (this._dragStartPos == null)
          this._dragStartPos = new import_cc5.Vec2();
        this._dragStartPos.set(evt.pos);
        this._dragTesting = true;
        evt.captureTouch();
      }
      onTouchMove_0(evt) {
        if (_GObject.draggingObject != this && this._draggable && this._dragTesting) {
          var sensitivity = UIConfig.touchDragSensitivity;
          if (this._dragStartPos && Math.abs(this._dragStartPos.x - evt.pos.x) < sensitivity && Math.abs(this._dragStartPos.y - evt.pos.y) < sensitivity)
            return;
          this._dragTesting = false;
          s_dragQuery = true;
          this._node.emit(Event.DRAG_START, evt);
          if (s_dragQuery)
            this.dragBegin(evt.touchId);
        }
        if (_GObject.draggingObject == this) {
          var xx = evt.pos.x - sGlobalDragStart.x + sGlobalRect.x;
          var yy = evt.pos.y - sGlobalDragStart.y + sGlobalRect.y;
          if (this._dragBounds) {
            var rect = Decls$1.GRoot.inst.localToGlobalRect(this._dragBounds.x, this._dragBounds.y, this._dragBounds.width, this._dragBounds.height, s_rect$1);
            if (xx < rect.x)
              xx = rect.x;
            else if (xx + sGlobalRect.width > rect.xMax) {
              xx = rect.xMax - sGlobalRect.width;
              if (xx < rect.x)
                xx = rect.x;
            }
            if (yy < rect.y)
              yy = rect.y;
            else if (yy + sGlobalRect.height > rect.yMax) {
              yy = rect.yMax - sGlobalRect.height;
              if (yy < rect.y)
                yy = rect.y;
            }
          }
          s_dragging = true;
          var pt = this.parent.globalToLocal(xx, yy, s_vec2$4);
          this.setPosition(Math.round(pt.x), Math.round(pt.y));
          s_dragging = false;
          this._node.emit(Event.DRAG_MOVE, evt);
        }
      }
      onTouchEnd_0(evt) {
        if (_GObject.draggingObject == this) {
          _GObject.draggingObject = null;
          this._node.emit(Event.DRAG_END, evt);
        }
      }
    };
    GObjectPartner = class extends import_cc5.Component {
      callLater(callback, delay) {
        if (!import_cc5.director.getScheduler().isScheduled(callback, this))
          this.scheduleOnce(callback, delay);
      }
      onClickLink(evt, text) {
        this.node.emit(Event.LINK, text, evt);
      }
      onEnable() {
        this.node["$gobj"].onEnable();
        if (this._emitDisplayEvents)
          this.node.emit(Event.DISPLAY);
      }
      onDisable() {
        this.node["$gobj"].onDisable();
        if (this._emitDisplayEvents)
          this.node.emit(Event.UNDISPLAY);
      }
      update(dt) {
        this.node["$gobj"].onUpdate(dt);
      }
      onDestroy() {
        this.node["$gobj"].onDestroy();
      }
    };
    GearClasses = [
      GearDisplay,
      GearXY,
      GearSize,
      GearLook,
      GearColor,
      GearAnimation,
      GearText,
      GearIcon,
      GearDisplay2,
      GearFontSize
    ];
    s_vec2$4 = new import_cc5.Vec2();
    s_vec3$1 = new import_cc5.Vec3();
    s_rect$1 = new import_cc5.Rect();
    sGlobalDragStart = new import_cc5.Vec2();
    sGlobalRect = new import_cc5.Rect();
    Decls$1 = {};
    constructingDepth = { n: 0 };
    GGroup = class extends GObject {
      constructor() {
        super();
        this._layout = 0;
        this._lineGap = 0;
        this._columnGap = 0;
        this._mainGridIndex = -1;
        this._mainGridMinSize = 50;
        this._mainChildIndex = -1;
        this._totalSize = 0;
        this._numChildren = 0;
        this._updating = 0;
        this._node.name = "GGroup";
        this._touchDisabled = true;
      }
      dispose() {
        this._boundsChanged = false;
        super.dispose();
      }
      get layout() {
        return this._layout;
      }
      set layout(value) {
        if (this._layout != value) {
          this._layout = value;
          this.setBoundsChangedFlag();
        }
      }
      get lineGap() {
        return this._lineGap;
      }
      set lineGap(value) {
        if (this._lineGap != value) {
          this._lineGap = value;
          this.setBoundsChangedFlag(true);
        }
      }
      get columnGap() {
        return this._columnGap;
      }
      set columnGap(value) {
        if (this._columnGap != value) {
          this._columnGap = value;
          this.setBoundsChangedFlag(true);
        }
      }
      get excludeInvisibles() {
        return this._excludeInvisibles;
      }
      set excludeInvisibles(value) {
        if (this._excludeInvisibles != value) {
          this._excludeInvisibles = value;
          this.setBoundsChangedFlag();
        }
      }
      get autoSizeDisabled() {
        return this._autoSizeDisabled;
      }
      set autoSizeDisabled(value) {
        this._autoSizeDisabled = value;
      }
      get mainGridMinSize() {
        return this._mainGridMinSize;
      }
      set mainGridMinSize(value) {
        if (this._mainGridMinSize != value) {
          this._mainGridMinSize = value;
          this.setBoundsChangedFlag();
        }
      }
      get mainGridIndex() {
        return this._mainGridIndex;
      }
      set mainGridIndex(value) {
        if (this._mainGridIndex != value) {
          this._mainGridIndex = value;
          this.setBoundsChangedFlag();
        }
      }
      setBoundsChangedFlag(positionChangedOnly = false) {
        if (this._updating == 0 && this._parent) {
          if (!positionChangedOnly)
            this._percentReady = false;
          if (!this._boundsChanged) {
            this._boundsChanged = true;
            if (this._layout != GroupLayoutType.None)
              this._partner.callLater(this._ensureBoundsCorrect);
          }
        }
      }
      _ensureBoundsCorrect() {
        let _t = GObject.cast(this.node);
        _t.ensureBoundsCorrect();
      }
      ensureSizeCorrect() {
        if (this._parent == null || !this._boundsChanged || this._layout == 0)
          return;
        this._boundsChanged = false;
        if (this._autoSizeDisabled)
          this.resizeChildren(0, 0);
        else {
          this.handleLayout();
          this.updateBounds();
        }
      }
      ensureBoundsCorrect() {
        if (this._parent == null || !this._boundsChanged)
          return;
        this._boundsChanged = false;
        if (this._layout == 0)
          this.updateBounds();
        else {
          if (this._autoSizeDisabled)
            this.resizeChildren(0, 0);
          else {
            this.handleLayout();
            this.updateBounds();
          }
        }
      }
      updateBounds() {
        this._partner.unschedule(this._ensureBoundsCorrect);
        var cnt = this._parent.numChildren;
        var i;
        var child;
        var ax = Number.POSITIVE_INFINITY, ay = Number.POSITIVE_INFINITY;
        var ar = Number.NEGATIVE_INFINITY, ab = Number.NEGATIVE_INFINITY;
        var tmp;
        var empty = true;
        for (i = 0; i < cnt; i++) {
          child = this._parent.getChildAt(i);
          if (child.group != this || this._excludeInvisibles && !child.internalVisible3)
            continue;
          tmp = child.xMin;
          if (tmp < ax)
            ax = tmp;
          tmp = child.yMin;
          if (tmp < ay)
            ay = tmp;
          tmp = child.xMin + child.width;
          if (tmp > ar)
            ar = tmp;
          tmp = child.yMin + child.height;
          if (tmp > ab)
            ab = tmp;
          empty = false;
        }
        var w = 0, h = 0;
        if (!empty) {
          this._updating |= 1;
          this.setPosition(ax, ay);
          this._updating &= 2;
          w = ar - ax;
          h = ab - ay;
        }
        if ((this._updating & 2) == 0) {
          this._updating |= 2;
          this.setSize(w, h);
          this._updating &= 1;
        } else {
          this._updating &= 1;
          this.resizeChildren(this._width - w, this._height - h);
        }
      }
      handleLayout() {
        this._updating |= 1;
        var child;
        var i;
        var cnt;
        if (this._layout == GroupLayoutType.Horizontal) {
          var curX = this.x;
          cnt = this._parent.numChildren;
          for (i = 0; i < cnt; i++) {
            child = this._parent.getChildAt(i);
            if (child.group != this)
              continue;
            if (this._excludeInvisibles && !child.internalVisible3)
              continue;
            child.xMin = curX;
            if (child.width != 0)
              curX += child.width + this._columnGap;
          }
        } else if (this._layout == GroupLayoutType.Vertical) {
          var curY = this.y;
          cnt = this._parent.numChildren;
          for (i = 0; i < cnt; i++) {
            child = this._parent.getChildAt(i);
            if (child.group != this)
              continue;
            if (this._excludeInvisibles && !child.internalVisible3)
              continue;
            child.yMin = curY;
            if (child.height != 0)
              curY += child.height + this._lineGap;
          }
        }
        this._updating &= 2;
      }
      moveChildren(dx, dy) {
        if ((this._updating & 1) != 0 || this._parent == null)
          return;
        this._updating |= 1;
        var cnt = this._parent.numChildren;
        var i;
        var child;
        for (i = 0; i < cnt; i++) {
          child = this._parent.getChildAt(i);
          if (child.group == this) {
            child.setPosition(child.x + dx, child.y + dy);
          }
        }
        this._updating &= 2;
      }
      resizeChildren(dw, dh) {
        if (this._layout == GroupLayoutType.None || (this._updating & 2) != 0 || this._parent == null)
          return;
        this._updating |= 2;
        if (this._boundsChanged) {
          this._boundsChanged = false;
          if (!this._autoSizeDisabled) {
            this.updateBounds();
            return;
          }
        }
        var cnt = this._parent.numChildren;
        var i;
        var child;
        if (!this._percentReady) {
          this._percentReady = true;
          this._numChildren = 0;
          this._totalSize = 0;
          this._mainChildIndex = -1;
          var j = 0;
          for (i = 0; i < cnt; i++) {
            child = this._parent.getChildAt(i);
            if (child.group != this)
              continue;
            if (!this._excludeInvisibles || child.internalVisible3) {
              if (j == this._mainGridIndex)
                this._mainChildIndex = i;
              this._numChildren++;
              if (this._layout == 1)
                this._totalSize += child.width;
              else
                this._totalSize += child.height;
            }
            j++;
          }
          if (this._mainChildIndex != -1) {
            if (this._layout == 1) {
              child = this._parent.getChildAt(this._mainChildIndex);
              this._totalSize += this._mainGridMinSize - child.width;
              child._sizePercentInGroup = this._mainGridMinSize / this._totalSize;
            } else {
              child = this._parent.getChildAt(this._mainChildIndex);
              this._totalSize += this._mainGridMinSize - child.height;
              child._sizePercentInGroup = this._mainGridMinSize / this._totalSize;
            }
          }
          for (i = 0; i < cnt; i++) {
            child = this._parent.getChildAt(i);
            if (child.group != this)
              continue;
            if (i == this._mainChildIndex)
              continue;
            if (this._totalSize > 0)
              child._sizePercentInGroup = (this._layout == 1 ? child.width : child.height) / this._totalSize;
            else
              child._sizePercentInGroup = 0;
          }
        }
        var remainSize = 0;
        var remainPercent = 1;
        var priorHandled = false;
        if (this._layout == 1) {
          remainSize = this.width - (this._numChildren - 1) * this._columnGap;
          if (this._mainChildIndex != -1 && remainSize >= this._totalSize) {
            child = this._parent.getChildAt(this._mainChildIndex);
            child.setSize(remainSize - (this._totalSize - this._mainGridMinSize), child._rawHeight + dh, true);
            remainSize -= child.width;
            remainPercent -= child._sizePercentInGroup;
            priorHandled = true;
          }
          var curX = this.x;
          for (i = 0; i < cnt; i++) {
            child = this._parent.getChildAt(i);
            if (child.group != this)
              continue;
            if (this._excludeInvisibles && !child.internalVisible3) {
              child.setSize(child._rawWidth, child._rawHeight + dh, true);
              continue;
            }
            if (!priorHandled || i != this._mainChildIndex) {
              child.setSize(Math.round(child._sizePercentInGroup / remainPercent * remainSize), child._rawHeight + dh, true);
              remainPercent -= child._sizePercentInGroup;
              remainSize -= child.width;
            }
            child.xMin = curX;
            if (child.width != 0)
              curX += child.width + this._columnGap;
          }
        } else {
          remainSize = this.height - (this._numChildren - 1) * this._lineGap;
          if (this._mainChildIndex != -1 && remainSize >= this._totalSize) {
            child = this._parent.getChildAt(this._mainChildIndex);
            child.setSize(child._rawWidth + dw, remainSize - (this._totalSize - this._mainGridMinSize), true);
            remainSize -= child.height;
            remainPercent -= child._sizePercentInGroup;
            priorHandled = true;
          }
          var curY = this.y;
          for (i = 0; i < cnt; i++) {
            child = this._parent.getChildAt(i);
            if (child.group != this)
              continue;
            if (this._excludeInvisibles && !child.internalVisible3) {
              child.setSize(child._rawWidth + dw, child._rawHeight, true);
              continue;
            }
            if (!priorHandled || i != this._mainChildIndex) {
              child.setSize(child._rawWidth + dw, Math.round(child._sizePercentInGroup / remainPercent * remainSize), true);
              remainPercent -= child._sizePercentInGroup;
              remainSize -= child.height;
            }
            child.yMin = curY;
            if (child.height != 0)
              curY += child.height + this._lineGap;
          }
        }
        this._updating &= 1;
      }
      handleAlphaChanged() {
        if (this._underConstruct)
          return;
        var cnt = this._parent.numChildren;
        for (var i = 0; i < cnt; i++) {
          var child = this._parent.getChildAt(i);
          if (child.group == this)
            child.alpha = this.alpha;
        }
      }
      handleVisibleChanged() {
        if (!this._parent)
          return;
        var cnt = this._parent.numChildren;
        for (var i = 0; i < cnt; i++) {
          var child = this._parent.getChildAt(i);
          if (child.group == this)
            child.handleVisibleChanged();
        }
      }
      setup_beforeAdd(buffer, beginPos) {
        super.setup_beforeAdd(buffer, beginPos);
        buffer.seek(beginPos, 5);
        this._layout = buffer.readByte();
        this._lineGap = buffer.readInt();
        this._columnGap = buffer.readInt();
        if (buffer.version >= 2) {
          this._excludeInvisibles = buffer.readBool();
          this._autoSizeDisabled = buffer.readBool();
          this._mainGridIndex = buffer.readShort();
        }
      }
      setup_afterAdd(buffer, beginPos) {
        super.setup_afterAdd(buffer, beginPos);
        if (!this.visible)
          this.handleVisibleChanged();
      }
    };
    GGraph = class extends GObject {
      constructor() {
        super();
        this._type = 0;
        this._lineSize = 0;
        this._node.name = "GGraph";
        this._lineSize = 1;
        this._lineColor = new import_cc5.Color();
        this._fillColor = new import_cc5.Color(255, 255, 255, 255);
        this._content = this._node.addComponent(import_cc5.Graphics);
      }
      drawRect(lineSize, lineColor, fillColor, corner) {
        this._type = 1;
        this._lineSize = lineSize;
        this._lineColor.set(lineColor);
        this._fillColor.set(fillColor);
        this._cornerRadius = corner;
        this.updateGraph();
      }
      drawEllipse(lineSize, lineColor, fillColor) {
        this._type = 2;
        this._lineSize = lineSize;
        this._lineColor.set(lineColor);
        this._fillColor.set(fillColor);
        this.updateGraph();
      }
      drawRegularPolygon(lineSize, lineColor, fillColor, sides, startAngle, distances) {
        this._type = 4;
        this._lineSize = lineSize;
        this._lineColor.set(lineColor);
        this._fillColor.set(fillColor);
        this._sides = sides;
        this._startAngle = startAngle || 0;
        this._distances = distances;
        this.updateGraph();
      }
      drawPolygon(lineSize, lineColor, fillColor, points) {
        this._type = 3;
        this._lineSize = lineSize;
        this._lineColor.set(lineColor);
        this._fillColor.set(fillColor);
        this._polygonPoints = points;
        this.updateGraph();
      }
      get distances() {
        return this._distances;
      }
      set distances(value) {
        this._distances = value;
        if (this._type == 3)
          this.updateGraph();
      }
      clearGraphics() {
        this._type = 0;
        if (this._hasContent) {
          this._content.clear();
          this._hasContent = false;
        }
      }
      get type() {
        return this._type;
      }
      get color() {
        return this._fillColor;
      }
      set color(value) {
        this._fillColor.set(value);
        if (this._type != 0)
          this.updateGraph();
      }
      updateGraph() {
        let ctx = this._content;
        if (this._hasContent) {
          this._hasContent = false;
          ctx.clear();
        }
        var w = this._width;
        var h = this._height;
        if (w == 0 || h == 0)
          return;
        var px = -this.pivotX * this._width;
        var py = this.pivotY * this._height;
        let ls = this._lineSize / 2;
        ctx.lineWidth = this._lineSize;
        ctx.strokeColor = this._lineColor;
        ctx.fillColor = this._fillColor;
        if (this._type == 1) {
          if (this._cornerRadius) {
            ctx.roundRect(px + ls, -h + py + ls, w - this._lineSize, h - this._lineSize, this._cornerRadius[0]);
          } else
            ctx.rect(px + ls, -h + py + ls, w - this._lineSize, h - this._lineSize);
        } else if (this._type == 2) {
          ctx.ellipse(w / 2 + px, -h / 2 + py, w / 2 - ls, h / 2 - ls);
        } else if (this._type == 3) {
          this.drawPath(ctx, this._polygonPoints, px, py);
        } else if (this._type == 4) {
          if (!this._polygonPoints)
            this._polygonPoints = [];
          var radius = Math.min(w, h) / 2 - ls;
          this._polygonPoints.length = 0;
          var angle = import_cc5.misc.degreesToRadians(this._startAngle);
          var deltaAngle = 2 * Math.PI / this._sides;
          var dist;
          for (var i = 0; i < this._sides; i++) {
            if (this._distances) {
              dist = this._distances[i];
              if (isNaN(dist))
                dist = 1;
            } else
              dist = 1;
            var xv = radius + radius * dist * Math.cos(angle);
            var yv = radius + radius * dist * Math.sin(angle);
            this._polygonPoints.push(xv, yv);
            angle += deltaAngle;
          }
          this.drawPath(ctx, this._polygonPoints, px, py);
        }
        if (ls != 0)
          ctx.stroke();
        if (this._fillColor.a != 0)
          ctx.fill();
        this._hasContent = true;
      }
      drawPath(ctx, points, px, py) {
        var cnt = points.length;
        ctx.moveTo(points[0] + px, -points[1] + py);
        for (var i = 2; i < cnt; i += 2)
          ctx.lineTo(points[i] + px, -points[i + 1] + py);
        ctx.lineTo(points[0] + px, -points[1] + py);
      }
      handleSizeChanged() {
        super.handleSizeChanged();
        if (this._type != 0)
          this.updateGraph();
      }
      handleAnchorChanged() {
        super.handleAnchorChanged();
        if (this._type != 0)
          this.updateGraph();
      }
      getProp(index) {
        if (index == ObjectPropID.Color)
          return this.color;
        else
          return super.getProp(index);
      }
      setProp(index, value) {
        if (index == ObjectPropID.Color)
          this.color = value;
        else
          super.setProp(index, value);
      }
      _hitTest(pt) {
        if (pt.x >= 0 && pt.y >= 0 && pt.x < this._width && pt.y < this._height) {
          if (this._type == 3) {
            let points = this._polygonPoints;
            let len = points.length / 2;
            let i;
            let j = len - 1;
            let oddNodes = false;
            this._width;
            this._height;
            for (i = 0; i < len; ++i) {
              let ix = points[i * 2];
              let iy = points[i * 2 + 1];
              let jx = points[j * 2];
              let jy = points[j * 2 + 1];
              if ((iy < pt.y && jy >= pt.y || jy < pt.y && iy >= pt.y) && (ix <= pt.x || jx <= pt.x)) {
                if (ix + (pt.y - iy) / (jy - iy) * (jx - ix) < pt.x)
                  oddNodes = !oddNodes;
              }
              j = i;
            }
            return oddNodes ? this : null;
          } else
            return this;
        } else
          return null;
      }
      setup_beforeAdd(buffer, beginPos) {
        super.setup_beforeAdd(buffer, beginPos);
        buffer.seek(beginPos, 5);
        this._type = buffer.readByte();
        if (this._type != 0) {
          var i;
          var cnt;
          this._lineSize = buffer.readInt();
          this._lineColor.set(buffer.readColor(true));
          this._fillColor.set(buffer.readColor(true));
          if (buffer.readBool()) {
            this._cornerRadius = new Array(4);
            for (i = 0; i < 4; i++)
              this._cornerRadius[i] = buffer.readFloat();
          }
          if (this._type == 3) {
            cnt = buffer.readShort();
            this._polygonPoints = [];
            this._polygonPoints.length = cnt;
            for (i = 0; i < cnt; i++)
              this._polygonPoints[i] = buffer.readFloat();
          } else if (this._type == 4) {
            this._sides = buffer.readShort();
            this._startAngle = buffer.readFloat();
            cnt = buffer.readShort();
            if (cnt > 0) {
              this._distances = [];
              for (i = 0; i < cnt; i++)
                this._distances[i] = buffer.readFloat();
            }
          }
          this.updateGraph();
        }
      }
    };
    Image = class extends import_cc5.Sprite {
      constructor() {
        super();
        this._flip = FlipType.None;
        this._fillMethod = FillMethod.None;
        this._fillOrigin = FillOrigin.Left;
        this._fillAmount = 0;
      }
      get flip() {
        return this._flip;
      }
      set flip(value) {
        if (this._flip != value) {
          this._flip = value;
          let sx = 1, sy = 1;
          if (this._flip == FlipType.Horizontal || this._flip == FlipType.Both)
            sx = -1;
          if (this._flip == FlipType.Vertical || this._flip == FlipType.Both)
            sy = -1;
          if (sx != 1 || sy != 1) {
            let uiTrans = this.node.getComponent(import_cc5.UITransform);
            uiTrans.setAnchorPoint(0.5, 0.5);
          }
          this.node.setScale(sx, sy);
        }
      }
      get fillMethod() {
        return this._fillMethod;
      }
      set fillMethod(value) {
        if (this._fillMethod != value) {
          this._fillMethod = value;
          if (this._fillMethod != 0) {
            this.updateFillType();
            this.setupFill();
          } else {
            this.type = import_cc5.Sprite.Type.SIMPLE;
          }
        }
      }
      updateFillType() {
        if (!this.spriteFrame) {
          return;
        }
        this.type = import_cc5.Sprite.Type.FILLED;
        if (this._fillMethod <= 3)
          this.fillType = this._fillMethod - 1;
        else
          this.fillType = import_cc5.Sprite.FillType.RADIAL;
        this.fillCenter = new import_cc5.Vec2(0.5, 0.5);
      }
      get fillOrigin() {
        return this._fillOrigin;
      }
      set fillOrigin(value) {
        if (this._fillOrigin != value) {
          this._fillOrigin = value;
          if (this._fillMethod != 0)
            this.setupFill();
        }
      }
      get fillClockwise() {
        return this._fillClockwise;
      }
      set fillClockwise(value) {
        if (this._fillClockwise != value) {
          this._fillClockwise = value;
          if (this._fillMethod != 0)
            this.setupFill();
        }
      }
      get fillAmount() {
        return this._fillAmount;
      }
      set fillAmount(value) {
        if (this._fillAmount != value) {
          this._fillAmount = value;
          if (this._fillMethod != 0) {
            this.updateFillRange();
          }
        }
      }
      updateFillRange() {
        if (!this.spriteFrame) {
          return;
        }
        if (this._fillClockwise)
          this.fillRange = -this._fillAmount;
        else
          this.fillRange = this._fillAmount;
      }
      __update() {
        if (this._fillMethod != 0) {
          this.updateFillType();
          this.setupFill();
          this.updateFillRange();
        }
      }
      setupFill() {
        if (!this.spriteFrame) {
          return;
        }
        if (this._fillMethod == FillMethod.Horizontal) {
          this._fillClockwise = this._fillOrigin == FillOrigin.Right || this._fillOrigin == FillOrigin.Bottom;
          this.fillStart = this._fillClockwise ? 1 : 0;
        } else if (this._fillMethod == FillMethod.Vertical) {
          this._fillClockwise = this._fillOrigin == FillOrigin.Left || this._fillOrigin == FillOrigin.Top;
          this.fillStart = this._fillClockwise ? 1 : 0;
        } else {
          switch (this._fillOrigin) {
            case FillOrigin.Right:
              this.fillOrigin = 0;
              break;
            case FillOrigin.Top:
              this.fillStart = 0.25;
              break;
            case FillOrigin.Left:
              this.fillStart = 0.5;
              break;
            case FillOrigin.Bottom:
              this.fillStart = 0.75;
              break;
          }
        }
      }
    };
    GImage = class extends GObject {
      constructor() {
        super();
        this._node.name = "GImage";
        this._touchDisabled = true;
        this._content = this._node.addComponent(Image);
        this._content.sizeMode = import_cc5.Sprite.SizeMode.CUSTOM;
        this._content.trim = false;
      }
      get color() {
        return this._content.color;
      }
      set color(value) {
        this._content.color = value;
        this.updateGear(4);
      }
      get flip() {
        return this._content.flip;
      }
      set flip(value) {
        this._content.flip = value;
      }
      get fillMethod() {
        return this._content.fillMethod;
      }
      set fillMethod(value) {
        this._content.fillMethod = value;
      }
      get fillOrigin() {
        return this._content.fillOrigin;
      }
      set fillOrigin(value) {
        this._content.fillOrigin = value;
      }
      get fillClockwise() {
        return this._content.fillClockwise;
      }
      set fillClockwise(value) {
        this._content.fillClockwise = value;
      }
      get fillAmount() {
        return this._content.fillAmount;
      }
      set fillAmount(value) {
        this._content.fillAmount = value;
      }
      init(contentItem) {
        if (!(0, import_cc5.isValid)(this.node)) {
          return;
        }
        this._content.spriteFrame = contentItem.asset;
        this._content.__update();
        this._contentPackageItem = contentItem;
        this._contentPackageItem.addRef();
        if (this.onReady) {
          this.onReady();
          this.onReady = null;
        }
      }
      constructFromResource() {
        var contentItem = this.packageItem.getBranch();
        this.sourceWidth = contentItem.width;
        this.sourceHeight = contentItem.height;
        this.initWidth = this.sourceWidth;
        this.initHeight = this.sourceHeight;
        this.setSize(this.sourceWidth, this.sourceHeight);
        contentItem = contentItem.getHighResolution();
        if (contentItem.scale9Grid)
          this._content.type = import_cc5.Sprite.Type.SLICED;
        else if (contentItem.scaleByTile)
          this._content.type = import_cc5.Sprite.Type.TILED;
        if (!UIConfig.enableDelayLoad || contentItem.__loaded && contentItem.decoded) {
          contentItem.load();
          this.init(contentItem);
        } else {
          contentItem.loadAsync().then(() => {
            this.init(contentItem);
          });
        }
      }
      dispose() {
        if (this._contentPackageItem) {
          this._contentPackageItem.decRef();
          this._contentPackageItem = null;
        }
        super.dispose();
      }
      handleGrayedChanged() {
        this._content.grayscale = this._grayed;
      }
      getProp(index) {
        if (index == ObjectPropID.Color)
          return this.color;
        else
          return super.getProp(index);
      }
      setProp(index, value) {
        if (index == ObjectPropID.Color)
          this.color = value;
        else
          super.setProp(index, value);
      }
      setup_beforeAdd(buffer, beginPos) {
        super.setup_beforeAdd(buffer, beginPos);
        buffer.seek(beginPos, 5);
        if (buffer.readBool())
          this.color = buffer.readColor();
        this._content.flip = buffer.readByte();
        this._content.fillMethod = buffer.readByte();
        if (this._content.fillMethod != 0) {
          this._content.fillOrigin = buffer.readByte();
          this._content.fillClockwise = buffer.readBool();
          this._content.fillAmount = buffer.readFloat();
        }
      }
    };
    MovieClip = class extends Image {
      constructor() {
        super();
        this.interval = 0;
        this.swing = false;
        this.repeatDelay = 0;
        this.timeScale = 1;
        this._playing = true;
        this._frameCount = 0;
        this._frame = 0;
        this._start = 0;
        this._end = 0;
        this._times = 0;
        this._endAt = 0;
        this._status = 0;
        this._smoothing = true;
        this._frameElapsed = 0;
        this._reversed = false;
        this._repeatedCount = 0;
      }
      get frames() {
        return this._frames;
      }
      set frames(value) {
        this._frames = value;
        if (this._frames) {
          this._frameCount = this._frames.length;
          if (this._end == -1 || this._end > this._frameCount - 1)
            this._end = this._frameCount - 1;
          if (this._endAt == -1 || this._endAt > this._frameCount - 1)
            this._endAt = this._frameCount - 1;
          if (this._frame < 0 || this._frame > this._frameCount - 1)
            this._frame = this._frameCount - 1;
          this.type = import_cc5.Sprite.Type.SIMPLE;
          this.drawFrame();
          this._frameElapsed = 0;
          this._repeatedCount = 0;
          this._reversed = false;
        } else {
          this._frameCount = 0;
        }
      }
      get frameCount() {
        return this._frameCount;
      }
      get frame() {
        return this._frame;
      }
      set frame(value) {
        if (this._frame != value) {
          if (this._frames && value >= this._frameCount)
            value = this._frameCount - 1;
          this._frame = value;
          this._frameElapsed = 0;
          this.drawFrame();
        }
      }
      get playing() {
        return this._playing;
      }
      set playing(value) {
        if (this._playing != value) {
          this._playing = value;
        }
      }
      get smoothing() {
        return this._smoothing;
      }
      set smoothing(value) {
        this._smoothing = value;
      }
      rewind() {
        this._frame = 0;
        this._frameElapsed = 0;
        this._reversed = false;
        this._repeatedCount = 0;
        this.drawFrame();
      }
      syncStatus(anotherMc) {
        this._frame = anotherMc._frame;
        this._frameElapsed = anotherMc._frameElapsed;
        this._reversed = anotherMc._reversed;
        this._repeatedCount = anotherMc._repeatedCount;
        this.drawFrame();
      }
      advance(timeInSeconds) {
        var beginFrame = this._frame;
        var beginReversed = this._reversed;
        var backupTime = timeInSeconds;
        while (true) {
          var tt = this.interval + this._frames[this._frame].addDelay;
          if (this._frame == 0 && this._repeatedCount > 0)
            tt += this.repeatDelay;
          if (timeInSeconds < tt) {
            this._frameElapsed = 0;
            break;
          }
          timeInSeconds -= tt;
          if (this.swing) {
            if (this._reversed) {
              this._frame--;
              if (this._frame <= 0) {
                this._frame = 0;
                this._repeatedCount++;
                this._reversed = !this._reversed;
              }
            } else {
              this._frame++;
              if (this._frame > this._frameCount - 1) {
                this._frame = Math.max(0, this._frameCount - 2);
                this._repeatedCount++;
                this._reversed = !this._reversed;
              }
            }
          } else {
            this._frame++;
            if (this._frame > this._frameCount - 1) {
              this._frame = 0;
              this._repeatedCount++;
            }
          }
          if (this._frame == beginFrame && this._reversed == beginReversed) {
            var roundTime = backupTime - timeInSeconds;
            timeInSeconds -= Math.floor(timeInSeconds / roundTime) * roundTime;
          }
        }
        this.drawFrame();
      }
      //从start帧开始，播放到end帧（-1表示结尾），重复times次（0表示无限循环），循环结束后，停止在endAt帧（-1表示参数end）
      setPlaySettings(start, end, times, endAt, endCallback) {
        if (start == void 0)
          start = 0;
        if (end == void 0)
          end = -1;
        if (times == void 0)
          times = 0;
        if (endAt == void 0)
          endAt = -1;
        this._start = start;
        this._end = end;
        if (this._end == -1 || this._end > this._frameCount - 1)
          this._end = this._frameCount - 1;
        this._times = times;
        this._endAt = endAt;
        if (this._endAt == -1)
          this._endAt = this._end;
        this._status = 0;
        this._callback = endCallback;
        this.frame = start;
      }
      update(dt) {
        if (!this._playing || this._frameCount == 0 || this._status == 3)
          return;
        if (this.timeScale != 1)
          dt *= this.timeScale;
        this._frameElapsed += dt;
        var tt = this.interval + this._frames[this._frame].addDelay;
        if (this._frame == 0 && this._repeatedCount > 0)
          tt += this.repeatDelay;
        if (this._frameElapsed < tt)
          return;
        this._frameElapsed -= tt;
        if (this._frameElapsed > this.interval)
          this._frameElapsed = this.interval;
        if (this.swing) {
          if (this._reversed) {
            this._frame--;
            if (this._frame <= 0) {
              this._frame = 0;
              this._repeatedCount++;
              this._reversed = !this._reversed;
            }
          } else {
            this._frame++;
            if (this._frame > this._frameCount - 1) {
              this._frame = Math.max(0, this._frameCount - 2);
              this._repeatedCount++;
              this._reversed = !this._reversed;
            }
          }
        } else {
          this._frame++;
          if (this._frame > this._frameCount - 1) {
            this._frame = 0;
            this._repeatedCount++;
          }
        }
        if (this._status == 1) {
          this._frame = this._start;
          this._frameElapsed = 0;
          this._status = 0;
        } else if (this._status == 2) {
          this._frame = this._endAt;
          this._frameElapsed = 0;
          this._status = 3;
          if (this._callback != null) {
            let callback = this._callback;
            this._callback = null;
            callback();
          }
        } else {
          if (this._frame == this._end) {
            if (this._times > 0) {
              this._times--;
              if (this._times == 0)
                this._status = 2;
              else
                this._status = 1;
            } else if (this._start != 0)
              this._status = 1;
          }
        }
        this.drawFrame();
      }
      drawFrame() {
        if (this._frameCount > 0 && this._frame < this._frames.length) {
          var frame = this._frames[this._frame];
          this.spriteFrame = frame.texture;
        }
      }
    };
    GMovieClip = class extends GObject {
      constructor() {
        super();
        this._node.name = "GMovieClip";
        this._touchDisabled = true;
        this._content = this._node.addComponent(MovieClip);
        this._content.sizeMode = import_cc5.Sprite.SizeMode.CUSTOM;
        this._content.trim = false;
        this._content.setPlaySettings();
      }
      get color() {
        return this._content.color;
      }
      set color(value) {
        this._content.color = value;
        this.updateGear(4);
      }
      get playing() {
        return this._content.playing;
      }
      set playing(value) {
        if (this._content.playing != value) {
          this._content.playing = value;
          this.updateGear(5);
        }
      }
      get frame() {
        return this._content.frame;
      }
      set frame(value) {
        if (this._content.frame != value) {
          this._content.frame = value;
          this.updateGear(5);
        }
      }
      get timeScale() {
        return this._content.timeScale;
      }
      set timeScale(value) {
        this._content.timeScale = value;
      }
      rewind() {
        this._content.rewind();
      }
      syncStatus(anotherMc) {
        this._content.syncStatus(anotherMc._content);
      }
      advance(timeInSeconds) {
        this._content.advance(timeInSeconds);
      }
      //从start帧开始，播放到end帧（-1表示结尾），重复times次（0表示无限循环），循环结束后，停止在endAt帧（-1表示参数end）
      setPlaySettings(start, end, times, endAt, endCallback) {
        this._content.setPlaySettings(start, end, times, endAt, endCallback);
      }
      handleGrayedChanged() {
        this._content.grayscale = this._grayed;
      }
      handleSizeChanged() {
        super.handleSizeChanged();
        this._content.sizeMode = import_cc5.Sprite.SizeMode.CUSTOM;
      }
      getProp(index) {
        switch (index) {
          case ObjectPropID.Color:
            return this.color;
          case ObjectPropID.Playing:
            return this.playing;
          case ObjectPropID.Frame:
            return this.frame;
          case ObjectPropID.TimeScale:
            return this.timeScale;
          default:
            return super.getProp(index);
        }
      }
      setProp(index, value) {
        switch (index) {
          case ObjectPropID.Color:
            this.color = value;
            break;
          case ObjectPropID.Playing:
            this.playing = value;
            break;
          case ObjectPropID.Frame:
            this.frame = value;
            break;
          case ObjectPropID.TimeScale:
            this.timeScale = value;
            break;
          case ObjectPropID.DeltaTime:
            this.advance(value);
            break;
          default:
            super.setProp(index, value);
            break;
        }
      }
      init(contentItem) {
        if (!(0, import_cc5.isValid)(this.node)) {
          return;
        }
        this._content.interval = contentItem.interval;
        this._content.swing = contentItem.swing;
        this._content.repeatDelay = contentItem.repeatDelay;
        this._content.frames = contentItem.frames;
        this._content.smoothing = contentItem.smoothing;
        this._contentPackageItem = contentItem;
        this._contentPackageItem.addRef();
      }
      constructFromResource() {
        var contentItem = this.packageItem.getBranch();
        this.sourceWidth = contentItem.width;
        this.sourceHeight = contentItem.height;
        this.initWidth = this.sourceWidth;
        this.initHeight = this.sourceHeight;
        this.setSize(this.sourceWidth, this.sourceHeight);
        contentItem = contentItem.getHighResolution();
        if (!UIConfig.enableDelayLoad || contentItem.__loaded && contentItem.decoded) {
          contentItem.load();
          this.init(contentItem);
        } else {
          contentItem.loadAsync().then(() => {
            this.init(contentItem);
          });
        }
      }
      onDestroy() {
        if (this._contentPackageItem) {
          this._contentPackageItem.decRef();
          this._contentPackageItem = null;
        }
        super.onDestroy();
      }
      setup_beforeAdd(buffer, beginPos) {
        super.setup_beforeAdd(buffer, beginPos);
        buffer.seek(beginPos, 5);
        if (buffer.readBool())
          this.color = buffer.readColor();
        buffer.readByte();
        this._content.frame = buffer.readInt();
        this._content.playing = buffer.readBool();
      }
    };
    UIContentScaler = class {
    };
    UIContentScaler.scaleFactor = 1;
    UIContentScaler.scaleLevel = 0;
    UIContentScaler.rootSize = new import_cc5.Size();
    RefMannager = class {
      static deleteItem(item) {
        this._deletes.push(item);
      }
      static update(dt) {
        if (this._deletes.length == 0) {
          return;
        }
        this._timer += dt;
        if (this._timer >= 5) {
          this._timer = 0;
          for (let i = this._deletes.length - 1; i >= 0; i--) {
            let item = this._deletes[i];
            if (item.ref <= 0) {
              this._deletes.splice(i, 1);
              item.doRelease();
            }
          }
        }
      }
    };
    RefMannager._timer = 0;
    RefMannager._deletes = [];
    PackageItem = class {
      get ref() {
        return this._ref;
      }
      constructor() {
        this.width = 0;
        this.height = 0;
        this.__loaded = false;
        this._ref = 0;
      }
      load() {
        return this.owner.getItemAsset(this);
      }
      loadAsync() {
        return this.owner.getItemAssetAsync2(this);
      }
      getBranch() {
        if (this.branches && this.owner._branchIndex != -1) {
          var itemId = this.branches[this.owner._branchIndex];
          if (itemId)
            return this.owner.getItemById(itemId);
        }
        return this;
      }
      getHighResolution() {
        if (this.highResolution && UIContentScaler.scaleLevel > 0) {
          var itemId = this.highResolution[UIContentScaler.scaleLevel - 1];
          if (itemId)
            return this.owner.getItemById(itemId);
        }
        return this;
      }
      toString() {
        return this.name;
      }
      addRef() {
        var _a, _b;
        this._ref++;
        (_a = this.parent) === null || _a === void 0 ? void 0 : _a.addRef();
        (_b = this.asset) === null || _b === void 0 ? void 0 : _b.addRef();
        switch (this.type) {
          case PackageItemType.MovieClip:
            if (this.frames) {
              for (var i = 0; i < this.frames.length; i++) {
                var frame = this.frames[i];
                if (frame.texture) {
                  frame.texture.addRef();
                }
                if (frame.altasPackageItem) {
                  frame.altasPackageItem.addRef();
                }
              }
            }
            break;
        }
      }
      doRelease() {
        switch (this.type) {
          case PackageItemType.MovieClip:
            if (this.frames) {
              for (var i = 0; i < this.frames.length; i++) {
                var frame = this.frames[i];
                if (frame.texture) {
                  frame.texture.decRef(true);
                  if (UIConfig.autoReleaseAssets) {
                    if (frame.texture.refCount == 0) {
                      import_cc5.assetManager.releaseAsset(frame.texture);
                    }
                  }
                }
                if (frame.altasPackageItem) {
                  frame.altasPackageItem.decRef();
                }
              }
            }
            break;
        }
        if (UIConfig.autoReleaseAssets) {
          if (this.asset && this.asset.refCount == 0) {
            import_cc5.assetManager.releaseAsset(this.asset);
          }
          if (this._ref == 0) {
            this.__loaded = false;
            this.decoded = false;
            this.frames = null;
            this.asset = null;
            this.parent = null;
          }
        }
      }
      decRef() {
        var _a, _b;
        if (this._ref > 0) {
          this._ref--;
        } else {
          return;
        }
        (_a = this.parent) === null || _a === void 0 ? void 0 : _a.decRef();
        (_b = this.asset) === null || _b === void 0 ? void 0 : _b.decRef(false);
        if (this._ref <= 0) {
          RefMannager.deleteItem(this);
        }
      }
      dispose(force = false) {
        if (this.asset) {
          if (force) {
            import_cc5.assetManager.releaseAsset(this.asset);
          } else {
            this.asset.decRef(true);
          }
          this.asset = null;
        }
      }
    };
    TranslationHelper = class _TranslationHelper {
      static loadFromXML(source) {
        _TranslationHelper.strings = {};
        let strings = _TranslationHelper.strings;
        var xml = new DOMParser().parseFromString(source, "text/xml").documentElement;
        var nodes = xml.childNodes;
        var length1 = nodes.length;
        for (var i1 = 0; i1 < length1; i1++) {
          var cxml = nodes[i1];
          if (cxml.tagName == "string") {
            var key = cxml.getAttribute("name");
            var text = cxml.childNodes.length > 0 ? cxml.firstChild.nodeValue : "";
            var i = key.indexOf("-");
            if (i == -1)
              continue;
            var key2 = key.substr(0, i);
            var key3 = key.substr(i + 1);
            var col = strings[key2];
            if (!col) {
              col = {};
              strings[key2] = col;
            }
            col[key3] = text;
          }
        }
      }
      static translateComponent(item) {
        if (_TranslationHelper.strings == null)
          return;
        var compStrings = _TranslationHelper.strings[item.owner.id + item.id];
        if (compStrings == null)
          return;
        var elementId, value;
        var buffer = item.rawData;
        var nextPos;
        var itemCount;
        var i, j, k;
        var dataLen;
        var curPos;
        var valueCnt;
        var page;
        buffer.seek(0, 2);
        var childCount = buffer.readShort();
        for (i = 0; i < childCount; i++) {
          dataLen = buffer.readShort();
          curPos = buffer.position;
          buffer.seek(curPos, 0);
          var baseType = buffer.readByte();
          var type = baseType;
          buffer.skip(4);
          elementId = buffer.readS();
          if (type == ObjectType.Component) {
            if (buffer.seek(curPos, 6))
              type = buffer.readByte();
          }
          buffer.seek(curPos, 1);
          if ((value = compStrings[elementId + "-tips"]) != null)
            buffer.writeS(value);
          buffer.seek(curPos, 2);
          var gearCnt = buffer.readShort();
          for (j = 0; j < gearCnt; j++) {
            nextPos = buffer.readShort();
            nextPos += buffer.position;
            if (buffer.readByte() == 6) {
              buffer.skip(2);
              valueCnt = buffer.readShort();
              for (k = 0; k < valueCnt; k++) {
                page = buffer.readS();
                if (page != null) {
                  if ((value = compStrings[elementId + "-texts_" + k]) != null)
                    buffer.writeS(value);
                  else
                    buffer.skip(2);
                }
              }
              if (buffer.readBool() && (value = compStrings[elementId + "-texts_def"]) != null)
                buffer.writeS(value);
            }
            buffer.position = nextPos;
          }
          if (baseType == ObjectType.Component && buffer.version >= 2) {
            buffer.seek(curPos, 4);
            buffer.skip(2);
            buffer.skip(4 * buffer.readShort());
            var cpCount = buffer.readShort();
            for (var k = 0; k < cpCount; k++) {
              var target = buffer.readS();
              var propertyId = buffer.readShort();
              if (propertyId == 0 && (value = compStrings[elementId + "-cp-" + target]) != null)
                buffer.writeS(value);
              else
                buffer.skip(2);
            }
          }
          switch (type) {
            case ObjectType.Text:
            case ObjectType.RichText:
            case ObjectType.InputText: {
              if ((value = compStrings[elementId]) != null) {
                buffer.seek(curPos, 6);
                buffer.writeS(value);
              }
              if ((value = compStrings[elementId + "-prompt"]) != null) {
                buffer.seek(curPos, 4);
                buffer.writeS(value);
              }
              break;
            }
            case ObjectType.List:
            case ObjectType.Tree: {
              buffer.seek(curPos, 8);
              buffer.skip(2);
              itemCount = buffer.readShort();
              for (j = 0; j < itemCount; j++) {
                nextPos = buffer.readShort();
                nextPos += buffer.position;
                buffer.skip(2);
                if (type == ObjectType.Tree)
                  buffer.skip(2);
                if ((value = compStrings[elementId + "-" + j]) != null)
                  buffer.writeS(value);
                else
                  buffer.skip(2);
                if ((value = compStrings[elementId + "-" + j + "-0"]) != null)
                  buffer.writeS(value);
                else
                  buffer.skip(2);
                if (buffer.version >= 2) {
                  buffer.skip(6);
                  buffer.skip(buffer.readUshort() * 4);
                  var cpCount = buffer.readUshort();
                  for (var k = 0; k < cpCount; k++) {
                    var target = buffer.readS();
                    var propertyId = buffer.readUshort();
                    if (propertyId == 0 && (value = compStrings[elementId + "-" + j + "-" + target]) != null)
                      buffer.writeS(value);
                    else
                      buffer.skip(2);
                  }
                }
                buffer.position = nextPos;
              }
              break;
            }
            case ObjectType.Label: {
              if (buffer.seek(curPos, 6) && buffer.readByte() == type) {
                if ((value = compStrings[elementId]) != null)
                  buffer.writeS(value);
                else
                  buffer.skip(2);
                buffer.skip(2);
                if (buffer.readBool())
                  buffer.skip(4);
                buffer.skip(4);
                if (buffer.readBool() && (value = compStrings[elementId + "-prompt"]) != null)
                  buffer.writeS(value);
              }
              break;
            }
            case ObjectType.Button: {
              if (buffer.seek(curPos, 6) && buffer.readByte() == type) {
                if ((value = compStrings[elementId]) != null)
                  buffer.writeS(value);
                else
                  buffer.skip(2);
                if ((value = compStrings[elementId + "-0"]) != null)
                  buffer.writeS(value);
              }
              break;
            }
            case ObjectType.ComboBox: {
              if (buffer.seek(curPos, 6) && buffer.readByte() == type) {
                itemCount = buffer.readShort();
                for (j = 0; j < itemCount; j++) {
                  nextPos = buffer.readShort();
                  nextPos += buffer.position;
                  if ((value = compStrings[elementId + "-" + j]) != null)
                    buffer.writeS(value);
                  buffer.position = nextPos;
                }
                if ((value = compStrings[elementId]) != null)
                  buffer.writeS(value);
              }
              break;
            }
          }
          buffer.position = curPos + dataLen;
        }
      }
    };
    ByteBuffer = class _ByteBuffer {
      constructor(buffer, offset, length) {
        this.version = 0;
        offset = offset || 0;
        if (length == null || length == -1)
          length = buffer.byteLength - offset;
        this._bytes = new Uint8Array(buffer, offset, length);
        this._view = new DataView(this._bytes.buffer, offset, length);
        this._pos = 0;
        this._length = length;
      }
      get data() {
        return this._bytes;
      }
      get position() {
        return this._pos;
      }
      set position(value) {
        if (value > this._length)
          throw "Out of bounds";
        this._pos = value;
      }
      skip(count) {
        this._pos += count;
      }
      validate(forward) {
        if (this._pos + forward > this._length)
          throw "Out of bounds";
      }
      readByte() {
        this.validate(1);
        return this._view.getUint8(this._pos++);
      }
      readBool() {
        return this.readByte() == 1;
      }
      readShort() {
        this.validate(2);
        let ret = this._view.getInt16(this._pos, this.littleEndian);
        this._pos += 2;
        return ret;
      }
      readUshort() {
        this.validate(2);
        let ret = this._view.getUint16(this._pos, this.littleEndian);
        this._pos += 2;
        return ret;
      }
      readInt() {
        this.validate(4);
        let ret = this._view.getInt32(this._pos, this.littleEndian);
        this._pos += 4;
        return ret;
      }
      readUint() {
        this.validate(4);
        let ret = this._view.getUint32(this._pos, this.littleEndian);
        this._pos += 4;
        return ret;
      }
      readFloat() {
        this.validate(4);
        let ret = this._view.getFloat32(this._pos, this.littleEndian);
        this._pos += 4;
        return ret;
      }
      readString(len) {
        if (len == void 0)
          len = this.readUshort();
        this.validate(len);
        let v = "", max = this._pos + len, c = 0, c2 = 0, c3 = 0, f = String.fromCharCode;
        let u = this._bytes;
        let pos = this._pos;
        while (pos < max) {
          c = u[pos++];
          if (c < 128) {
            if (c != 0) {
              v += f(c);
            }
          } else if (c < 224) {
            v += f((c & 63) << 6 | u[pos++] & 127);
          } else if (c < 240) {
            c2 = u[pos++];
            v += f((c & 31) << 12 | (c2 & 127) << 6 | u[pos++] & 127);
          } else {
            c2 = u[pos++];
            c3 = u[pos++];
            v += f((c & 15) << 18 | (c2 & 127) << 12 | c3 << 6 & 127 | u[pos++] & 127);
          }
        }
        this._pos += len;
        return v;
      }
      readS() {
        var index = this.readUshort();
        if (index == 65534)
          return null;
        else if (index == 65533)
          return "";
        else
          return this.stringTable[index];
      }
      readSArray(cnt) {
        var ret = new Array(cnt);
        for (var i = 0; i < cnt; i++)
          ret[i] = this.readS();
        return ret;
      }
      writeS(value) {
        var index = this.readUshort();
        if (index != 65534 && index != 65533)
          this.stringTable[index] = value;
      }
      readColor(hasAlpha) {
        var r = this.readByte();
        var g = this.readByte();
        var b = this.readByte();
        var a = this.readByte();
        return new import_cc5.Color(r, g, b, hasAlpha ? a : 255);
      }
      readChar() {
        var i = this.readUshort();
        return String.fromCharCode(i);
      }
      readBuffer() {
        var count = this.readUint();
        this.validate(count);
        var ba = new _ByteBuffer(this._bytes.buffer, this._bytes.byteOffset + this._pos, count);
        ba.stringTable = this.stringTable;
        ba.version = this.version;
        this._pos += count;
        return ba;
      }
      seek(indexTablePos, blockIndex) {
        var tmp = this._pos;
        this._pos = indexTablePos;
        var segCount = this.readByte();
        if (blockIndex < segCount) {
          var useShort = this.readByte() == 1;
          var newPos;
          if (useShort) {
            this._pos += 2 * blockIndex;
            newPos = this.readUshort();
          } else {
            this._pos += 4 * blockIndex;
            newPos = this.readUint();
          }
          if (newPos > 0) {
            this._pos = indexTablePos + newPos;
            return true;
          } else {
            this._pos = tmp;
            return false;
          }
        } else {
          this._pos = tmp;
          return false;
        }
      }
    };
    PixelHitTest = class {
      constructor(data, offsetX, offsetY) {
        this._data = data;
        this.offsetX = offsetX == void 0 ? 0 : offsetX;
        this.offsetY = offsetY == void 0 ? 0 : offsetY;
        this.scaleX = 1;
        this.scaleY = 1;
      }
      hitTest(pt) {
        let x = Math.floor((pt.x / this.scaleX - this.offsetX) * this._data.scale);
        let y = Math.floor((pt.y / this.scaleY - this.offsetY) * this._data.scale);
        if (x < 0 || y < 0 || x >= this._data.pixelWidth)
          return false;
        var pos = y * this._data.pixelWidth + x;
        var pos2 = Math.floor(pos / 8);
        var pos3 = pos % 8;
        if (pos2 >= 0 && pos2 < this._data.pixels.length)
          return (this._data.pixels[pos2] >> pos3 & 1) == 1;
        else
          return false;
      }
    };
    PixelHitTestData = class {
      constructor(ba) {
        ba.readInt();
        this.pixelWidth = ba.readInt();
        this.scale = 1 / ba.readByte();
        this.pixels = ba.readBuffer().data;
      }
    };
    ChildHitArea = class {
      constructor(child) {
        this._child = child;
      }
      hitTest(pt, globalPt) {
        return this._child.hitTest(globalPt, false) != null;
      }
    };
    __awaiter$1 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    PathUtils = import_cc5.path;
    UIPackage = class _UIPackage {
      constructor() {
        this._items = [];
        this._itemsById = {};
        this._itemsByName = {};
        this._sprites = {};
        this._dependencies = [];
        this._branches = [];
        this._branchIndex = -1;
      }
      static get branch() {
        return _branch;
      }
      static set branch(value) {
        _branch = value;
        for (var pkgId in _instById) {
          var pkg = _instById[pkgId];
          if (pkg._branches) {
            pkg._branchIndex = pkg._branches.indexOf(value);
          }
        }
      }
      static getVar(key) {
        return _vars[key];
      }
      static setVar(key, value) {
        _vars[key] = value;
      }
      static getById(id) {
        return _instById[id];
      }
      static getByName(name) {
        return _instByName[name];
      }
      /**
       * 注册一个包。包的所有资源必须放在resources下，且已经预加载。
       * @param path 相对 resources 的路径。
       */
      static addPackage(path4) {
        let pkg = _instById[path4];
        if (pkg)
          return pkg;
        let asset = import_cc5.resources.get(path4, import_cc5.BufferAsset);
        if (!asset)
          throw "Resource '" + path4 + "' not ready";
        const buffer = asset.buffer();
        if (!buffer)
          throw "Missing asset data.";
        pkg = new _UIPackage();
        pkg._bundle = import_cc5.resources;
        pkg.loadPackage(new ByteBuffer(buffer), path4);
        import_cc5.assetManager.releaseAsset(asset);
        _instById[pkg.id] = pkg;
        _instByName[pkg.name] = pkg;
        _instById[pkg._path] = pkg;
        return pkg;
      }
      static loadPackage(...args) {
        let path4;
        let onProgress;
        let onComplete;
        let bundle;
        let delayLoad = UIConfig.enableDelayLoad;
        if (args[0] instanceof import_cc5.AssetManager.Bundle) {
          bundle = args[0];
          path4 = args[1];
          if (args.length > 4) {
            onProgress = args[2];
            onComplete = args[3];
            delayLoad = args[4];
          } else if (args.length > 3) {
            onProgress = args[2];
            onComplete = args[3];
          } else
            onComplete = args[2];
        } else {
          path4 = args[0];
          if (args.length > 3) {
            onProgress = args[1];
            onComplete = args[2];
            delayLoad = args[3];
          } else if (args.length > 2) {
            onProgress = args[1];
            onComplete = args[2];
          } else
            onComplete = args[1];
        }
        let p = _instById[path4];
        if (p) {
          onComplete === null || onComplete === void 0 ? void 0 : onComplete.call(this, null, p);
          return;
        }
        bundle = bundle || import_cc5.resources;
        bundle.load(path4, import_cc5.Asset, onProgress, (err, asset) => {
          if (err) {
            if (onComplete != null)
              onComplete(err, null);
            return;
          }
          let pkg = new _UIPackage();
          pkg._bundle = bundle;
          let buffer = asset.buffer ? asset.buffer() : asset._nativeAsset;
          pkg.loadPackage(new ByteBuffer(buffer), path4);
          import_cc5.assetManager.releaseAsset(asset);
          let cnt = pkg._items.length;
          let urls = [];
          for (var i = 0; i < cnt; i++) {
            var pi = pkg._items[i];
            if (pi.type == PackageItemType.Atlas && !delayLoad || pi.type == PackageItemType.Sound) {
              ItemTypeToAssetType[pi.type];
              urls.push(pi.file);
            }
          }
          let total = urls.length;
          let lastErr;
          let taskComplete = (err2, asset2) => {
            total--;
            if (err2)
              lastErr = err2;
            if (total <= 0) {
              _instById[pkg.id] = pkg;
              _instByName[pkg.name] = pkg;
              if (pkg._path)
                _instById[pkg._path] = pkg;
              if (onComplete != null)
                onComplete(lastErr, pkg);
            }
          };
          if (total > 0) {
            urls.forEach((url, index) => {
              bundle.load(url, import_cc5.Asset, onProgress, taskComplete);
            });
          } else
            taskComplete(null);
        });
      }
      static removePackage(packageIdOrName, disposeAll = false) {
        var pkg = _instById[packageIdOrName];
        if (!pkg)
          pkg = _instByName[packageIdOrName];
        if (!pkg)
          throw "No package found: " + packageIdOrName;
        pkg.dispose(disposeAll);
        delete _instById[pkg.id];
        delete _instByName[pkg.name];
        if (pkg._path)
          delete _instById[pkg._path];
      }
      static createObject(pkgName, resName, userClass) {
        var pkg = _UIPackage.getByName(pkgName);
        if (pkg)
          return pkg.createObject(resName, userClass);
        else
          return null;
      }
      static createObjectFromURL(url, userClass) {
        var pi = _UIPackage.getItemByURL(url);
        if (pi)
          return pi.owner.internalCreateObject(pi, userClass);
        else
          return null;
      }
      static getItemURL(pkgName, resName) {
        var pkg = _UIPackage.getByName(pkgName);
        if (!pkg)
          return null;
        var pi = pkg._itemsByName[resName];
        if (!pi)
          return null;
        return "ui://" + pkg.id + pi.id;
      }
      static getItemByURL(url) {
        var pos1 = url.indexOf("//");
        if (pos1 == -1)
          return null;
        var pos2 = url.indexOf("/", pos1 + 2);
        if (pos2 == -1) {
          if (url.length > 13) {
            var pkgId = url.substr(5, 8);
            var pkg = _UIPackage.getById(pkgId);
            if (pkg != null) {
              var srcId = url.substr(13);
              return pkg.getItemById(srcId);
            }
          }
        } else {
          var pkgName = url.substr(pos1 + 2, pos2 - pos1 - 2);
          pkg = _UIPackage.getByName(pkgName);
          if (pkg != null) {
            var srcName = url.substr(pos2 + 1);
            return pkg.getItemByName(srcName);
          }
        }
        return null;
      }
      static normalizeURL(url) {
        if (url == null)
          return null;
        var pos1 = url.indexOf("//");
        if (pos1 == -1)
          return null;
        var pos2 = url.indexOf("/", pos1 + 2);
        if (pos2 == -1)
          return url;
        var pkgName = url.substr(pos1 + 2, pos2 - pos1 - 2);
        var srcName = url.substr(pos2 + 1);
        return _UIPackage.getItemURL(pkgName, srcName);
      }
      static setStringsSource(source) {
        TranslationHelper.loadFromXML(source);
      }
      loadPackage(buffer, path4) {
        if (buffer.readUint() != 1179080009)
          throw "FairyGUI: old package format found in '" + path4 + "'";
        this._path = path4;
        buffer.version = buffer.readInt();
        var ver2 = buffer.version >= 2;
        buffer.readBool();
        this._id = buffer.readString();
        this._name = buffer.readString();
        buffer.skip(20);
        var indexTablePos = buffer.position;
        var cnt;
        var i;
        var nextPos;
        var str;
        var branchIncluded;
        buffer.seek(indexTablePos, 4);
        cnt = buffer.readInt();
        var stringTable = new Array(cnt);
        buffer.stringTable = stringTable;
        for (i = 0; i < cnt; i++)
          stringTable[i] = buffer.readString();
        if (buffer.seek(indexTablePos, 5)) {
          cnt = buffer.readInt();
          for (i = 0; i < cnt; i++) {
            let index = buffer.readUshort();
            let len = buffer.readInt();
            stringTable[index] = buffer.readString(len);
          }
        }
        buffer.seek(indexTablePos, 0);
        cnt = buffer.readShort();
        for (i = 0; i < cnt; i++)
          this._dependencies.push({ id: buffer.readS(), name: buffer.readS() });
        if (ver2) {
          cnt = buffer.readShort();
          if (cnt > 0) {
            this._branches = buffer.readSArray(cnt);
            if (_branch)
              this._branchIndex = this._branches.indexOf(_branch);
          }
          branchIncluded = cnt > 0;
        }
        buffer.seek(indexTablePos, 1);
        var pi;
        let pos = path4.lastIndexOf("/");
        let shortPath = pos == -1 ? "" : path4.substr(0, pos + 1);
        path4 = path4 + "_";
        cnt = buffer.readShort();
        for (i = 0; i < cnt; i++) {
          nextPos = buffer.readInt();
          nextPos += buffer.position;
          pi = new PackageItem();
          pi.owner = this;
          pi.type = buffer.readByte();
          pi.id = buffer.readS();
          pi.name = buffer.readS();
          buffer.readS();
          pi.file = buffer.readS();
          buffer.readBool();
          pi.width = buffer.readInt();
          pi.height = buffer.readInt();
          switch (pi.type) {
            case PackageItemType.Image: {
              pi.objectType = ObjectType.Image;
              var scaleOption = buffer.readByte();
              if (scaleOption == 1) {
                pi.scale9Grid = new import_cc5.Rect();
                pi.scale9Grid.x = buffer.readInt();
                pi.scale9Grid.y = buffer.readInt();
                pi.scale9Grid.width = buffer.readInt();
                pi.scale9Grid.height = buffer.readInt();
                pi.tileGridIndice = buffer.readInt();
              } else if (scaleOption == 2)
                pi.scaleByTile = true;
              pi.smoothing = buffer.readBool();
              break;
            }
            case PackageItemType.MovieClip: {
              pi.smoothing = buffer.readBool();
              pi.objectType = ObjectType.MovieClip;
              pi.rawData = buffer.readBuffer();
              break;
            }
            case PackageItemType.Font: {
              pi.rawData = buffer.readBuffer();
              break;
            }
            case PackageItemType.Component: {
              var extension = buffer.readByte();
              if (extension > 0)
                pi.objectType = extension;
              else
                pi.objectType = ObjectType.Component;
              pi.rawData = buffer.readBuffer();
              Decls.UIObjectFactory.resolveExtension(pi);
              break;
            }
            case PackageItemType.Atlas:
            case PackageItemType.Sound:
            case PackageItemType.Misc: {
              pi.file = path4 + PathUtils.mainFileName(pi.file);
              break;
            }
            case PackageItemType.Spine:
            case PackageItemType.DragonBones: {
              pi.file = shortPath + PathUtils.mainFileName(pi.file);
              pi.skeletonAnchor = new import_cc5.Vec2();
              pi.skeletonAnchor.x = buffer.readFloat();
              pi.skeletonAnchor.y = buffer.readFloat();
              break;
            }
          }
          if (ver2) {
            str = buffer.readS();
            if (str)
              pi.name = str + "/" + pi.name;
            var branchCnt = buffer.readByte();
            if (branchCnt > 0) {
              if (branchIncluded)
                pi.branches = buffer.readSArray(branchCnt);
              else
                this._itemsById[buffer.readS()] = pi;
            }
            var highResCnt = buffer.readByte();
            if (highResCnt > 0)
              pi.highResolution = buffer.readSArray(highResCnt);
          }
          this._items.push(pi);
          this._itemsById[pi.id] = pi;
          if (pi.name != null)
            this._itemsByName[pi.name] = pi;
          buffer.position = nextPos;
        }
        buffer.seek(indexTablePos, 2);
        cnt = buffer.readShort();
        for (i = 0; i < cnt; i++) {
          nextPos = buffer.readShort();
          nextPos += buffer.position;
          var itemId = buffer.readS();
          pi = this._itemsById[buffer.readS()];
          let rect = new import_cc5.Rect();
          rect.x = buffer.readInt();
          rect.y = buffer.readInt();
          rect.width = buffer.readInt();
          rect.height = buffer.readInt();
          var sprite = { atlas: pi, rect, offset: new import_cc5.Vec2(), originalSize: new import_cc5.Size(0, 0) };
          sprite.rotated = buffer.readBool();
          if (ver2 && buffer.readBool()) {
            sprite.offset.x = buffer.readInt();
            sprite.offset.y = buffer.readInt();
            sprite.originalSize.width = buffer.readInt();
            sprite.originalSize.height = buffer.readInt();
          } else {
            sprite.originalSize.width = sprite.rect.width;
            sprite.originalSize.height = sprite.rect.height;
          }
          this._sprites[itemId] = sprite;
          buffer.position = nextPos;
        }
        if (buffer.seek(indexTablePos, 3)) {
          cnt = buffer.readShort();
          for (i = 0; i < cnt; i++) {
            nextPos = buffer.readInt();
            nextPos += buffer.position;
            pi = this._itemsById[buffer.readS()];
            if (pi && pi.type == PackageItemType.Image)
              pi.hitTestData = new PixelHitTestData(buffer);
            buffer.position = nextPos;
          }
        }
      }
      dispose(force = false) {
        var cnt = this._items.length;
        for (var i = 0; i < cnt; i++) {
          var pi = this._items[i];
          pi.dispose(force);
        }
      }
      get id() {
        return this._id;
      }
      get name() {
        return this._name;
      }
      get path() {
        return this._path;
      }
      get dependencies() {
        return this._dependencies;
      }
      createObject(resName, userClass) {
        var pi = this._itemsByName[resName];
        if (pi)
          return this.internalCreateObject(pi, userClass);
        else
          return null;
      }
      internalCreateObject(item, userClass) {
        var g = Decls.UIObjectFactory.newObject(item, userClass);
        if (g == null)
          return null;
        constructingDepth.n++;
        g.constructFromResource();
        constructingDepth.n--;
        return g;
      }
      getItemById(itemId) {
        return this._itemsById[itemId];
      }
      getItemByName(resName) {
        return this._itemsByName[resName];
      }
      getItemAssetByName(resName) {
        var pi = this._itemsByName[resName];
        if (pi == null) {
          throw "Resource not found -" + resName;
        }
        return this.getItemAsset(pi);
      }
      getItemAsset(item) {
        switch (item.type) {
          case PackageItemType.Image:
            if (!item.decoded) {
              item.decoded = true;
              var sprite = this._sprites[item.id];
              if (sprite) {
                item.parent = sprite.atlas;
                let atlasTexture = this.getItemAsset(sprite.atlas);
                if (atlasTexture) {
                  let sf = new import_cc5.SpriteFrame();
                  sf.texture = atlasTexture;
                  sf.rect = sprite.rect;
                  sf.rotated = sprite.rotated;
                  sf.offset = new import_cc5.Vec2(sprite.offset.x - (sprite.originalSize.width - sprite.rect.width) / 2, -(sprite.offset.y - (sprite.originalSize.height - sprite.rect.height) / 2));
                  sf.originalSize = sprite.originalSize;
                  if (item.scale9Grid) {
                    sf.insetLeft = item.scale9Grid.x;
                    sf.insetTop = item.scale9Grid.y;
                    sf.insetRight = item.width - item.scale9Grid.xMax;
                    sf.insetBottom = item.height - item.scale9Grid.yMax;
                  }
                  item.asset = sf;
                }
              }
              if (!UIConfig.autoReleaseAssets) {
                item.addRef();
              }
            }
            break;
          case PackageItemType.Atlas:
          case PackageItemType.Sound:
            if (!item.decoded) {
              item.decoded = true;
              item.asset = this._bundle.get(item.file, ItemTypeToAssetType[item.type]);
              if (!item.asset)
                console.log("Resource '" + item.file + "' not found");
              else if (item.type == PackageItemType.Atlas) {
                const asset = item.asset;
                let tex = asset["_texture"];
                if (!tex) {
                  tex = new import_cc5.Texture2D();
                  tex.name = asset.nativeUrl;
                  tex.image = asset;
                }
                item.asset = tex;
              } else {
                item.asset = item.asset;
              }
              if (!UIConfig.autoReleaseAssets || item.type == PackageItemType.Sound) {
                item.addRef();
              }
            }
            break;
          case PackageItemType.Font:
            if (!item.decoded) {
              item.decoded = true;
              this.loadFont(item);
              item.addRef();
            }
            break;
          case PackageItemType.MovieClip:
            if (!item.decoded) {
              item.decoded = true;
              this.loadMovieClip(item);
              if (!UIConfig.autoReleaseAssets) {
                item.addRef();
              }
            }
            break;
        }
        return item.asset;
      }
      loadAssetAsync(bundle, path4, type) {
        return __awaiter$1(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            bundle.load(path4, type, null, (err, asset) => {
              if (err) {
                reject(err);
                return;
              }
              resolve(asset);
            });
          });
        });
      }
      getItemAssetAsync2(item) {
        return __awaiter$1(this, void 0, void 0, function* () {
          if (item.__loaded) {
            return item.asset;
          }
          switch (item.type) {
            case PackageItemType.Image:
              if (!item.decoded) {
                item.decoded = true;
                var sprite = this._sprites[item.id];
                if (sprite) {
                  item.parent = sprite.atlas;
                  let atlasTexture = yield this.getItemAssetAsync2(sprite.atlas);
                  if (atlasTexture) {
                    let sf = new import_cc5.SpriteFrame();
                    sf.texture = atlasTexture;
                    sf.rect = sprite.rect;
                    sf.rotated = sprite.rotated;
                    sf.offset = new import_cc5.Vec2(sprite.offset.x - (sprite.originalSize.width - sprite.rect.width) / 2, -(sprite.offset.y - (sprite.originalSize.height - sprite.rect.height) / 2));
                    sf.originalSize = sprite.originalSize;
                    if (item.scale9Grid) {
                      sf.insetLeft = item.scale9Grid.x;
                      sf.insetTop = item.scale9Grid.y;
                      sf.insetRight = item.width - item.scale9Grid.xMax;
                      sf.insetBottom = item.height - item.scale9Grid.yMax;
                    }
                    item.asset = sf;
                  }
                }
                item.__loaded = true;
                if (!UIConfig.autoReleaseAssets) {
                  item.addRef();
                }
              }
              break;
            case PackageItemType.Atlas:
            case PackageItemType.Sound:
              if (!item.decoded) {
                item.decoded = true;
                item.asset = yield this.loadAssetAsync(this._bundle, item.file, ItemTypeToAssetType[item.type]);
                if (!item.asset)
                  console.log("Resource '" + item.file + "' not found");
                else if (item.type == PackageItemType.Atlas) {
                  const asset = item.asset;
                  let tex = asset["_texture"];
                  if (!tex) {
                    tex = new import_cc5.Texture2D();
                    tex.name = asset.nativeUrl;
                    tex.image = asset;
                  }
                  item.asset = tex;
                } else {
                  item.asset = item.asset;
                }
                if (!UIConfig.autoReleaseAssets || item.type == PackageItemType.Sound) {
                  item.addRef();
                }
                item.__loaded = true;
              }
              break;
            case PackageItemType.Font:
              if (!item.decoded) {
                item.decoded = true;
                yield this.loadFontAsync(item);
                if (!UIConfig.autoReleaseAssets) {
                  item.addRef();
                }
                item.__loaded = true;
              }
              break;
            case PackageItemType.MovieClip:
              if (!item.decoded) {
                item.decoded = true;
                yield this.loadMovieClipAsync(item);
                item.__loaded = true;
                if (!UIConfig.autoReleaseAssets) {
                  item.addRef();
                }
              }
              break;
          }
          let check = (done) => {
            if (!item.__loaded) {
              setTimeout(() => {
                check(done);
              }, 10, this);
            } else {
              done(true);
            }
          };
          yield new Promise((resolve, reject) => {
            check(resolve);
          });
          return item.asset;
        });
      }
      getItemAssetAsync(item, onComplete) {
        if (item.decoded) {
          onComplete(null, item);
          return;
        }
        if (item.loading) {
          item.loading.push(onComplete);
          return;
        }
        switch (item.type) {
          case PackageItemType.Spine:
            item.loading = [onComplete];
            this.loadSpine(item);
            break;
          case PackageItemType.DragonBones:
            item.loading = [onComplete];
            this.loadDragonBones(item);
            break;
          default:
            this.getItemAsset(item);
            onComplete(null, item);
            break;
        }
      }
      loadAllAssets() {
        var cnt = this._items.length;
        for (var i = 0; i < cnt; i++) {
          var pi = this._items[i];
          this.getItemAsset(pi);
        }
      }
      loadMovieClipAsync(item) {
        return __awaiter$1(this, void 0, void 0, function* () {
          var buffer = item.rawData;
          buffer.seek(0, 0);
          item.interval = buffer.readInt() / 1e3;
          item.swing = buffer.readBool();
          item.repeatDelay = buffer.readInt() / 1e3;
          buffer.seek(0, 1);
          var frameCount = buffer.readShort();
          item.frames = [];
          var spriteId;
          var sprite;
          for (var i = 0; i < frameCount; i++) {
            var nextPos = buffer.readShort();
            nextPos += buffer.position;
            let rect = new import_cc5.Rect();
            rect.x = buffer.readInt();
            rect.y = buffer.readInt();
            rect.width = buffer.readInt();
            rect.height = buffer.readInt();
            let addDelay = buffer.readInt() / 1e3;
            let frame = { rect, addDelay, texture: null, altasPackageItem: null };
            spriteId = buffer.readS();
            if (spriteId != null && (sprite = this._sprites[spriteId]) != null) {
              let atlasTexture = null;
              atlasTexture = yield this.getItemAssetAsync2(sprite.atlas);
              frame.altasPackageItem = sprite.atlas;
              if (atlasTexture) {
                item.width / frame.rect.width;
                let sf = new import_cc5.SpriteFrame();
                sf.texture = atlasTexture;
                sf.rect = sprite.rect;
                sf.rotated = sprite.rotated;
                sf.offset = new import_cc5.Vec2(frame.rect.x - (item.width - frame.rect.width) / 2, -(frame.rect.y - (item.height - frame.rect.height) / 2));
                sf.originalSize = new import_cc5.Size(item.width, item.height);
                frame.texture = sf;
              }
            }
            item.frames.push(frame);
            buffer.position = nextPos;
          }
        });
      }
      loadMovieClip(item) {
        var buffer = item.rawData;
        buffer.seek(0, 0);
        item.interval = buffer.readInt() / 1e3;
        item.swing = buffer.readBool();
        item.repeatDelay = buffer.readInt() / 1e3;
        buffer.seek(0, 1);
        var frameCount = buffer.readShort();
        item.frames = Array(frameCount);
        var spriteId;
        var sprite;
        for (var i = 0; i < frameCount; i++) {
          var nextPos = buffer.readShort();
          nextPos += buffer.position;
          let rect = new import_cc5.Rect();
          rect.x = buffer.readInt();
          rect.y = buffer.readInt();
          rect.width = buffer.readInt();
          rect.height = buffer.readInt();
          let addDelay = buffer.readInt() / 1e3;
          let frame = { rect, addDelay, texture: null, altasPackageItem: null };
          spriteId = buffer.readS();
          if (spriteId != null && (sprite = this._sprites[spriteId]) != null) {
            let atlasTexture = this.getItemAsset(sprite.atlas);
            frame.altasPackageItem = sprite.atlas;
            if (atlasTexture) {
              item.width / frame.rect.width;
              let sf = new import_cc5.SpriteFrame();
              sf.texture = atlasTexture;
              sf.rect = sprite.rect;
              sf.rotated = sprite.rotated;
              sf.offset = new import_cc5.Vec2(frame.rect.x - (item.width - frame.rect.width) / 2, -(frame.rect.y - (item.height - frame.rect.height) / 2));
              sf.originalSize = new import_cc5.Size(item.width, item.height);
              frame.texture = sf;
            }
          }
          item.frames[i] = frame;
          buffer.position = nextPos;
        }
      }
      loadFont(item) {
        var font = new import_cc5.BitmapFont();
        item.asset = font;
        font.fntConfig = {
          commonHeight: 0,
          fontSize: 0,
          kerningDict: {},
          fontDefDictionary: {}
        };
        let dict = font.fntConfig.fontDefDictionary;
        var buffer = item.rawData;
        buffer.seek(0, 0);
        let ttf = buffer.readBool();
        let canTint = buffer.readBool();
        let resizable = buffer.readBool();
        buffer.readBool();
        let fontSize = buffer.readInt();
        var xadvance = buffer.readInt();
        var lineHeight = buffer.readInt();
        let mainTexture;
        var mainSprite = this._sprites[item.id];
        if (mainSprite)
          mainTexture = this.getItemAsset(mainSprite.atlas);
        buffer.seek(0, 1);
        var bg;
        var cnt = buffer.readInt();
        for (var i = 0; i < cnt; i++) {
          var nextPos = buffer.readShort();
          nextPos += buffer.position;
          bg = {};
          var ch = buffer.readUshort();
          dict[ch] = bg;
          let rect = new import_cc5.Rect();
          bg.rect = rect;
          var img = buffer.readS();
          rect.x = buffer.readInt();
          rect.y = buffer.readInt();
          bg.xOffset = buffer.readInt();
          bg.yOffset = buffer.readInt();
          rect.width = buffer.readInt();
          rect.height = buffer.readInt();
          bg.xAdvance = buffer.readInt();
          bg.channel = buffer.readByte();
          if (bg.channel == 1)
            bg.channel = 3;
          else if (bg.channel == 2)
            bg.channel = 2;
          else if (bg.channel == 3)
            bg.channel = 1;
          if (ttf) {
            rect.x += mainSprite.rect.x;
            rect.y += mainSprite.rect.y;
          } else {
            let sprite = this._sprites[img];
            if (sprite) {
              if (!mainSprite) {
                mainSprite = sprite;
              }
              rect.set(sprite.rect);
              bg.xOffset += sprite.offset.x;
              bg.yOffset += sprite.offset.y;
              if (fontSize == 0)
                fontSize = sprite.originalSize.height;
            }
            if (bg.xAdvance == 0) {
              if (xadvance == 0)
                bg.xAdvance = bg.xOffset + bg.rect.width;
              else
                bg.xAdvance = xadvance;
            }
          }
          buffer.position = nextPos;
        }
        font.fontSize = fontSize;
        font.fntConfig.fontSize = fontSize;
        font.fntConfig.commonHeight = lineHeight == 0 ? fontSize : lineHeight;
        font.fntConfig.resizable = resizable;
        font.fntConfig.canTint = canTint;
        if (!mainTexture && mainSprite) {
          mainSprite.atlas.load();
          mainTexture = mainSprite.atlas.asset;
        }
        let spriteFrame = new import_cc5.SpriteFrame();
        spriteFrame.texture = mainTexture;
        font.spriteFrame = spriteFrame;
        font.onLoaded();
      }
      loadFontAsync(item) {
        return __awaiter$1(this, void 0, void 0, function* () {
          var font = new import_cc5.BitmapFont();
          item.asset = font;
          font.fntConfig = {
            commonHeight: 0,
            fontSize: 0,
            kerningDict: {},
            fontDefDictionary: {}
          };
          let dict = font.fntConfig.fontDefDictionary;
          var buffer = item.rawData;
          buffer.seek(0, 0);
          let ttf = buffer.readBool();
          let canTint = buffer.readBool();
          let resizable = buffer.readBool();
          buffer.readBool();
          let fontSize = buffer.readInt();
          var xadvance = buffer.readInt();
          var lineHeight = buffer.readInt();
          let mainTexture;
          var mainSprite = this._sprites[item.id];
          if (mainSprite)
            mainTexture = this.getItemAsset(mainSprite.atlas);
          buffer.seek(0, 1);
          var bg;
          var cnt = buffer.readInt();
          for (var i = 0; i < cnt; i++) {
            var nextPos = buffer.readShort();
            nextPos += buffer.position;
            bg = {};
            var ch = buffer.readUshort();
            dict[ch] = bg;
            let rect = new import_cc5.Rect();
            bg.rect = rect;
            var img = buffer.readS();
            rect.x = buffer.readInt();
            rect.y = buffer.readInt();
            bg.xOffset = buffer.readInt();
            bg.yOffset = buffer.readInt();
            rect.width = buffer.readInt();
            rect.height = buffer.readInt();
            bg.xAdvance = buffer.readInt();
            bg.channel = buffer.readByte();
            if (bg.channel == 1)
              bg.channel = 3;
            else if (bg.channel == 2)
              bg.channel = 2;
            else if (bg.channel == 3)
              bg.channel = 1;
            if (ttf) {
              rect.x += mainSprite.rect.x;
              rect.y += mainSprite.rect.y;
            } else {
              let sprite = this._sprites[img];
              if (sprite) {
                if (!mainSprite) {
                  mainSprite = sprite;
                }
                rect.set(sprite.rect);
                bg.xOffset += sprite.offset.x;
                bg.yOffset += sprite.offset.y;
                if (fontSize == 0)
                  fontSize = sprite.originalSize.height;
              }
              if (bg.xAdvance == 0) {
                if (xadvance == 0)
                  bg.xAdvance = bg.xOffset + bg.rect.width;
                else
                  bg.xAdvance = xadvance;
              }
            }
            buffer.position = nextPos;
          }
          font.fontSize = fontSize;
          font.fntConfig.fontSize = fontSize;
          font.fntConfig.commonHeight = lineHeight == 0 ? fontSize : lineHeight;
          font.fntConfig.resizable = resizable;
          font.fntConfig.canTint = canTint;
          if (mainSprite) {
            if (!mainTexture) {
              yield mainSprite.atlas.loadAsync();
              mainTexture = mainSprite.atlas.asset;
            }
            item.parent = mainSprite.atlas;
          }
          let spriteFrame = new import_cc5.SpriteFrame();
          spriteFrame.texture = mainTexture;
          font.spriteFrame = spriteFrame;
          font.onLoaded();
        });
      }
      loadSpine(item) {
        this._bundle.load(item.file, import_cc5.sp.SkeletonData, (err, asset) => {
          item.decoded = true;
          item.asset = asset;
          let arr = item.loading;
          delete item.loading;
          arr.forEach((e) => e(err, item));
        });
      }
      loadDragonBones(item) {
        this._bundle.load(item.file, import_cc5.dragonBones.DragonBonesAsset, (err, asset) => {
          if (err) {
            item.decoded = true;
            let arr = item.loading;
            delete item.loading;
            arr.forEach((e) => e(err, item));
            return;
          }
          item.asset = asset;
          let atlasFile = item.file.replace("_ske", "_tex");
          let pos = atlasFile.lastIndexOf(".");
          if (pos != -1)
            atlasFile = atlasFile.substr(0, pos + 1) + "json";
          this._bundle.load(atlasFile, import_cc5.dragonBones.DragonBonesAtlasAsset, (err2, asset2) => {
            item.decoded = true;
            item.atlasAsset = asset2;
            let arr = item.loading;
            delete item.loading;
            arr.forEach((e) => e(err2, item));
          });
        });
      }
    };
    ItemTypeToAssetType = {
      [PackageItemType.Atlas]: import_cc5.ImageAsset,
      [PackageItemType.Sound]: import_cc5.AudioClip
    };
    _instById = {};
    _instByName = {};
    _branch = "";
    _vars = {};
    Decls = {};
    UBBParser = class {
      constructor() {
        this._readPos = 0;
        this._handlers = {};
        this._handlers["url"] = this.onTag_URL;
        this._handlers["img"] = this.onTag_IMG;
        this._handlers["b"] = this.onTag_Simple;
        this._handlers["i"] = this.onTag_Simple;
        this._handlers["u"] = this.onTag_Simple;
        this._handlers["color"] = this.onTag_COLOR;
        this._handlers["size"] = this.onTag_SIZE;
      }
      onTag_URL(tagName, end, attr) {
        if (!end) {
          let ret;
          if (attr != null)
            ret = '<on click="onClickLink" param="' + attr + '">';
          else {
            var href = this.getTagText();
            ret = '<on click="onClickLink" param="' + href + '">';
          }
          if (this.linkUnderline)
            ret += "<u>";
          if (this.linkColor)
            ret += "<color=" + this.linkColor + ">";
          return ret;
        } else {
          let ret = "";
          if (this.linkColor)
            ret += "</color>";
          if (this.linkUnderline)
            ret += "</u>";
          ret += "</on>";
          return ret;
        }
      }
      onTag_IMG(tagName, end, attr) {
        if (!end) {
          var src = this.getTagText(true);
          if (!src)
            return null;
          return '<img src="' + src + '"/>';
        } else
          return null;
      }
      onTag_Simple(tagName, end, attr) {
        return end ? "</" + tagName + ">" : "<" + tagName + ">";
      }
      onTag_COLOR(tagName, end, attr) {
        if (!end) {
          this.lastColor = attr;
          return "<color=" + attr + ">";
        } else
          return "</color>";
      }
      onTag_FONT(tagName, end, attr) {
        if (!end)
          return '<font face="' + attr + '">';
        else
          return "</font>";
      }
      onTag_SIZE(tagName, end, attr) {
        if (!end) {
          this.lastSize = attr;
          return "<size=" + attr + ">";
        } else
          return "</size>";
      }
      getTagText(remove) {
        var pos1 = this._readPos;
        var pos2;
        var result = "";
        while ((pos2 = this._text.indexOf("[", pos1)) != -1) {
          if (this._text.charCodeAt(pos2 - 1) == 92) {
            result += this._text.substring(pos1, pos2 - 1);
            result += "[";
            pos1 = pos2 + 1;
          } else {
            result += this._text.substring(pos1, pos2);
            break;
          }
        }
        if (pos2 == -1)
          return null;
        if (remove)
          this._readPos = pos2;
        return result;
      }
      parse(text, remove) {
        this._text = text;
        this.lastColor = null;
        this.lastSize = null;
        var pos1 = 0, pos2, pos3;
        var end;
        var tag, attr;
        var repl;
        var func;
        var result = "";
        while ((pos2 = this._text.indexOf("[", pos1)) != -1) {
          if (pos2 > 0 && this._text.charCodeAt(pos2 - 1) == 92) {
            result += this._text.substring(pos1, pos2 - 1);
            result += "[";
            pos1 = pos2 + 1;
            continue;
          }
          result += this._text.substring(pos1, pos2);
          pos1 = pos2;
          pos2 = this._text.indexOf("]", pos1);
          if (pos2 == -1)
            break;
          end = this._text.charAt(pos1 + 1) == "/";
          tag = this._text.substring(end ? pos1 + 2 : pos1 + 1, pos2);
          this._readPos = pos2 + 1;
          attr = null;
          repl = null;
          pos3 = tag.indexOf("=");
          if (pos3 != -1) {
            attr = tag.substring(pos3 + 1);
            tag = tag.substring(0, pos3);
          }
          tag = tag.toLowerCase();
          func = this._handlers[tag];
          if (func != null) {
            repl = func.call(this, tag, end, attr);
            if (repl != null && !remove)
              result += repl;
          } else
            result += this._text.substring(pos1, this._readPos);
          pos1 = this._readPos;
        }
        if (pos1 < this._text.length)
          result += this._text.substr(pos1);
        this._text = null;
        return result;
      }
    };
    defaultParser = new UBBParser();
    GTextField = class extends GObject {
      constructor() {
        super();
        this._fontSize = 0;
        this._leading = 0;
        this._dirtyVersion = 0;
        this._node.name = "GTextField";
        this._touchDisabled = true;
        this._text = "";
        this._color = new import_cc5.Color(255, 255, 255, 255);
        this.createRenderer();
        this.fontSize = 12;
        this.leading = 3;
        this.singleLine = false;
        this._sizeDirty = false;
        this._node.on(import_cc5.Node.EventType.SIZE_CHANGED, this.onLabelSizeChanged, this);
      }
      createRenderer() {
        this._label = this._node.addComponent(import_cc5.Label);
        this._label.string = "";
        this.autoSize = AutoSizeType.Both;
      }
      set text(value) {
        this._text = value;
        if (this._text == null)
          this._text = "";
        this.updateGear(6);
        this.markSizeChanged();
        this.updateText();
      }
      get text() {
        return this._text;
      }
      get font() {
        return this._font;
      }
      init(fontItem, font) {
        this._fontPackageItem = fontItem;
        if (fontItem) {
          fontItem.addRef();
        }
        this._realFont = font;
        this.updateFont();
        this.updateFontSize();
      }
      set font(value) {
        if (this._font != value || !value) {
          this._dirtyVersion++;
          let dirtyVersion = this._dirtyVersion;
          this._font = value;
          this.markSizeChanged();
          let newFont = value ? value : UIConfig.defaultFont;
          var pi = null;
          if (newFont.startsWith("ui://")) {
            pi = UIPackage.getItemByURL(newFont);
            if (pi) {
              if (!UIConfig.enableDelayLoad || pi.__loaded && pi.decoded) {
                newFont = pi.owner.getItemAsset(pi);
              } else {
                newFont = pi.owner.getItemAssetAsync2(pi);
              }
            } else
              newFont = UIConfig.defaultFont;
          }
          if (newFont instanceof Promise) {
            newFont.then((asset) => {
              if (!(0, import_cc5.isValid)(this._node) || this._dirtyVersion != dirtyVersion) {
                return;
              }
              this.init(pi, asset);
            });
          } else {
            this.init(pi, newFont);
          }
        }
      }
      dispose() {
        super.dispose();
        if (this._fontPackageItem) {
          this._fontPackageItem.decRef();
          this._fontPackageItem = null;
        }
      }
      get fontSize() {
        return this._fontSize;
      }
      set fontSize(value) {
        if (value < 0)
          return;
        if (this._fontSize != value) {
          this._fontSize = value;
          this.markSizeChanged();
          this.updateFontSize();
        }
      }
      get color() {
        return this._color;
      }
      set color(value) {
        this._color.set(value);
        this.updateGear(4);
        this.updateFontColor();
      }
      get align() {
        return this._label ? this._label.horizontalAlign : 0;
      }
      set align(value) {
        if (this._label)
          this._label.horizontalAlign = value;
      }
      get verticalAlign() {
        return this._label ? this._label.verticalAlign : 0;
      }
      set verticalAlign(value) {
        if (this._label)
          this._label.verticalAlign = value;
      }
      get leading() {
        return this._leading;
      }
      set leading(value) {
        if (this._leading != value) {
          this._leading = value;
          this.markSizeChanged();
          this.updateFontSize();
        }
      }
      get letterSpacing() {
        return this._label ? this._label.spacingX : 0;
      }
      set letterSpacing(value) {
        if (this._label && this._label.spacingX != value) {
          this.markSizeChanged();
          this._label.spacingX = value;
        }
      }
      get underline() {
        return this._label ? this._label.isUnderline : false;
      }
      set underline(value) {
        if (this._label)
          this._label.isUnderline = value;
      }
      get bold() {
        return this._label ? this._label.isBold : false;
      }
      set bold(value) {
        if (this._label)
          this._label.isBold = value;
      }
      get italic() {
        return this._label ? this._label.isItalic : false;
      }
      set italic(value) {
        if (this._label)
          this._label.isItalic = value;
      }
      get singleLine() {
        return this._label ? !this._label.enableWrapText : false;
      }
      set singleLine(value) {
        if (this._label)
          this._label.enableWrapText = !value;
      }
      get stroke() {
        return this._outline && this._outline.enabled ? this._outline.width : 0;
      }
      set stroke(value) {
        if (value == 0) {
          if (this._outline)
            this._outline.enabled = false;
        } else {
          if (!this._outline) {
            this._outline = this._node.addComponent(import_cc5.LabelOutline);
            this.updateStrokeColor();
          } else
            this._outline.enabled = true;
          this._outline.width = value;
        }
      }
      get strokeColor() {
        return this._strokeColor;
      }
      set strokeColor(value) {
        if (!this._strokeColor)
          this._strokeColor = new import_cc5.Color();
        this._strokeColor.set(value);
        this.updateGear(4);
        this.updateStrokeColor();
      }
      get shadowOffset() {
        return this._shadowOffset;
      }
      set shadowOffset(value) {
        if (!this._shadowOffset)
          this._shadowOffset = new import_cc5.Vec2();
        this._shadowOffset.set(value);
        if (this._shadowOffset.x != 0 || this._shadowOffset.y != 0) {
          if (!this._shadow) {
            this._shadow = this._node.addComponent(import_cc5.LabelShadow);
            this.updateShadowColor();
          } else
            this._shadow.enabled = true;
          this._shadow.offset.x = value.x;
          this._shadow.offset.y = -value.y;
        } else if (this._shadow)
          this._shadow.enabled = false;
      }
      get shadowColor() {
        return this._shadowColor;
      }
      set shadowColor(value) {
        if (!this._shadowColor)
          this._shadowColor = new import_cc5.Color();
        this._shadowColor.set(value);
        this.updateShadowColor();
      }
      set ubbEnabled(value) {
        if (this._ubbEnabled != value) {
          this._ubbEnabled = value;
          this.markSizeChanged();
          this.updateText();
        }
      }
      get ubbEnabled() {
        return this._ubbEnabled;
      }
      set autoSize(value) {
        if (this._autoSize != value) {
          this._autoSize = value;
          this.markSizeChanged();
          this.updateOverflow();
        }
      }
      get autoSize() {
        return this._autoSize;
      }
      parseTemplate(template) {
        var pos1 = 0, pos2, pos3;
        var tag;
        var value;
        var result = "";
        while ((pos2 = template.indexOf("{", pos1)) != -1) {
          if (pos2 > 0 && template.charCodeAt(pos2 - 1) == 92) {
            result += template.substring(pos1, pos2 - 1);
            result += "{";
            pos1 = pos2 + 1;
            continue;
          }
          result += template.substring(pos1, pos2);
          pos1 = pos2;
          pos2 = template.indexOf("}", pos1);
          if (pos2 == -1)
            break;
          if (pos2 == pos1 + 1) {
            result += template.substr(pos1, 2);
            pos1 = pos2 + 1;
            continue;
          }
          tag = template.substring(pos1 + 1, pos2);
          pos3 = tag.indexOf("=");
          if (pos3 != -1) {
            value = this._templateVars[tag.substring(0, pos3)];
            if (value == null)
              result += tag.substring(pos3 + 1);
            else
              result += value;
          } else {
            value = this._templateVars[tag];
            if (value != null)
              result += value;
          }
          pos1 = pos2 + 1;
        }
        if (pos1 < template.length)
          result += template.substr(pos1);
        return result;
      }
      get templateVars() {
        return this._templateVars;
      }
      set templateVars(value) {
        if (this._templateVars == null && value == null)
          return;
        this._templateVars = value;
        this.flushVars();
      }
      setVar(name, value) {
        if (!this._templateVars)
          this._templateVars = {};
        this._templateVars[name] = value;
        return this;
      }
      flushVars() {
        this.markSizeChanged();
        this.updateText();
      }
      get textWidth() {
        this.ensureSizeCorrect();
        return this._node._uiProps.uiTransformComp.width;
      }
      ensureSizeCorrect() {
        if (this._sizeDirty) {
          this._label.updateRenderData(true);
          this._sizeDirty = false;
        }
      }
      updateText() {
        var text2 = this._text;
        if (this._templateVars)
          text2 = this.parseTemplate(text2);
        if (this._ubbEnabled)
          text2 = defaultParser.parse(text2, true);
        this._label.string = text2;
      }
      assignFont(label, value) {
        if (value instanceof import_cc5.Font)
          label.font = value;
        else {
          let font = getFontByName(value);
          if (!font) {
            label.fontFamily = value;
            label.useSystemFont = true;
          } else
            label.font = font;
        }
        this.updateFontColor();
      }
      assignFontColor(label, value) {
        let font = label.font;
        if (font instanceof import_cc5.BitmapFont && !font.fntConfig.canTint)
          value = import_cc5.Color.WHITE;
        if (label instanceof import_cc5.Label) {
          if (font instanceof import_cc5.BitmapFont && this._grayed) {
            label._instanceMaterialType = import_cc5.InstanceMaterialType.GRAYSCALE;
            label.updateMaterial();
          } else {
            label.changeMaterialForDefine();
            if (this._grayed)
              value = toGrayedColor(value);
          }
        } else {
          if (this._grayed)
            value = toGrayedColor(value);
        }
        label.color = value;
      }
      updateFont() {
        this.assignFont(this._label, this._realFont);
      }
      updateFontColor() {
        this.assignFontColor(this._label, this._color);
      }
      updateStrokeColor() {
        if (!this._outline)
          return;
        if (!this._strokeColor)
          this._strokeColor = new import_cc5.Color();
        if (this._grayed)
          this._outline.color = toGrayedColor(this._strokeColor);
        else
          this._outline.color = this._strokeColor;
      }
      updateShadowColor() {
        if (!this._shadow)
          return;
        if (!this._shadowColor)
          this._shadowColor = new import_cc5.Color();
        if (this._grayed)
          this._shadow.color = toGrayedColor(this._shadowColor);
        else
          this._shadow.color = this._shadowColor;
      }
      updateFontSize() {
        let font = this._label.font;
        if (font instanceof import_cc5.BitmapFont) {
          let fntConfig = font.fntConfig;
          if (fntConfig.resizable)
            this._label.fontSize = this._fontSize;
          else
            this._label.fontSize = fntConfig.fontSize;
          this._label.lineHeight = fntConfig.fontSize + (this._leading + 4) * fntConfig.fontSize / this._label.fontSize;
        } else {
          this._label.fontSize = this._fontSize;
          this._label.lineHeight = this._fontSize + this._leading;
        }
      }
      updateOverflow() {
        const uiComp = this._node._uiProps.uiTransformComp;
        if (this._autoSize == AutoSizeType.Both)
          this._label.overflow = import_cc5.Label.Overflow.NONE;
        else if (this._autoSize == AutoSizeType.Height) {
          this._label.overflow = import_cc5.Label.Overflow.RESIZE_HEIGHT;
          uiComp.width = this._width;
        } else if (this._autoSize == AutoSizeType.Shrink) {
          this._label.overflow = import_cc5.Label.Overflow.SHRINK;
          uiComp.setContentSize(this._width, this._height);
        } else {
          this._label.overflow = import_cc5.Label.Overflow.CLAMP;
          uiComp.setContentSize(this._width, this._height);
        }
      }
      markSizeChanged() {
        if (this._underConstruct)
          return;
        if (this._autoSize == AutoSizeType.Both || this._autoSize == AutoSizeType.Height) {
          if (!this._sizeDirty) {
            this._node.emit(Event.SIZE_DELAY_CHANGE);
            this._sizeDirty = true;
          }
        }
      }
      onLabelSizeChanged() {
        this._sizeDirty = false;
        if (this._underConstruct)
          return;
        if (this._autoSize == AutoSizeType.Both || this._autoSize == AutoSizeType.Height) {
          this._updatingSize = true;
          this.setSize(this._node._uiProps.uiTransformComp.width, this._node._uiProps.uiTransformComp.height);
          this._updatingSize = false;
        }
      }
      handleSizeChanged() {
        if (this._updatingSize)
          return;
        if (this._autoSize == AutoSizeType.None || this._autoSize == AutoSizeType.Shrink) {
          this._node._uiProps.uiTransformComp.setContentSize(this._width, this._height);
        } else if (this._autoSize == AutoSizeType.Height)
          this._node._uiProps.uiTransformComp.width = this._width;
      }
      handleGrayedChanged() {
        this.updateFontColor();
        this.updateStrokeColor();
      }
      getProp(index) {
        switch (index) {
          case ObjectPropID.Color:
            return this.color;
          case ObjectPropID.OutlineColor:
            return this.strokeColor;
          case ObjectPropID.FontSize:
            return this.fontSize;
          default:
            return super.getProp(index);
        }
      }
      setProp(index, value) {
        switch (index) {
          case ObjectPropID.Color:
            this.color = value;
            break;
          case ObjectPropID.OutlineColor:
            this.strokeColor = value;
            break;
          case ObjectPropID.FontSize:
            this.fontSize = value;
            break;
          default:
            super.setProp(index, value);
            break;
        }
      }
      setup_beforeAdd(buffer, beginPos) {
        super.setup_beforeAdd(buffer, beginPos);
        buffer.seek(beginPos, 5);
        this.font = buffer.readS();
        this.fontSize = buffer.readShort();
        this.color = buffer.readColor();
        this.align = buffer.readByte();
        this.verticalAlign = buffer.readByte();
        this.leading = buffer.readShort();
        this.letterSpacing = buffer.readShort();
        this._ubbEnabled = buffer.readBool();
        this.autoSize = buffer.readByte();
        this.underline = buffer.readBool();
        this.italic = buffer.readBool();
        this.bold = buffer.readBool();
        this.singleLine = buffer.readBool();
        if (buffer.readBool()) {
          this.strokeColor = buffer.readColor();
          this.stroke = buffer.readFloat();
        }
        if (buffer.readBool()) {
          this.shadowColor = buffer.readColor();
          let f1 = buffer.readFloat();
          let f2 = buffer.readFloat();
          this.shadowOffset = new import_cc5.Vec2(f1, f2);
        }
        if (buffer.readBool())
          this._templateVars = {};
      }
      setup_afterAdd(buffer, beginPos) {
        super.setup_afterAdd(buffer, beginPos);
        buffer.seek(beginPos, 6);
        var str = buffer.readS();
        if (str != null)
          this.text = str;
      }
    };
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    RichTextImageAtlas = class extends import_cc5.SpriteAtlas {
      getSpriteFrame(key) {
        let pi = UIPackage.getItemByURL(key);
        if (pi) {
          pi.load();
          if (pi.type == PackageItemType.Image)
            return pi.asset;
          else if (pi.type == PackageItemType.MovieClip)
            return pi.frames[0].texture;
        }
        return super.getSpriteFrame(key);
      }
      getSpriteFrameAsync(key) {
        const _super = Object.create(null, {
          getSpriteFrame: { get: () => super.getSpriteFrame }
        });
        return __awaiter(this, void 0, void 0, function* () {
          let pi = UIPackage.getItemByURL(key);
          if (pi) {
            yield pi.loadAsync();
            if (pi.type == PackageItemType.Image)
              return pi.asset;
            else if (pi.type == PackageItemType.MovieClip)
              return pi.frames[0].texture;
          }
          return _super.getSpriteFrame.call(this, key);
        });
      }
    };
    imageAtlas = new RichTextImageAtlas();
    GRichTextField = class extends GTextField {
      constructor() {
        super();
        this._node.name = "GRichTextField";
        this._touchDisabled = false;
        this.linkUnderline = UIConfig.linkUnderline;
      }
      createRenderer() {
        this._richText = this._node.addComponent(import_cc5.RichText);
        this._richText.handleTouchEvent = false;
        this.autoSize = AutoSizeType.None;
        this._richText.imageAtlas = imageAtlas;
      }
      get align() {
        return this._richText.horizontalAlign;
      }
      set align(value) {
        this._richText.horizontalAlign = value;
      }
      get underline() {
        return this._underline;
      }
      set underline(value) {
        if (this._underline != value) {
          this._underline = value;
          this.updateText();
        }
      }
      get bold() {
        return this._bold;
      }
      set bold(value) {
        if (this._bold != value) {
          this._bold = value;
          this.updateText();
        }
      }
      get italic() {
        return this._italics;
      }
      set italic(value) {
        if (this._italics != value) {
          this._italics = value;
          this.updateText();
        }
      }
      markSizeChanged() {
      }
      updateText() {
        var text2 = this._text;
        if (this._templateVars)
          text2 = this.parseTemplate(text2);
        if (this._ubbEnabled) {
          defaultParser.linkUnderline = this.linkUnderline;
          defaultParser.linkColor = this.linkColor;
          text2 = defaultParser.parse(text2);
        }
        if (this._bold)
          text2 = "<b>" + text2 + "</b>";
        if (this._italics)
          text2 = "<i>" + text2 + "</i>";
        if (this._underline)
          text2 = "<u>" + text2 + "</u>";
        let c = this._color;
        if (this._grayed)
          c = toGrayedColor(c);
        text2 = "<color=" + c.toHEX("#rrggbb") + ">" + text2 + "</color>";
        if (this._autoSize == AutoSizeType.Both) {
          if (this._richText.maxWidth != 0)
            this._richText["_maxWidth"] = 0;
          this._richText.string = text2;
          if (this.maxWidth != 0 && this._node._uiProps.uiTransformComp.contentSize.width > this.maxWidth)
            this._richText.maxWidth = this.maxWidth;
        } else
          this._richText.string = text2;
      }
      updateFont() {
        this.assignFont(this._richText, this._realFont);
      }
      updateFontColor() {
        this.assignFontColor(this._richText, this._color);
      }
      updateFontSize() {
        let fontSize = this._fontSize;
        let font = this._richText.font;
        if (font instanceof import_cc5.BitmapFont) {
          if (!font.fntConfig.resizable)
            fontSize = font.fntConfig.fontSize;
        }
        this._richText.fontSize = fontSize;
        this._richText.lineHeight = fontSize + this._leading * 2;
      }
      updateOverflow() {
        if (this._autoSize == AutoSizeType.Both)
          this._richText.maxWidth = 0;
        else
          this._richText.maxWidth = this._width;
      }
      handleSizeChanged() {
        if (this._updatingSize)
          return;
        if (this._autoSize != AutoSizeType.Both)
          this._richText.maxWidth = this._width;
      }
    };
    InputProcessor = class extends import_cc5.Component {
      get touching() {
        return this._touching;
      }
      constructor() {
        super();
        this._touching = false;
        this._touches = new Array();
        this._rollOutChain = new Array();
        this._rollOverChain = new Array();
        this._touchPos = new import_cc5.Vec2();
      }
      onLoad() {
        this._owner = GObject.cast(this.node);
      }
      onEnable() {
        let node = this.node;
        node.on(import_cc5.Node.EventType.TOUCH_START, this.touchBeginHandler, this);
        node.on(import_cc5.Node.EventType.TOUCH_MOVE, this.touchMoveHandler, this);
        node.on(import_cc5.Node.EventType.TOUCH_END, this.touchEndHandler, this);
        node.on(import_cc5.Node.EventType.TOUCH_CANCEL, this.touchCancelHandler, this);
        node.on(import_cc5.Node.EventType.MOUSE_DOWN, this.mouseDownHandler, this);
        node.on(import_cc5.Node.EventType.MOUSE_MOVE, this.mouseMoveHandler, this);
        node.on(import_cc5.Node.EventType.MOUSE_UP, this.mouseUpHandler, this);
        node.on(import_cc5.Node.EventType.MOUSE_WHEEL, this.mouseWheelHandler, this);
        this._touchListener = this.node.eventProcessor.touchListener;
      }
      onDisable() {
        let node = this.node;
        node.off(import_cc5.Node.EventType.TOUCH_START, this.touchBeginHandler, this);
        node.off(import_cc5.Node.EventType.TOUCH_MOVE, this.touchMoveHandler, this);
        node.off(import_cc5.Node.EventType.TOUCH_END, this.touchEndHandler, this);
        node.off(import_cc5.Node.EventType.TOUCH_CANCEL, this.touchCancelHandler, this);
        node.off(import_cc5.Node.EventType.MOUSE_DOWN, this.mouseDownHandler, this);
        node.off(import_cc5.Node.EventType.MOUSE_MOVE, this.mouseMoveHandler, this);
        node.off(import_cc5.Node.EventType.MOUSE_UP, this.mouseUpHandler, this);
        node.off(import_cc5.Node.EventType.MOUSE_WHEEL, this.mouseWheelHandler, this);
        this._touchListener = null;
      }
      getAllTouches(touchIds) {
        touchIds = touchIds || new Array();
        let cnt = this._touches.length;
        for (let i = 0; i < cnt; i++) {
          let ti = this._touches[i];
          if (ti.touchId != -1)
            touchIds.push(ti.touchId);
        }
        return touchIds;
      }
      getTouchPosition(touchId) {
        if (touchId === void 0)
          touchId = -1;
        let cnt = this._touches.length;
        for (let i = 0; i < cnt; i++) {
          let ti = this._touches[i];
          if (ti.touchId != -1 && (touchId == -1 || ti.touchId == touchId))
            return ti.pos;
        }
        return import_cc5.Vec2.ZERO;
      }
      getTouchTarget() {
        let cnt = this._touches.length;
        for (let i = 0; i < cnt; i++) {
          let ti = this._touches[i];
          if (ti.touchId != -1)
            return ti.target;
        }
        return null;
      }
      addTouchMonitor(touchId, target) {
        let ti = this.getInfo(touchId, false);
        if (!ti)
          return;
        let index = ti.touchMonitors.indexOf(target);
        if (index == -1)
          ti.touchMonitors.push(target);
      }
      removeTouchMonitor(target) {
        let cnt = this._touches.length;
        for (let i = 0; i < cnt; i++) {
          let ti = this._touches[i];
          let index = ti.touchMonitors.indexOf(target);
          if (index != -1)
            ti.touchMonitors.splice(index, 1);
        }
      }
      cancelClick(touchId) {
        let ti = this.getInfo(touchId, false);
        if (ti)
          ti.clickCancelled = true;
      }
      simulateClick(target) {
        let evt;
        evt = borrowEvent(Event.TOUCH_BEGIN, true);
        evt.initiator = target;
        evt.pos.set(target.localToGlobal());
        evt.touchId = 0;
        evt.clickCount = 1;
        evt.button = 0;
        evt._processor = this;
        if (this._captureCallback)
          this._captureCallback.call(this._owner, evt);
        target.node.dispatchEvent(evt);
        evt.unuse();
        evt.type = Event.TOUCH_END;
        evt.bubbles = true;
        target.node.dispatchEvent(evt);
        evt.unuse();
        evt.type = Event.CLICK;
        evt.bubbles = true;
        target.node.dispatchEvent(evt);
        returnEvent(evt);
      }
      touchBeginHandler(evt) {
        this._touching = true;
        let ti = this.updateInfo(evt.getID(), evt.getLocation());
        this.setBegin(ti);
        if (this._touchListener) {
          this._touchListener.setSwallowTouches(ti.target != this._owner);
        } else {
          let e = evt;
          e.preventSwallow = ti.target == this._owner;
        }
        let evt2 = this.getEvent(ti, ti.target, Event.TOUCH_BEGIN, true);
        if (this._captureCallback)
          this._captureCallback.call(this._owner, evt2);
        ti.target.node.dispatchEvent(evt2);
        this.handleRollOver(ti, ti.target);
        return true;
      }
      touchMoveHandler(evt) {
        let ti = this.updateInfo(evt.getID(), evt.getLocation());
        if (!this._touchListener) {
          let e = evt;
          e.preventSwallow = ti.target == this._owner;
        }
        this.handleRollOver(ti, ti.target);
        if (ti.began) {
          let evt2 = this.getEvent(ti, ti.target, Event.TOUCH_MOVE, false);
          let done = false;
          let cnt = ti.touchMonitors.length;
          for (let i = 0; i < cnt; i++) {
            let mm = ti.touchMonitors[i];
            if (mm.node == null || !mm.node.activeInHierarchy)
              continue;
            evt2.unuse();
            evt2.type = Event.TOUCH_MOVE;
            mm.node.dispatchEvent(evt2);
            if (mm == this._owner)
              done = true;
          }
          if (!done && this.node) {
            evt2.unuse();
            evt2.type = Event.TOUCH_MOVE;
            this.node.dispatchEvent(evt2);
          }
          returnEvent(evt2);
        }
      }
      touchEndHandler(evt) {
        this._touching = false;
        let ti = this.updateInfo(evt.getID(), evt.getLocation());
        if (!this._touchListener) {
          let e = evt;
          e.preventSwallow = ti.target == this._owner;
        }
        this.setEnd(ti);
        let evt2 = this.getEvent(ti, ti.target, Event.TOUCH_END, false);
        let cnt = ti.touchMonitors.length;
        for (let i = 0; i < cnt; i++) {
          let mm = ti.touchMonitors[i];
          if (mm == ti.target || mm.node == null || !mm.node.activeInHierarchy || "isAncestorOf" in mm && mm.isAncestorOf(ti.target))
            continue;
          evt2.unuse();
          evt2.type = Event.TOUCH_END;
          mm.node.dispatchEvent(evt2);
        }
        ti.touchMonitors.length = 0;
        if (ti.target && ti.target.node) {
          if (ti.target instanceof GRichTextField)
            ti.target.node.getComponent(import_cc5.RichText)["_onTouchEnded"](evt);
          evt2.unuse();
          evt2.type = Event.TOUCH_END;
          evt2.bubbles = true;
          ti.target.node.dispatchEvent(evt2);
        }
        returnEvent(evt2);
        ti.target = this.clickTest(ti);
        if (ti.target) {
          evt2 = this.getEvent(ti, ti.target, Event.CLICK, true);
          ti.target.node.dispatchEvent(evt2);
          returnEvent(evt2);
        }
        if (import_cc5.sys.isMobile)
          this.handleRollOver(ti, null);
        else
          this.handleRollOver(ti, ti.target);
        ti.target = null;
        ti.touchId = -1;
        ti.button = -1;
      }
      touchCancelHandler(evt) {
        this._touching = false;
        let ti = this.updateInfo(evt.getID(), evt.getLocation());
        if (!this._touchListener) {
          let e = evt;
          e.preventSwallow = ti.target == this._owner;
        }
        let evt2 = this.getEvent(ti, ti.target, Event.TOUCH_END, false);
        let cnt = ti.touchMonitors.length;
        for (let i = 0; i < cnt; i++) {
          let mm = ti.touchMonitors[i];
          if (mm == ti.target || mm.node == null || !mm.node.activeInHierarchy || "isAncestorOf" in mm && mm.isAncestorOf(ti.target))
            continue;
          evt2.initiator = mm;
          mm.node.dispatchEvent(evt2);
        }
        ti.touchMonitors.length = 0;
        if (ti.target && ti.target.node) {
          evt2.bubbles = true;
          ti.target.node.dispatchEvent(evt2);
        }
        returnEvent(evt2);
        this.handleRollOver(ti, null);
        ti.target = null;
        ti.touchId = -1;
        ti.button = -1;
      }
      mouseDownHandler(evt) {
        let ti = this.getInfo(0, true);
        ti.button = evt.getButton();
      }
      mouseUpHandler(evt) {
        let ti = this.getInfo(0, true);
        ti.button = evt.getButton();
      }
      mouseMoveHandler(evt) {
        let ti = this.getInfo(0, false);
        if (ti && Math.abs(ti.pos.x - evt.getLocationX()) < 1 && Math.abs(ti.pos.y - (UIContentScaler.rootSize.height - evt.getLocationY())) < 1)
          return;
        ti = this.updateInfo(0, evt.getLocation());
        this.handleRollOver(ti, ti.target);
        if (ti.began) {
          let evt2 = this.getEvent(ti, ti.target, Event.TOUCH_MOVE, false);
          let done = false;
          let cnt = ti.touchMonitors.length;
          for (let i = 0; i < cnt; i++) {
            let mm = ti.touchMonitors[i];
            if (mm.node == null || !mm.node.activeInHierarchy)
              continue;
            evt2.initiator = mm;
            mm.node.dispatchEvent(evt2);
            if (mm == this._owner)
              done = true;
          }
          if (!done && this.node) {
            evt2.initiator = this._owner;
            this.node.dispatchEvent(evt2);
            returnEvent(evt2);
          }
          returnEvent(evt2);
        }
      }
      mouseWheelHandler(evt) {
        let ti = this.updateInfo(0, evt.getLocation());
        ti.mouseWheelDelta = Math.max(evt.getScrollX(), evt.getScrollY());
        let evt2 = this.getEvent(ti, ti.target, Event.MOUSE_WHEEL, true);
        ti.target.node.dispatchEvent(evt2);
        returnEvent(evt2);
      }
      updateInfo(touchId, pos) {
        const camera = import_cc5.director.root.batcher2D.getFirstRenderCamera(this.node);
        if (camera) {
          s_vec3.set(pos.x, pos.y);
          camera.screenToWorld(s_vec3_2, s_vec3);
          this._touchPos.set(s_vec3_2.x, s_vec3_2.y);
        } else
          this._touchPos.set(pos);
        this._touchPos.y = UIContentScaler.rootSize.height - this._touchPos.y;
        let target = this._owner.hitTest(this._touchPos);
        if (!target)
          target = this._owner;
        let ti = this.getInfo(touchId);
        ti.target = target;
        ti.pos.set(this._touchPos);
        ti.button = import_cc5.EventMouse.BUTTON_LEFT;
        ti.touchId = touchId;
        return ti;
      }
      getInfo(touchId, createIfNotExisits) {
        if (createIfNotExisits === void 0)
          createIfNotExisits = true;
        let ret = null;
        let cnt = this._touches.length;
        for (let i = 0; i < cnt; i++) {
          let ti = this._touches[i];
          if (ti.touchId == touchId)
            return ti;
          else if (ti.touchId == -1)
            ret = ti;
        }
        if (!ret) {
          if (!createIfNotExisits)
            return null;
          ret = new TouchInfo();
          this._touches.push(ret);
        }
        ret.touchId = touchId;
        return ret;
      }
      setBegin(ti) {
        ti.began = true;
        ti.clickCancelled = false;
        ti.downPos.set(ti.pos);
        ti.downTargets.length = 0;
        let obj = ti.target;
        while (obj) {
          ti.downTargets.push(obj);
          obj = obj.findParent();
        }
      }
      setEnd(ti) {
        ti.began = false;
        let now = import_cc5.game.totalTime / 1e3;
        let elapsed = now - ti.lastClickTime;
        if (elapsed < 0.45) {
          if (ti.clickCount == 2)
            ti.clickCount = 1;
          else
            ti.clickCount++;
        } else
          ti.clickCount = 1;
        ti.lastClickTime = now;
      }
      clickTest(ti) {
        if (ti.downTargets.length == 0 || ti.clickCancelled || Math.abs(ti.pos.x - ti.downPos.x) > 50 || Math.abs(ti.pos.y - ti.downPos.y) > 50)
          return null;
        let obj = ti.downTargets[0];
        if (obj && obj.node && obj.node.activeInHierarchy)
          return obj;
        obj = ti.target;
        while (obj) {
          let index = ti.downTargets.indexOf(obj);
          if (index != -1 && obj.node && obj.node.activeInHierarchy)
            break;
          obj = obj.findParent();
        }
        return obj;
      }
      handleRollOver(ti, target) {
        if (ti.lastRollOver == target)
          return;
        let element = ti.lastRollOver;
        while (element && element.node) {
          this._rollOutChain.push(element);
          element = element.findParent();
        }
        element = target;
        while (element && element.node) {
          let i = this._rollOutChain.indexOf(element);
          if (i != -1) {
            this._rollOutChain.length = i;
            break;
          }
          this._rollOverChain.push(element);
          element = element.findParent();
        }
        ti.lastRollOver = target;
        let cnt = this._rollOutChain.length;
        for (let i = 0; i < cnt; i++) {
          element = this._rollOutChain[i];
          if (element.node && element.node.activeInHierarchy) {
            let evt = this.getEvent(ti, element, Event.ROLL_OUT, false);
            element.node.dispatchEvent(evt);
            returnEvent(evt);
          }
        }
        cnt = this._rollOverChain.length;
        for (let i = 0; i < cnt; i++) {
          element = this._rollOverChain[i];
          if (element.node && element.node.activeInHierarchy) {
            let evt = this.getEvent(ti, element, Event.ROLL_OVER, false);
            element.node.dispatchEvent(evt);
            returnEvent(evt);
          }
        }
        this._rollOutChain.length = 0;
        this._rollOverChain.length = 0;
      }
      getEvent(ti, target, type, bubbles) {
        let evt = borrowEvent(type, bubbles);
        evt.initiator = target;
        evt.pos.set(ti.pos);
        evt.touchId = ti.touchId;
        evt.clickCount = ti.clickCount;
        evt.button = ti.button;
        evt.mouseWheelDelta = ti.mouseWheelDelta;
        evt._processor = this;
        return evt;
      }
    };
    TouchInfo = class {
      constructor() {
        this.pos = new import_cc5.Vec2();
        this.touchId = 0;
        this.clickCount = 0;
        this.mouseWheelDelta = 0;
        this.button = -1;
        this.downPos = new import_cc5.Vec2();
        this.began = false;
        this.clickCancelled = false;
        this.lastClickTime = 0;
        this.downTargets = new Array();
        this.touchMonitors = new Array();
      }
    };
    s_vec3 = new import_cc5.Vec3();
    s_vec3_2 = new import_cc5.Vec3();
    ControllerAction = class {
      constructor() {
      }
      run(controller, prevPage, curPage) {
        if ((!this.fromPage || this.fromPage.length == 0 || this.fromPage.indexOf(prevPage) != -1) && (!this.toPage || this.toPage.length == 0 || this.toPage.indexOf(curPage) != -1))
          this.enter(controller);
        else
          this.leave(controller);
      }
      enter(controller) {
      }
      leave(controller) {
      }
      setup(buffer) {
        var cnt;
        var i;
        cnt = buffer.readShort();
        this.fromPage = [];
        for (i = 0; i < cnt; i++)
          this.fromPage[i] = buffer.readS();
        cnt = buffer.readShort();
        this.toPage = [];
        for (i = 0; i < cnt; i++)
          this.toPage[i] = buffer.readS();
      }
    };
    PlayTransitionAction = class extends ControllerAction {
      constructor() {
        super();
        this.playTimes = 1;
        this.delay = 0;
      }
      enter(controller) {
        var trans = controller.parent.getTransition(this.transitionName);
        if (trans) {
          if (this._currentTransition && this._currentTransition.playing)
            trans.changePlayTimes(this.playTimes);
          else
            trans.play(null, this.playTimes, this.delay);
          this._currentTransition = trans;
        }
      }
      leave(controller) {
        if (this.stopOnExit && this._currentTransition) {
          this._currentTransition.stop();
          this._currentTransition = null;
        }
      }
      setup(buffer) {
        super.setup(buffer);
        this.transitionName = buffer.readS();
        this.playTimes = buffer.readInt();
        this.delay = buffer.readFloat();
        this.stopOnExit = buffer.readBool();
      }
    };
    ChangePageAction = class extends ControllerAction {
      constructor() {
        super();
      }
      enter(controller) {
        if (!this.controllerName)
          return;
        var gcom;
        if (this.objectId)
          gcom = controller.parent.getChildById(this.objectId);
        else
          gcom = controller.parent;
        if (gcom) {
          var cc = gcom.getController(this.controllerName);
          if (cc && cc != controller && !cc.changing) {
            if (this.targetPage == "~1") {
              if (controller.selectedIndex < cc.pageCount)
                cc.selectedIndex = controller.selectedIndex;
            } else if (this.targetPage == "~2")
              cc.selectedPage = controller.selectedPage;
            else
              cc.selectedPageId = this.targetPage;
          }
        }
      }
      setup(buffer) {
        super.setup(buffer);
        this.objectId = buffer.readS();
        this.controllerName = buffer.readS();
        this.targetPage = buffer.readS();
      }
    };
    _nextPageId = 0;
    Controller = class extends import_cc5.EventTarget {
      constructor() {
        super();
        this._pageIds = [];
        this._pageNames = [];
        this._selectedIndex = -1;
        this._previousIndex = -1;
      }
      dispose() {
      }
      get selectedIndex() {
        return this._selectedIndex;
      }
      set selectedIndex(value) {
        if (this._selectedIndex != value) {
          if (value > this._pageIds.length - 1)
            throw "index out of bounds: " + value;
          this.changing = true;
          this._previousIndex = this._selectedIndex;
          this._selectedIndex = value;
          this.parent.applyController(this);
          this.emit(Event.STATUS_CHANGED, this);
          this.changing = false;
        }
      }
      onChanged(callback, thisArg) {
        this.on(Event.STATUS_CHANGED, callback, thisArg);
      }
      offChanged(callback, thisArg) {
        this.off(Event.STATUS_CHANGED, callback, thisArg);
      }
      //功能和设置selectedIndex一样，但不会触发事件
      setSelectedIndex(value) {
        if (this._selectedIndex != value) {
          if (value > this._pageIds.length - 1)
            throw "index out of bounds: " + value;
          this.changing = true;
          this._previousIndex = this._selectedIndex;
          this._selectedIndex = value;
          this.parent.applyController(this);
          this.changing = false;
        }
      }
      get previsousIndex() {
        return this._previousIndex;
      }
      get selectedPage() {
        if (this._selectedIndex == -1)
          return null;
        else
          return this._pageNames[this._selectedIndex];
      }
      set selectedPage(val) {
        var i = this._pageNames.indexOf(val);
        if (i == -1)
          i = 0;
        this.selectedIndex = i;
      }
      //功能和设置selectedPage一样，但不会触发事件
      setSelectedPage(value) {
        var i = this._pageNames.indexOf(value);
        if (i == -1)
          i = 0;
        this.setSelectedIndex(i);
      }
      get previousPage() {
        if (this._previousIndex == -1)
          return null;
        else
          return this._pageNames[this._previousIndex];
      }
      get pageCount() {
        return this._pageIds.length;
      }
      getPageName(index) {
        return this._pageNames[index];
      }
      addPage(name) {
        name = name || "";
        this.addPageAt(name, this._pageIds.length);
      }
      addPageAt(name, index) {
        name = name || "";
        var nid = "" + _nextPageId++;
        if (index == null || index == this._pageIds.length) {
          this._pageIds.push(nid);
          this._pageNames.push(name);
        } else {
          this._pageIds.splice(index, 0, nid);
          this._pageNames.splice(index, 0, name);
        }
      }
      removePage(name) {
        var i = this._pageNames.indexOf(name);
        if (i != -1) {
          this._pageIds.splice(i, 1);
          this._pageNames.splice(i, 1);
          if (this._selectedIndex >= this._pageIds.length)
            this.selectedIndex = this._selectedIndex - 1;
          else
            this.parent.applyController(this);
        }
      }
      removePageAt(index) {
        this._pageIds.splice(index, 1);
        this._pageNames.splice(index, 1);
        if (this._selectedIndex >= this._pageIds.length)
          this.selectedIndex = this._selectedIndex - 1;
        else
          this.parent.applyController(this);
      }
      clearPages() {
        this._pageIds.length = 0;
        this._pageNames.length = 0;
        if (this._selectedIndex != -1)
          this.selectedIndex = -1;
        else
          this.parent.applyController(this);
      }
      hasPage(aName) {
        return this._pageNames.indexOf(aName) != -1;
      }
      getPageIndexById(aId) {
        return this._pageIds.indexOf(aId);
      }
      getPageIdByName(aName) {
        var i = this._pageNames.indexOf(aName);
        if (i != -1)
          return this._pageIds[i];
        else
          return null;
      }
      getPageNameById(aId) {
        var i = this._pageIds.indexOf(aId);
        if (i != -1)
          return this._pageNames[i];
        else
          return null;
      }
      getPageId(index) {
        return this._pageIds[index];
      }
      get selectedPageId() {
        if (this._selectedIndex == -1)
          return null;
        else
          return this._pageIds[this._selectedIndex];
      }
      set selectedPageId(val) {
        var i = this._pageIds.indexOf(val);
        this.selectedIndex = i;
      }
      set oppositePageId(val) {
        var i = this._pageIds.indexOf(val);
        if (i > 0)
          this.selectedIndex = 0;
        else if (this._pageIds.length > 1)
          this.selectedIndex = 1;
      }
      get previousPageId() {
        if (this._previousIndex == -1)
          return null;
        else
          return this._pageIds[this._previousIndex];
      }
      runActions() {
        if (this._actions) {
          var cnt = this._actions.length;
          for (var i = 0; i < cnt; i++) {
            this._actions[i].run(this, this.previousPageId, this.selectedPageId);
          }
        }
      }
      setup(buffer) {
        var beginPos = buffer.position;
        buffer.seek(beginPos, 0);
        this.name = buffer.readS();
        if (buffer.readBool())
          this.autoRadioGroupDepth = true;
        buffer.seek(beginPos, 1);
        var i;
        var nextPos;
        var cnt = buffer.readShort();
        for (i = 0; i < cnt; i++) {
          this._pageIds.push(buffer.readS());
          this._pageNames.push(buffer.readS());
        }
        var homePageIndex = 0;
        if (buffer.version >= 2) {
          var homePageType = buffer.readByte();
          switch (homePageType) {
            case 1:
              homePageIndex = buffer.readShort();
              break;
            case 2:
              homePageIndex = this._pageNames.indexOf(UIPackage.branch);
              if (homePageIndex == -1)
                homePageIndex = 0;
              break;
            case 3:
              homePageIndex = this._pageNames.indexOf(UIPackage.getVar(buffer.readS()));
              if (homePageIndex == -1)
                homePageIndex = 0;
              break;
          }
        }
        buffer.seek(beginPos, 2);
        cnt = buffer.readShort();
        if (cnt > 0) {
          if (!this._actions)
            this._actions = new Array();
          for (i = 0; i < cnt; i++) {
            nextPos = buffer.readShort();
            nextPos += buffer.position;
            var action = createAction(buffer.readByte());
            action.setup(buffer);
            this._actions.push(action);
            buffer.position = nextPos;
          }
        }
        if (this.parent && this._pageIds.length > 0)
          this._selectedIndex = homePageIndex;
        else
          this._selectedIndex = -1;
      }
      addAction(action) {
        if (!this._actions)
          this._actions = new Array();
        this._actions.push(action);
      }
    };
    Margin = class {
      constructor() {
        this.left = 0;
        this.right = 0;
        this.top = 0;
        this.bottom = 0;
      }
      copy(source) {
        this.top = source.top;
        this.bottom = source.bottom;
        this.left = source.left;
        this.right = source.right;
      }
      isNone() {
        return this.left == 0 && this.right == 0 && this.top == 0 && this.bottom == 0;
      }
    };
    ScrollPane = class _ScrollPane extends import_cc5.Component {
      constructor() {
        super(...arguments);
        this._aniFlag = 0;
      }
      setup(buffer) {
        const o = this._owner = GObject.cast(this.node);
        this._maskContainer = new import_cc5.Node("ScrollPane");
        this._maskContainer.layer = UIConfig.defaultUILayer;
        this._maskContainer.addComponent(import_cc5.UITransform).setAnchorPoint(0, 1);
        this._maskContainer.parent = o.node;
        this._container = o._container;
        this._container.parent = this._maskContainer;
        this._scrollBarMargin = new Margin();
        this._mouseWheelEnabled = true;
        this._xPos = 0;
        this._yPos = 0;
        this._aniFlag = 0;
        this._tweening = 0;
        this._footerLockedSize = 0;
        this._headerLockedSize = 0;
        this._viewSize = new import_cc5.Vec2();
        this._contentSize = new import_cc5.Vec2();
        this._pageSize = new import_cc5.Vec2(1, 1);
        this._overlapSize = new import_cc5.Vec2();
        this._tweenTime = new import_cc5.Vec2();
        this._tweenStart = new import_cc5.Vec2();
        this._tweenDuration = new import_cc5.Vec2();
        this._tweenChange = new import_cc5.Vec2();
        this._velocity = new import_cc5.Vec2();
        this._containerPos = new import_cc5.Vec2();
        this._beginTouchPos = new import_cc5.Vec2();
        this._lastTouchPos = new import_cc5.Vec2();
        this._lastTouchGlobalPos = new import_cc5.Vec2();
        this._scrollStep = UIConfig.defaultScrollStep;
        this._mouseWheelStep = this._scrollStep * 2;
        this._decelerationRate = UIConfig.defaultScrollDecelerationRate;
        this._snappingPolicy = 0;
        o.on(Event.TOUCH_BEGIN, this.onTouchBegin, this);
        o.on(Event.TOUCH_MOVE, this.onTouchMove, this);
        o.on(Event.TOUCH_END, this.onTouchEnd, this);
        o.on(Event.MOUSE_WHEEL, this.onMouseWheel, this);
        this._scrollType = buffer.readByte();
        var scrollBarDisplay = buffer.readByte();
        var flags = buffer.readInt();
        if (buffer.readBool()) {
          this._scrollBarMargin.top = buffer.readInt();
          this._scrollBarMargin.bottom = buffer.readInt();
          this._scrollBarMargin.left = buffer.readInt();
          this._scrollBarMargin.right = buffer.readInt();
        }
        var vtScrollBarRes = buffer.readS();
        var hzScrollBarRes = buffer.readS();
        var headerRes = buffer.readS();
        var footerRes = buffer.readS();
        if ((flags & 1) != 0)
          this._displayOnLeft = true;
        if ((flags & 2) != 0)
          this._snapToItem = true;
        if ((flags & 4) != 0)
          this._displayInDemand = true;
        if ((flags & 8) != 0)
          this._pageMode = true;
        if (flags & 16)
          this._touchEffect = true;
        else if (flags & 32)
          this._touchEffect = false;
        else
          this._touchEffect = UIConfig.defaultScrollTouchEffect;
        if (flags & 64)
          this._bouncebackEffect = true;
        else if (flags & 128)
          this._bouncebackEffect = false;
        else
          this._bouncebackEffect = UIConfig.defaultScrollBounceEffect;
        if ((flags & 256) != 0)
          this._inertiaDisabled = true;
        if ((flags & 512) == 0)
          this._maskContainer.addComponent(import_cc5.Mask);
        if ((flags & 1024) != 0)
          this._floating = true;
        if ((flags & 2048) != 0)
          this._dontClipMargin = true;
        if (scrollBarDisplay == ScrollBarDisplayType.Default)
          scrollBarDisplay = UIConfig.defaultScrollBarDisplay;
        if (scrollBarDisplay != ScrollBarDisplayType.Hidden) {
          if (this._scrollType == ScrollType.Both || this._scrollType == ScrollType.Vertical) {
            var res = vtScrollBarRes ? vtScrollBarRes : UIConfig.verticalScrollBar;
            if (res) {
              this._vtScrollBar = UIPackage.createObjectFromURL(res);
              if (!this._vtScrollBar)
                throw "cannot create scrollbar from " + res;
              this._vtScrollBar.setScrollPane(this, true);
              this._vtScrollBar.node.parent = o.node;
            }
          }
          if (this._scrollType == ScrollType.Both || this._scrollType == ScrollType.Horizontal) {
            var res = hzScrollBarRes ? hzScrollBarRes : UIConfig.horizontalScrollBar;
            if (res) {
              this._hzScrollBar = UIPackage.createObjectFromURL(res);
              if (!this._hzScrollBar)
                throw "cannot create scrollbar from " + res;
              this._hzScrollBar.setScrollPane(this, false);
              this._hzScrollBar.node.parent = o.node;
            }
          }
          if (scrollBarDisplay == ScrollBarDisplayType.Auto)
            this._scrollBarDisplayAuto = true;
          if (this._scrollBarDisplayAuto) {
            if (this._vtScrollBar)
              this._vtScrollBar.node.active = false;
            if (this._hzScrollBar)
              this._hzScrollBar.node.active = false;
            o.on(Event.ROLL_OVER, this.onRollOver, this);
            o.on(Event.ROLL_OUT, this.onRollOut, this);
          }
        }
        if (headerRes) {
          this._header = UIPackage.createObjectFromURL(headerRes);
          if (this._header == null)
            throw "cannot create scrollPane header from " + headerRes;
          else
            this._maskContainer.insertChild(this._header.node, 0);
        }
        if (footerRes) {
          this._footer = UIPackage.createObjectFromURL(footerRes);
          if (this._footer == null)
            throw "cannot create scrollPane footer from " + footerRes;
          else
            this._maskContainer.insertChild(this._footer.node, 0);
        }
        this._refreshBarAxis = this._scrollType == ScrollType.Both || this._scrollType == ScrollType.Vertical ? "y" : "x";
        this.setSize(o.width, o.height);
      }
      onDestroy() {
        delete this._pageController;
        if (this._hzScrollBar)
          this._hzScrollBar.dispose();
        if (this._vtScrollBar)
          this._vtScrollBar.dispose();
        if (this._header)
          this._header.dispose();
        if (this._footer)
          this._footer.dispose();
      }
      hitTest(pt, globalPt) {
        let target;
        if (this._vtScrollBar) {
          target = this._vtScrollBar.hitTest(globalPt);
          if (target)
            return target;
        }
        if (this._hzScrollBar) {
          target = this._hzScrollBar.hitTest(globalPt);
          if (target)
            return target;
        }
        if (this._header && this._header.node.activeInHierarchy) {
          target = this._header.hitTest(globalPt);
          if (target)
            return target;
        }
        if (this._footer && this._footer.node.activeInHierarchy) {
          target = this._footer.hitTest(globalPt);
          if (target)
            return target;
        }
        if (pt.x >= this._owner.margin.left && pt.y >= this._owner.margin.top && pt.x < this._owner.margin.left + this._viewSize.x && pt.y < this._owner.margin.top + this._viewSize.y)
          return this._owner;
        else
          return null;
      }
      get owner() {
        return this._owner;
      }
      get hzScrollBar() {
        return this._hzScrollBar;
      }
      get vtScrollBar() {
        return this._vtScrollBar;
      }
      get header() {
        return this._header;
      }
      get footer() {
        return this._footer;
      }
      get bouncebackEffect() {
        return this._bouncebackEffect;
      }
      set bouncebackEffect(sc) {
        this._bouncebackEffect = sc;
      }
      get touchEffect() {
        return this._touchEffect;
      }
      set touchEffect(sc) {
        this._touchEffect = sc;
      }
      set scrollStep(val) {
        this._scrollStep = val;
        if (this._scrollStep == 0)
          this._scrollStep = UIConfig.defaultScrollStep;
        this._mouseWheelStep = this._scrollStep * 2;
      }
      get decelerationRate() {
        return this._decelerationRate;
      }
      set decelerationRate(val) {
        this._decelerationRate = val;
      }
      get scrollStep() {
        return this._scrollStep;
      }
      get snapToItem() {
        return this._snapToItem;
      }
      set snapToItem(value) {
        this._snapToItem = value;
      }
      get snappingPolicy() {
        return this._snappingPolicy;
      }
      set snappingPolicy(value) {
        this._snappingPolicy = value;
      }
      get mouseWheelEnabled() {
        return this._mouseWheelEnabled;
      }
      set mouseWheelEnabled(value) {
        this._mouseWheelEnabled = value;
      }
      get isDragged() {
        return this._dragged;
      }
      get percX() {
        return this._overlapSize.x == 0 ? 0 : this._xPos / this._overlapSize.x;
      }
      set percX(value) {
        this.setPercX(value, false);
      }
      setPercX(value, ani) {
        this._owner.ensureBoundsCorrect();
        this.setPosX(this._overlapSize.x * import_cc5.math.clamp01(value), ani);
      }
      get percY() {
        return this._overlapSize.y == 0 ? 0 : this._yPos / this._overlapSize.y;
      }
      set percY(value) {
        this.setPercY(value, false);
      }
      setPercY(value, ani) {
        this._owner.ensureBoundsCorrect();
        this.setPosY(this._overlapSize.y * import_cc5.math.clamp01(value), ani);
      }
      get posX() {
        return this._xPos;
      }
      set posX(value) {
        this.setPosX(value, false);
      }
      setPosX(value, ani) {
        this._owner.ensureBoundsCorrect();
        if (this._loop == 1)
          value = this.loopCheckingNewPos(value, "x");
        value = import_cc5.math.clamp(value, 0, this._overlapSize.x);
        if (value != this._xPos) {
          this._xPos = value;
          this.posChanged(ani);
        }
      }
      get posY() {
        return this._yPos;
      }
      set posY(value) {
        this.setPosY(value, false);
      }
      setPosY(value, ani) {
        this._owner.ensureBoundsCorrect();
        if (this._loop == 1)
          value = this.loopCheckingNewPos(value, "y");
        value = import_cc5.math.clamp(value, 0, this._overlapSize.y);
        if (value != this._yPos) {
          this._yPos = value;
          this.posChanged(ani);
        }
      }
      get contentWidth() {
        return this._contentSize.x;
      }
      get contentHeight() {
        return this._contentSize.y;
      }
      get viewWidth() {
        return this._viewSize.x;
      }
      set viewWidth(value) {
        value = value + this._owner.margin.left + this._owner.margin.right;
        if (this._vtScrollBar && !this._floating)
          value += this._vtScrollBar.width;
        this._owner.width = value;
      }
      get viewHeight() {
        return this._viewSize.y;
      }
      set viewHeight(value) {
        value = value + this._owner.margin.top + this._owner.margin.bottom;
        if (this._hzScrollBar && !this._floating)
          value += this._hzScrollBar.height;
        this._owner.height = value;
      }
      get currentPageX() {
        if (!this._pageMode)
          return 0;
        var page = Math.floor(this._xPos / this._pageSize.x);
        if (this._xPos - page * this._pageSize.x > this._pageSize.x * 0.5)
          page++;
        return page;
      }
      set currentPageX(value) {
        this.setCurrentPageX(value, false);
      }
      get currentPageY() {
        if (!this._pageMode)
          return 0;
        var page = Math.floor(this._yPos / this._pageSize.y);
        if (this._yPos - page * this._pageSize.y > this._pageSize.y * 0.5)
          page++;
        return page;
      }
      set currentPageY(value) {
        this.setCurrentPageY(value, false);
      }
      setCurrentPageX(value, ani) {
        if (!this._pageMode)
          return;
        this._owner.ensureBoundsCorrect();
        if (this._overlapSize.x > 0)
          this.setPosX(value * this._pageSize.x, ani);
      }
      setCurrentPageY(value, ani) {
        if (!this._pageMode)
          return;
        this._owner.ensureBoundsCorrect();
        if (this._overlapSize.y > 0)
          this.setPosY(value * this._pageSize.y, ani);
      }
      get isBottomMost() {
        return this._yPos == this._overlapSize.y || this._overlapSize.y == 0;
      }
      get isRightMost() {
        return this._xPos == this._overlapSize.x || this._overlapSize.x == 0;
      }
      get pageController() {
        return this._pageController;
      }
      set pageController(value) {
        this._pageController = value;
      }
      get scrollingPosX() {
        return import_cc5.math.clamp(-this._container.position.x, 0, this._overlapSize.x);
      }
      get scrollingPosY() {
        return import_cc5.math.clamp(- -this._container.position.y, 0, this._overlapSize.y);
      }
      scrollTop(ani) {
        this.setPercY(0, ani);
      }
      scrollBottom(ani) {
        this.setPercY(1, ani);
      }
      scrollUp(ratio, ani) {
        if (ratio == void 0)
          ratio = 1;
        if (this._pageMode)
          this.setPosY(this._yPos - this._pageSize.y * ratio, ani);
        else
          this.setPosY(this._yPos - this._scrollStep * ratio, ani);
      }
      scrollDown(ratio, ani) {
        if (ratio == void 0)
          ratio = 1;
        if (this._pageMode)
          this.setPosY(this._yPos + this._pageSize.y * ratio, ani);
        else
          this.setPosY(this._yPos + this._scrollStep * ratio, ani);
      }
      scrollLeft(ratio, ani) {
        if (ratio == void 0)
          ratio = 1;
        if (this._pageMode)
          this.setPosX(this._xPos - this._pageSize.x * ratio, ani);
        else
          this.setPosX(this._xPos - this._scrollStep * ratio, ani);
      }
      scrollRight(ratio, ani) {
        if (ratio == void 0)
          ratio = 1;
        if (this._pageMode)
          this.setPosX(this._xPos + this._pageSize.x * ratio, ani);
        else
          this.setPosX(this._xPos + this._scrollStep * ratio, ani);
      }
      scrollToView(target, ani, setFirst) {
        this._owner.ensureBoundsCorrect();
        if (this._needRefresh)
          this.refresh();
        var rect;
        if (target instanceof GObject) {
          if (target.parent != this._owner) {
            target.parent.localToGlobalRect(target.x, target.y, target.width, target.height, s_rect);
            rect = this._owner.globalToLocalRect(s_rect.x, s_rect.y, s_rect.width, s_rect.height, s_rect);
          } else {
            rect = s_rect;
            rect.x = target.x;
            rect.y = target.y;
            rect.width = target.width;
            rect.height = target.height;
          }
        } else
          rect = target;
        if (this._overlapSize.y > 0) {
          var bottom = this._yPos + this._viewSize.y;
          if (setFirst || rect.y <= this._yPos || rect.height >= this._viewSize.y) {
            if (this._pageMode)
              this.setPosY(Math.floor(rect.y / this._pageSize.y) * this._pageSize.y, ani);
            else
              this.setPosY(rect.y, ani);
          } else if (rect.y + rect.height > bottom) {
            if (this._pageMode)
              this.setPosY(Math.floor(rect.y / this._pageSize.y) * this._pageSize.y, ani);
            else if (rect.height <= this._viewSize.y / 2)
              this.setPosY(rect.y + rect.height * 2 - this._viewSize.y, ani);
            else
              this.setPosY(rect.y + rect.height - this._viewSize.y, ani);
          }
        }
        if (this._overlapSize.x > 0) {
          var right = this._xPos + this._viewSize.x;
          if (setFirst || rect.x <= this._xPos || rect.width >= this._viewSize.x) {
            if (this._pageMode)
              this.setPosX(Math.floor(rect.x / this._pageSize.x) * this._pageSize.x, ani);
            else
              this.setPosX(rect.x, ani);
          } else if (rect.x + rect.width > right) {
            if (this._pageMode)
              this.setPosX(Math.floor(rect.x / this._pageSize.x) * this._pageSize.x, ani);
            else if (rect.width <= this._viewSize.x / 2)
              this.setPosX(rect.x + rect.width * 2 - this._viewSize.x, ani);
            else
              this.setPosX(rect.x + rect.width - this._viewSize.x, ani);
          }
        }
        if (!ani && this._needRefresh)
          this.refresh();
      }
      isChildInView(obj) {
        if (this._overlapSize.y > 0) {
          var dist = obj.y + -this._container.position.y;
          if (dist < -obj.height || dist > this._viewSize.y)
            return false;
        }
        if (this._overlapSize.x > 0) {
          dist = obj.x + this._container.position.x;
          if (dist < -obj.width || dist > this._viewSize.x)
            return false;
        }
        return true;
      }
      cancelDragging() {
        if (_ScrollPane.draggingPane == this)
          _ScrollPane.draggingPane = null;
        _gestureFlag = 0;
        this._dragged = false;
      }
      lockHeader(size) {
        if (this._headerLockedSize == size)
          return;
        let cx = this._container.position.x;
        let cy = -this._container.position.y;
        let cr = this._refreshBarAxis == "x" ? cx : cy;
        this._headerLockedSize = size;
        if (!this._refreshEventDispatching && cr >= 0) {
          this._tweenStart.x = cx;
          this._tweenStart.y = cy;
          this._tweenChange.set(import_cc5.Vec2.ZERO);
          this._tweenChange[this._refreshBarAxis] = this._headerLockedSize - this._tweenStart[this._refreshBarAxis];
          this._tweenDuration.x = this._tweenDuration.y = TWEEN_TIME_DEFAULT;
          this.startTween(2);
        }
      }
      lockFooter(size) {
        if (this._footerLockedSize == size)
          return;
        let cx = this._container.position.x;
        let cy = -this._container.position.y;
        let cr = this._refreshBarAxis == "x" ? cx : cy;
        this._footerLockedSize = size;
        if (!this._refreshEventDispatching && cr <= -this._overlapSize[this._refreshBarAxis]) {
          this._tweenStart.x = cx;
          this._tweenStart.y = cy;
          this._tweenChange.set(import_cc5.Vec2.ZERO);
          var max = this._overlapSize[this._refreshBarAxis];
          if (max == 0)
            max = Math.max(this._contentSize[this._refreshBarAxis] + this._footerLockedSize - this._viewSize[this._refreshBarAxis], 0);
          else
            max += this._footerLockedSize;
          this._tweenChange[this._refreshBarAxis] = -max - this._tweenStart[this._refreshBarAxis];
          this._tweenDuration.x = this._tweenDuration.y = TWEEN_TIME_DEFAULT;
          this.startTween(2);
        }
      }
      onOwnerSizeChanged() {
        this.setSize(this._owner.width, this._owner.height);
        this.posChanged(false);
      }
      handleControllerChanged(c) {
        if (this._pageController == c) {
          if (this._scrollType == ScrollType.Horizontal)
            this.setCurrentPageX(c.selectedIndex, true);
          else
            this.setCurrentPageY(c.selectedIndex, true);
        }
      }
      updatePageController() {
        if (this._pageController && !this._pageController.changing) {
          var index;
          if (this._scrollType == ScrollType.Horizontal)
            index = this.currentPageX;
          else
            index = this.currentPageY;
          if (index < this._pageController.pageCount) {
            var c = this._pageController;
            this._pageController = null;
            c.selectedIndex = index;
            this._pageController = c;
          }
        }
      }
      adjustMaskContainer() {
        var mx = 0;
        if (this._displayOnLeft && this._vtScrollBar && !this._floating)
          mx = this._vtScrollBar.width;
        const o = this._owner;
        if (this._dontClipMargin)
          this._maskContainer._uiProps.uiTransformComp.setAnchorPoint((o.margin.left + o._alignOffset.x) / o.width, 1 - (o.margin.top + o._alignOffset.y) / o.height);
        else
          this._maskContainer._uiProps.uiTransformComp.setAnchorPoint(o._alignOffset.x / this._viewSize.x, 1 - o._alignOffset.y / this._viewSize.y);
        if (o._customMask)
          this._maskContainer.setPosition(mx + o._alignOffset.x, -o._alignOffset.y);
        else
          this._maskContainer.setPosition(o._pivotCorrectX + mx + o._alignOffset.x, o._pivotCorrectY - o._alignOffset.y);
      }
      setSize(aWidth, aHeight) {
        if (this._hzScrollBar) {
          this._hzScrollBar.y = aHeight - this._hzScrollBar.height;
          if (this._vtScrollBar) {
            this._hzScrollBar.width = aWidth - this._vtScrollBar.width - this._scrollBarMargin.left - this._scrollBarMargin.right;
            if (this._displayOnLeft)
              this._hzScrollBar.x = this._scrollBarMargin.left + this._vtScrollBar.width;
            else
              this._hzScrollBar.x = this._scrollBarMargin.left;
          } else {
            this._hzScrollBar.width = aWidth - this._scrollBarMargin.left - this._scrollBarMargin.right;
            this._hzScrollBar.x = this._scrollBarMargin.left;
          }
        }
        if (this._vtScrollBar) {
          if (!this._displayOnLeft)
            this._vtScrollBar.x = aWidth - this._vtScrollBar.width;
          if (this._hzScrollBar)
            this._vtScrollBar.height = aHeight - this._hzScrollBar.height - this._scrollBarMargin.top - this._scrollBarMargin.bottom;
          else
            this._vtScrollBar.height = aHeight - this._scrollBarMargin.top - this._scrollBarMargin.bottom;
          this._vtScrollBar.y = this._scrollBarMargin.top;
        }
        this._viewSize.x = aWidth;
        this._viewSize.y = aHeight;
        if (this._hzScrollBar && !this._floating)
          this._viewSize.y -= this._hzScrollBar.height;
        if (this._vtScrollBar && !this._floating)
          this._viewSize.x -= this._vtScrollBar.width;
        this._viewSize.x -= this._owner.margin.left + this._owner.margin.right;
        this._viewSize.y -= this._owner.margin.top + this._owner.margin.bottom;
        this._viewSize.x = Math.max(1, this._viewSize.x);
        this._viewSize.y = Math.max(1, this._viewSize.y);
        this._pageSize.x = this._viewSize.x;
        this._pageSize.y = this._viewSize.y;
        this.adjustMaskContainer();
        this.handleSizeChanged();
      }
      setContentSize(aWidth, aHeight) {
        if (this._contentSize.x == aWidth && this._contentSize.y == aHeight)
          return;
        this._contentSize.x = aWidth;
        this._contentSize.y = aHeight;
        this.handleSizeChanged();
        if (this._snapToItem && this._snappingPolicy != 0 && this._xPos == 0 && this._yPos == 0)
          this.posChanged(false);
      }
      changeContentSizeOnScrolling(deltaWidth, deltaHeight, deltaPosX, deltaPosY) {
        var isRightmost = this._xPos == this._overlapSize.x;
        var isBottom = this._yPos == this._overlapSize.y;
        this._contentSize.x += deltaWidth;
        this._contentSize.y += deltaHeight;
        this.handleSizeChanged();
        if (this._tweening == 1) {
          if (deltaWidth != 0 && isRightmost && this._tweenChange.x < 0) {
            this._xPos = this._overlapSize.x;
            this._tweenChange.x = -this._xPos - this._tweenStart.x;
          }
          if (deltaHeight != 0 && isBottom && this._tweenChange.y < 0) {
            this._yPos = this._overlapSize.y;
            this._tweenChange.y = -this._yPos - this._tweenStart.y;
          }
        } else if (this._tweening == 2) {
          if (deltaPosX != 0) {
            this._container.setPosition(this._container.position.x - deltaPosX, this._container.position.y);
            this._tweenStart.x -= deltaPosX;
            this._xPos = -this._container.position.x;
          }
          if (deltaPosY != 0) {
            this._container.setPosition(this._container.position.x, this._container.position.y + deltaPosY);
            this._tweenStart.y -= deltaPosY;
            this._yPos = - -this._container.position.y;
          }
        } else if (this._dragged) {
          if (deltaPosX != 0) {
            this._container.setPosition(this._container.position.x - deltaPosX, this._container.position.y);
            this._containerPos.x -= deltaPosX;
            this._xPos = -this._container.position.x;
          }
          if (deltaPosY != 0) {
            this._container.setPosition(this._container.position.x, this._container.position.y + deltaPosY);
            this._containerPos.y -= deltaPosY;
            this._yPos = - -this._container.position.y;
          }
        } else {
          if (deltaWidth != 0 && isRightmost) {
            this._xPos = this._overlapSize.x;
            this._container.setPosition(-this._xPos, this._container.position.y);
          }
          if (deltaHeight != 0 && isBottom) {
            this._yPos = this._overlapSize.y;
            this._container.setPosition(this._container.position.x, this._yPos);
          }
        }
        if (this._pageMode)
          this.updatePageController();
      }
      handleSizeChanged() {
        if (this._displayInDemand) {
          this._vScrollNone = this._contentSize.y <= this._viewSize.y;
          this._hScrollNone = this._contentSize.x <= this._viewSize.x;
        }
        if (this._vtScrollBar) {
          if (this._contentSize.y == 0)
            this._vtScrollBar.setDisplayPerc(0);
          else
            this._vtScrollBar.setDisplayPerc(Math.min(1, this._viewSize.y / this._contentSize.y));
        }
        if (this._hzScrollBar) {
          if (this._contentSize.x == 0)
            this._hzScrollBar.setDisplayPerc(0);
          else
            this._hzScrollBar.setDisplayPerc(Math.min(1, this._viewSize.x / this._contentSize.x));
        }
        this.updateScrollBarVisible();
        var maskWidth = this._viewSize.x;
        var maskHeight = this._viewSize.y;
        if (this._vScrollNone && this._vtScrollBar)
          maskWidth += this._vtScrollBar.width;
        if (this._hScrollNone && this._hzScrollBar)
          maskHeight += this._hzScrollBar.height;
        if (this._dontClipMargin) {
          maskWidth += this._owner.margin.left + this._owner.margin.right;
          maskHeight += this._owner.margin.top + this._owner.margin.bottom;
        }
        this._maskContainer._uiProps.uiTransformComp.setContentSize(maskWidth, maskHeight);
        if (this._vtScrollBar)
          this._vtScrollBar.handlePositionChanged();
        if (this._hzScrollBar)
          this._hzScrollBar.handlePositionChanged();
        if (this._header)
          this._header.handlePositionChanged();
        if (this._footer)
          this._footer.handlePositionChanged();
        if (this._scrollType == ScrollType.Horizontal || this._scrollType == ScrollType.Both)
          this._overlapSize.x = Math.ceil(Math.max(0, this._contentSize.x - this._viewSize.x));
        else
          this._overlapSize.x = 0;
        if (this._scrollType == ScrollType.Vertical || this._scrollType == ScrollType.Both)
          this._overlapSize.y = Math.ceil(Math.max(0, this._contentSize.y - this._viewSize.y));
        else
          this._overlapSize.y = 0;
        this._xPos = import_cc5.math.clamp(this._xPos, 0, this._overlapSize.x);
        this._yPos = import_cc5.math.clamp(this._yPos, 0, this._overlapSize.y);
        var max = this._overlapSize[this._refreshBarAxis];
        if (max == 0)
          max = Math.max(this._contentSize[this._refreshBarAxis] + this._footerLockedSize - this._viewSize[this._refreshBarAxis], 0);
        else
          max += this._footerLockedSize;
        if (this._refreshBarAxis == "x")
          this._container.setPosition(import_cc5.math.clamp(this._container.position.x, -max, this._headerLockedSize), -import_cc5.math.clamp(-this._container.position.y, -this._overlapSize.y, 0));
        else
          this._container.setPosition(import_cc5.math.clamp(this._container.position.x, -this._overlapSize.x, 0), -import_cc5.math.clamp(-this._container.position.y, -max, this._headerLockedSize));
        if (this._header) {
          if (this._refreshBarAxis == "x")
            this._header.height = this._viewSize.y;
          else
            this._header.width = this._viewSize.x;
        }
        if (this._footer) {
          if (this._refreshBarAxis == "y")
            this._footer.height = this._viewSize.y;
          else
            this._footer.width = this._viewSize.x;
        }
        this.updateScrollBarPos();
        if (this._pageMode)
          this.updatePageController();
      }
      posChanged(ani) {
        if (this._aniFlag == 0)
          this._aniFlag = ani ? 1 : -1;
        else if (this._aniFlag == 1 && !ani)
          this._aniFlag = -1;
        this._needRefresh = true;
        if (!import_cc5.director.getScheduler().isScheduled(this.refresh, this))
          this.scheduleOnce(this.refresh);
      }
      refresh(dt) {
        this._needRefresh = false;
        this.unschedule(this.refresh);
        if (this._pageMode || this._snapToItem) {
          sEndPos.x = -this._xPos;
          sEndPos.y = -this._yPos;
          this.alignPosition(sEndPos, false);
          this._xPos = -sEndPos.x;
          this._yPos = -sEndPos.y;
        }
        this.refresh2();
        this._owner.node.emit(Event.SCROLL, this._owner);
        if (this._needRefresh) {
          this._needRefresh = false;
          this.unschedule(this.refresh);
          this.refresh2();
        }
        this.updateScrollBarPos();
        this._aniFlag = 0;
      }
      refresh2() {
        if (this._aniFlag == 1 && !this._dragged) {
          var posX;
          var posY;
          if (this._overlapSize.x > 0)
            posX = -Math.floor(this._xPos);
          else {
            if (this._container.position.x != 0)
              this._container.setPosition(0, this._container.position.y);
            posX = 0;
          }
          if (this._overlapSize.y > 0)
            posY = -Math.floor(this._yPos);
          else {
            if (this._container.position.y != 0)
              this._container.setPosition(this._container.position.x, 0);
            posY = 0;
          }
          if (posX != this._container.position.x || posY != -this._container.position.y) {
            this._tweenDuration.x = this._tweenDuration.y = TWEEN_TIME_GO;
            this._tweenStart.x = this._container.position.x;
            this._tweenStart.y = -this._container.position.y;
            this._tweenChange.x = posX - this._tweenStart.x;
            this._tweenChange.y = posY - this._tweenStart.y;
            this.startTween(1);
          } else if (this._tweening != 0)
            this.killTween();
        } else {
          if (this._tweening != 0)
            this.killTween();
          this._container.setPosition(Math.floor(-this._xPos), -Math.floor(-this._yPos));
          this.loopCheckingCurrent();
        }
        if (this._pageMode)
          this.updatePageController();
      }
      onTouchBegin(evt) {
        if (!this._touchEffect)
          return;
        evt.captureTouch();
        if (this._tweening != 0) {
          this.killTween();
          Decls$1.GRoot.inst.inputProcessor.cancelClick(evt.touchId);
          this._dragged = true;
        } else
          this._dragged = false;
        var pt = this._owner.globalToLocal(evt.pos.x, evt.pos.y, s_vec2$3);
        this._containerPos.x = this._container.position.x;
        this._containerPos.y = -this._container.position.y;
        this._beginTouchPos.set(pt);
        this._lastTouchPos.set(pt);
        this._lastTouchGlobalPos.set(evt.pos);
        this._isHoldAreaDone = false;
        this._velocity.set(import_cc5.Vec2.ZERO);
        this._velocityScale = 1;
        this._lastMoveTime = import_cc5.game.totalTime / 1e3;
      }
      onTouchMove(evt) {
        if (!(0, import_cc5.isValid)(this._owner.node))
          return;
        if (!this._touchEffect)
          return;
        if (GObject.draggingObject && GObject.draggingObject.onStage)
          return;
        if (_ScrollPane.draggingPane && _ScrollPane.draggingPane != this && _ScrollPane.draggingPane._owner.onStage)
          return;
        var pt = this._owner.globalToLocal(evt.pos.x, evt.pos.y, s_vec2$3);
        var sensitivity = UIConfig.touchScrollSensitivity;
        var diff, diff2;
        var sv, sh;
        if (this._scrollType == ScrollType.Vertical) {
          if (!this._isHoldAreaDone) {
            _gestureFlag |= 1;
            diff = Math.abs(this._beginTouchPos.y - pt.y);
            if (diff < sensitivity)
              return;
            if ((_gestureFlag & 2) != 0) {
              diff2 = Math.abs(this._beginTouchPos.x - pt.x);
              if (diff < diff2)
                return;
            }
          }
          sv = true;
        } else if (this._scrollType == ScrollType.Horizontal) {
          if (!this._isHoldAreaDone) {
            _gestureFlag |= 2;
            diff = Math.abs(this._beginTouchPos.x - pt.x);
            if (diff < sensitivity)
              return;
            if ((_gestureFlag & 1) != 0) {
              diff2 = Math.abs(this._beginTouchPos.y - pt.y);
              if (diff < diff2)
                return;
            }
          }
          sh = true;
        } else {
          _gestureFlag = 3;
          if (!this._isHoldAreaDone) {
            diff = Math.abs(this._beginTouchPos.y - pt.y);
            if (diff < sensitivity) {
              diff = Math.abs(this._beginTouchPos.x - pt.x);
              if (diff < sensitivity)
                return;
            }
          }
          sv = sh = true;
        }
        var newPosX = Math.floor(this._containerPos.x + pt.x - this._beginTouchPos.x);
        var newPosY = Math.floor(this._containerPos.y + pt.y - this._beginTouchPos.y);
        if (sv) {
          if (newPosY > 0) {
            if (!this._bouncebackEffect)
              this._container.setPosition(this._container.position.x, 0);
            else if (this._header && this._header.maxHeight != 0)
              this._container.setPosition(this._container.position.x, -Math.floor(Math.min(newPosY * 0.5, this._header.maxHeight)));
            else
              this._container.setPosition(this._container.position.x, -Math.floor(Math.min(newPosY * 0.5, this._viewSize.y * PULL_RATIO)));
          } else if (newPosY < -this._overlapSize.y) {
            if (!this._bouncebackEffect)
              this._container.setPosition(this._container.position.x, this._overlapSize.y);
            else if (this._footer && this._footer.maxHeight > 0)
              this._container.setPosition(this._container.position.x, -Math.floor(Math.max((newPosY + this._overlapSize.y) * 0.5, -this._footer.maxHeight) - this._overlapSize.y));
            else
              this._container.setPosition(this._container.position.x, -Math.floor(Math.max((newPosY + this._overlapSize.y) * 0.5, -this._viewSize.y * PULL_RATIO) - this._overlapSize.y));
          } else
            this._container.setPosition(this._container.position.x, -newPosY);
        }
        if (sh) {
          if (newPosX > 0) {
            if (!this._bouncebackEffect)
              this._container.setPosition(0, this._container.position.y);
            else if (this._header && this._header.maxWidth != 0)
              this._container.setPosition(Math.floor(Math.min(newPosX * 0.5, this._header.maxWidth)), this._container.position.y);
            else
              this._container.setPosition(Math.floor(Math.min(newPosX * 0.5, this._viewSize.x * PULL_RATIO)), this._container.position.y);
          } else if (newPosX < 0 - this._overlapSize.x) {
            if (!this._bouncebackEffect)
              this._container.setPosition(-this._overlapSize.x, this._container.position.y);
            else if (this._footer && this._footer.maxWidth > 0)
              this._container.setPosition(Math.floor(Math.max((newPosX + this._overlapSize.x) * 0.5, -this._footer.maxWidth) - this._overlapSize.x), this._container.position.y);
            else
              this._container.setPosition(Math.floor(Math.max((newPosX + this._overlapSize.x) * 0.5, -this._viewSize.x * PULL_RATIO) - this._overlapSize.x), this._container.position.y);
          } else
            this._container.setPosition(newPosX, this._container.position.y);
        }
        var now = import_cc5.game.totalTime / 1e3;
        var deltaTime = Math.max(now - this._lastMoveTime, 1 / 60);
        var deltaPositionX = pt.x - this._lastTouchPos.x;
        var deltaPositionY = pt.y - this._lastTouchPos.y;
        if (!sh)
          deltaPositionX = 0;
        if (!sv)
          deltaPositionY = 0;
        if (deltaTime != 0) {
          var frameRate = 60;
          var elapsed = deltaTime * frameRate - 1;
          if (elapsed > 1) {
            var factor = Math.pow(0.833, elapsed);
            this._velocity.x = this._velocity.x * factor;
            this._velocity.y = this._velocity.y * factor;
          }
          this._velocity.x = import_cc5.math.lerp(this._velocity.x, deltaPositionX * 60 / frameRate / deltaTime, deltaTime * 10);
          this._velocity.y = import_cc5.math.lerp(this._velocity.y, deltaPositionY * 60 / frameRate / deltaTime, deltaTime * 10);
        }
        var deltaGlobalPositionX = this._lastTouchGlobalPos.x - evt.pos.x;
        var deltaGlobalPositionY = this._lastTouchGlobalPos.y - evt.pos.y;
        if (deltaPositionX != 0)
          this._velocityScale = Math.abs(deltaGlobalPositionX / deltaPositionX);
        else if (deltaPositionY != 0)
          this._velocityScale = Math.abs(deltaGlobalPositionY / deltaPositionY);
        this._lastTouchPos.set(pt);
        this._lastTouchGlobalPos.set(evt.pos);
        this._lastMoveTime = now;
        if (this._overlapSize.x > 0)
          this._xPos = import_cc5.math.clamp(-this._container.position.x, 0, this._overlapSize.x);
        if (this._overlapSize.y > 0)
          this._yPos = import_cc5.math.clamp(- -this._container.position.y, 0, this._overlapSize.y);
        if (this._loop != 0) {
          newPosX = this._container.position.x;
          newPosY = -this._container.position.y;
          if (this.loopCheckingCurrent()) {
            this._containerPos.x += this._container.position.x - newPosX;
            this._containerPos.y += -this._container.position.y - newPosY;
          }
        }
        _ScrollPane.draggingPane = this;
        this._isHoldAreaDone = true;
        this._dragged = true;
        this.updateScrollBarPos();
        this.updateScrollBarVisible();
        if (this._pageMode)
          this.updatePageController();
        this._owner.node.emit(Event.SCROLL);
      }
      onTouchEnd(evt) {
        if (_ScrollPane.draggingPane == this)
          _ScrollPane.draggingPane = null;
        _gestureFlag = 0;
        if (!this._dragged || !this._touchEffect || !this._owner.node.activeInHierarchy) {
          this._dragged = false;
          return;
        }
        this._dragged = false;
        this._tweenStart.x = this._container.position.x;
        this._tweenStart.y = -this._container.position.y;
        sEndPos.set(this._tweenStart);
        var flag = false;
        if (this._container.position.x > 0) {
          sEndPos.x = 0;
          flag = true;
        } else if (this._container.position.x < -this._overlapSize.x) {
          sEndPos.x = -this._overlapSize.x;
          flag = true;
        }
        if (-this._container.position.y > 0) {
          sEndPos.y = 0;
          flag = true;
        } else if (-this._container.position.y < -this._overlapSize.y) {
          sEndPos.y = -this._overlapSize.y;
          flag = true;
        }
        if (flag) {
          this._tweenChange.x = sEndPos.x - this._tweenStart.x;
          this._tweenChange.y = sEndPos.y - this._tweenStart.y;
          if (this._tweenChange.x < -UIConfig.touchDragSensitivity || this._tweenChange.y < -UIConfig.touchDragSensitivity) {
            this._refreshEventDispatching = true;
            this._owner.node.emit(Event.PULL_DOWN_RELEASE), this._owner;
            this._refreshEventDispatching = false;
          } else if (this._tweenChange.x > UIConfig.touchDragSensitivity || this._tweenChange.y > UIConfig.touchDragSensitivity) {
            this._refreshEventDispatching = true;
            this._owner.node.emit(Event.PULL_UP_RELEASE, this._owner);
            this._refreshEventDispatching = false;
          }
          if (this._headerLockedSize > 0 && sEndPos[this._refreshBarAxis] == 0) {
            sEndPos[this._refreshBarAxis] = this._headerLockedSize;
            this._tweenChange.x = sEndPos.x - this._tweenStart.x;
            this._tweenChange.y = sEndPos.y - this._tweenStart.y;
          } else if (this._footerLockedSize > 0 && sEndPos[this._refreshBarAxis] == -this._overlapSize[this._refreshBarAxis]) {
            var max = this._overlapSize[this._refreshBarAxis];
            if (max == 0)
              max = Math.max(this._contentSize[this._refreshBarAxis] + this._footerLockedSize - this._viewSize[this._refreshBarAxis], 0);
            else
              max += this._footerLockedSize;
            sEndPos[this._refreshBarAxis] = -max;
            this._tweenChange.x = sEndPos.x - this._tweenStart.x;
            this._tweenChange.y = sEndPos.y - this._tweenStart.y;
          }
          this._tweenDuration.x = this._tweenDuration.y = TWEEN_TIME_DEFAULT;
        } else {
          if (!this._inertiaDisabled) {
            var frameRate = 60;
            var elapsed = (import_cc5.game.totalTime / 1e3 - this._lastMoveTime) * frameRate - 1;
            if (elapsed > 1) {
              var factor = Math.pow(0.833, elapsed);
              this._velocity.x = this._velocity.x * factor;
              this._velocity.y = this._velocity.y * factor;
            }
            this.updateTargetAndDuration(this._tweenStart, sEndPos);
          } else
            this._tweenDuration.x = this._tweenDuration.y = TWEEN_TIME_DEFAULT;
          sOldChange.x = sEndPos.x - this._tweenStart.x;
          sOldChange.y = sEndPos.y - this._tweenStart.y;
          this.loopCheckingTarget(sEndPos);
          if (this._pageMode || this._snapToItem)
            this.alignPosition(sEndPos, true);
          this._tweenChange.x = sEndPos.x - this._tweenStart.x;
          this._tweenChange.y = sEndPos.y - this._tweenStart.y;
          if (this._tweenChange.x == 0 && this._tweenChange.y == 0) {
            this.updateScrollBarVisible();
            return;
          }
          if (this._pageMode || this._snapToItem) {
            this.fixDuration("x", sOldChange.x);
            this.fixDuration("y", sOldChange.y);
          }
        }
        this.startTween(2);
      }
      onRollOver() {
        this._hover = true;
        this.updateScrollBarVisible();
      }
      onRollOut() {
        this._hover = false;
        this.updateScrollBarVisible();
      }
      onMouseWheel(evt) {
        if (!this._mouseWheelEnabled)
          return;
        let delta = evt.mouseWheelDelta > 0 ? -1 : 1;
        if (this._overlapSize.x > 0 && this._overlapSize.y == 0) {
          if (this._pageMode)
            this.setPosX(this._xPos + this._pageSize.x * delta, false);
          else
            this.setPosX(this._xPos + this._mouseWheelStep * delta, false);
        } else {
          if (this._pageMode)
            this.setPosY(this._yPos + this._pageSize.y * delta, false);
          else
            this.setPosY(this._yPos + this._mouseWheelStep * delta, false);
        }
      }
      updateScrollBarPos() {
        if (this._vtScrollBar)
          this._vtScrollBar.setScrollPerc(this._overlapSize.y == 0 ? 0 : import_cc5.math.clamp(this._container.position.y, 0, this._overlapSize.y) / this._overlapSize.y);
        if (this._hzScrollBar)
          this._hzScrollBar.setScrollPerc(this._overlapSize.x == 0 ? 0 : import_cc5.math.clamp(-this._container.position.x, 0, this._overlapSize.x) / this._overlapSize.x);
        this.checkRefreshBar();
      }
      updateScrollBarVisible() {
        if (this._vtScrollBar) {
          if (this._viewSize.y <= this._vtScrollBar.minSize || this._vScrollNone)
            this._vtScrollBar.node.active = false;
          else
            this.updateScrollBarVisible2(this._vtScrollBar);
        }
        if (this._hzScrollBar) {
          if (this._viewSize.x <= this._hzScrollBar.minSize || this._hScrollNone)
            this._hzScrollBar.node.active = false;
          else
            this.updateScrollBarVisible2(this._hzScrollBar);
        }
      }
      updateScrollBarVisible2(bar) {
        if (this._scrollBarDisplayAuto)
          GTween.kill(bar, false, "alpha");
        if (this._scrollBarDisplayAuto && !this._hover && this._tweening == 0 && !this._dragged && !bar.gripDragging) {
          if (bar.node.active)
            GTween.to(1, 0, 0.5).setDelay(0.5).onComplete(this.__barTweenComplete, this).setTarget(bar, "alpha");
        } else {
          bar.alpha = 1;
          bar.node.active = true;
        }
      }
      __barTweenComplete(tweener) {
        var bar = tweener.target;
        bar.alpha = 1;
        bar.node.active = false;
      }
      getLoopPartSize(division, axis) {
        return (this._contentSize[axis] + (axis == "x" ? this._owner.columnGap : this._owner.lineGap)) / division;
      }
      loopCheckingCurrent() {
        var changed = false;
        if (this._loop == 1 && this._overlapSize.x > 0) {
          if (this._xPos < 1e-3) {
            this._xPos += this.getLoopPartSize(2, "x");
            changed = true;
          } else if (this._xPos >= this._overlapSize.x) {
            this._xPos -= this.getLoopPartSize(2, "x");
            changed = true;
          }
        } else if (this._loop == 2 && this._overlapSize.y > 0) {
          if (this._yPos < 1e-3) {
            this._yPos += this.getLoopPartSize(2, "y");
            changed = true;
          } else if (this._yPos >= this._overlapSize.y) {
            this._yPos -= this.getLoopPartSize(2, "y");
            changed = true;
          }
        }
        if (changed) {
          this._container.setPosition(Math.floor(-this._xPos), -Math.floor(-this._yPos));
        }
        return changed;
      }
      loopCheckingTarget(endPos) {
        if (this._loop == 1)
          this.loopCheckingTarget2(endPos, "x");
        if (this._loop == 2)
          this.loopCheckingTarget2(endPos, "y");
      }
      loopCheckingTarget2(endPos, axis) {
        var halfSize;
        var tmp;
        if (endPos[axis] > 0) {
          halfSize = this.getLoopPartSize(2, axis);
          tmp = this._tweenStart[axis] - halfSize;
          if (tmp <= 0 && tmp >= -this._overlapSize[axis]) {
            endPos[axis] -= halfSize;
            this._tweenStart[axis] = tmp;
          }
        } else if (endPos[axis] < -this._overlapSize[axis]) {
          halfSize = this.getLoopPartSize(2, axis);
          tmp = this._tweenStart[axis] + halfSize;
          if (tmp <= 0 && tmp >= -this._overlapSize[axis]) {
            endPos[axis] += halfSize;
            this._tweenStart[axis] = tmp;
          }
        }
      }
      loopCheckingNewPos(value, axis) {
        if (this._overlapSize[axis] == 0)
          return value;
        var pos = axis == "x" ? this._xPos : this._yPos;
        var changed = false;
        var v;
        if (value < 1e-3) {
          value += this.getLoopPartSize(2, axis);
          if (value > pos) {
            v = this.getLoopPartSize(6, axis);
            v = Math.ceil((value - pos) / v) * v;
            pos = import_cc5.math.clamp(pos + v, 0, this._overlapSize[axis]);
            changed = true;
          }
        } else if (value >= this._overlapSize[axis]) {
          value -= this.getLoopPartSize(2, axis);
          if (value < pos) {
            v = this.getLoopPartSize(6, axis);
            v = Math.ceil((pos - value) / v) * v;
            pos = import_cc5.math.clamp(pos - v, 0, this._overlapSize[axis]);
            changed = true;
          }
        }
        if (changed) {
          if (axis == "x")
            this._container.setPosition(-Math.floor(pos), this._container.position.y);
          else
            this._container.setPosition(this._container.position.x, Math.floor(pos));
        }
        return value;
      }
      alignPosition(pos, inertialScrolling) {
        let ax = 0, ay = 0;
        if (this._snappingPolicy == 1) {
          if (this._owner.numChildren > 0) {
            let obj = this._owner.getChildAt(0);
            ax = Math.floor(this._viewSize.x * 0.5 - obj.width * 0.5);
            ay = Math.floor(this._viewSize.y * 0.5 - obj.height * 0.5);
          }
        } else if (this._snappingPolicy == 2) {
          if (this._owner.numChildren > 0) {
            let obj = this._owner.getChildAt(0);
            ax = Math.floor(this._viewSize.x - obj.width);
            ay = Math.floor(this._viewSize.y - obj.height);
          }
        }
        pos.x -= ax;
        pos.y -= ay;
        if (this._pageMode) {
          pos.x = this.alignByPage(pos.x, "x", inertialScrolling);
          pos.y = this.alignByPage(pos.y, "y", inertialScrolling);
        } else if (this._snapToItem) {
          var pt = this._owner.getSnappingPosition(-pos.x, -pos.y, s_vec2$3);
          if (pos.x < 0 && pos.x > -this._overlapSize.x)
            pos.x = -pt.x;
          if (pos.y < 0 && pos.y > -this._overlapSize.y)
            pos.y = -pt.y;
        }
        pos.x += ax;
        pos.y += ay;
      }
      alignByPage(pos, axis, inertialScrolling) {
        var page;
        if (pos > 0)
          page = 0;
        else if (pos < -this._overlapSize[axis])
          page = Math.ceil(this._contentSize[axis] / this._pageSize[axis]) - 1;
        else {
          page = Math.floor(-pos / this._pageSize[axis]);
          var change = inertialScrolling ? pos - this._containerPos[axis] : pos - (axis == "x" ? this._container.position.x : -this._container.position.y);
          var testPageSize = Math.min(this._pageSize[axis], this._contentSize[axis] - (page + 1) * this._pageSize[axis]);
          var delta = -pos - page * this._pageSize[axis];
          if (Math.abs(change) > this._pageSize[axis]) {
            if (delta > testPageSize * 0.5)
              page++;
          } else {
            if (delta > testPageSize * (change < 0 ? 0.3 : 0.7))
              page++;
          }
          pos = -page * this._pageSize[axis];
          if (pos < -this._overlapSize[axis])
            pos = -this._overlapSize[axis];
        }
        if (inertialScrolling) {
          var oldPos = this._tweenStart[axis];
          var oldPage;
          if (oldPos > 0)
            oldPage = 0;
          else if (oldPos < -this._overlapSize[axis])
            oldPage = Math.ceil(this._contentSize[axis] / this._pageSize[axis]) - 1;
          else
            oldPage = Math.floor(-oldPos / this._pageSize[axis]);
          var startPage = Math.floor(-this._containerPos[axis] / this._pageSize[axis]);
          if (Math.abs(page - startPage) > 1 && Math.abs(oldPage - startPage) <= 1) {
            if (page > startPage)
              page = startPage + 1;
            else
              page = startPage - 1;
            pos = -page * this._pageSize[axis];
          }
        }
        return pos;
      }
      updateTargetAndDuration(orignPos, resultPos) {
        resultPos.x = this.updateTargetAndDuration2(orignPos.x, "x");
        resultPos.y = this.updateTargetAndDuration2(orignPos.y, "y");
      }
      updateTargetAndDuration2(pos, axis) {
        var v = this._velocity[axis];
        var duration = 0;
        if (pos > 0)
          pos = 0;
        else if (pos < -this._overlapSize[axis])
          pos = -this._overlapSize[axis];
        else {
          var isMobile = false;
          var v24 = Math.abs(v) * this._velocityScale;
          const winSize = import_cc5.screen.windowSize;
          if (isMobile)
            v24 *= 1136 / Math.max(winSize.width, winSize.height);
          var ratio = 0;
          if (this._pageMode || !isMobile) {
            if (v24 > 500)
              ratio = Math.pow((v24 - 500) / 500, 2);
          } else {
            if (v24 > 1e3)
              ratio = Math.pow((v24 - 1e3) / 1e3, 2);
          }
          if (ratio != 0) {
            if (ratio > 1)
              ratio = 1;
            v24 *= ratio;
            v *= ratio;
            this._velocity[axis] = v;
            duration = Math.log(60 / v24) / Math.log(this._decelerationRate) / 60;
            var change = Math.floor(v * duration * 0.4);
            pos += change;
          }
        }
        if (duration < TWEEN_TIME_DEFAULT)
          duration = TWEEN_TIME_DEFAULT;
        this._tweenDuration[axis] = duration;
        return pos;
      }
      fixDuration(axis, oldChange) {
        if (this._tweenChange[axis] == 0 || Math.abs(this._tweenChange[axis]) >= Math.abs(oldChange))
          return;
        var newDuration = Math.abs(this._tweenChange[axis] / oldChange) * this._tweenDuration[axis];
        if (newDuration < TWEEN_TIME_DEFAULT)
          newDuration = TWEEN_TIME_DEFAULT;
        this._tweenDuration[axis] = newDuration;
      }
      startTween(type) {
        this._tweenTime.set(import_cc5.Vec2.ZERO);
        this._tweening = type;
        this.updateScrollBarVisible();
      }
      killTween() {
        if (this._tweening == 1) {
          this._container.setPosition(this._tweenStart.x + this._tweenChange.x, -(this._tweenStart.y + this._tweenChange.y));
          this._owner.node.emit(Event.SCROLL, this._owner);
        }
        this._tweening = 0;
        this.updateScrollBarVisible();
        this._owner.node.emit(Event.SCROLL_END, this._owner);
      }
      checkRefreshBar() {
        if (this._header == null && this._footer == null)
          return;
        var pos = this._refreshBarAxis == "x" ? this._container.position.x : -this._container.position.y;
        if (this._header) {
          if (pos > 0) {
            this._header.node.active = true;
            var pt = s_vec2$3;
            pt.x = this._header.width;
            pt.y = this._header.height;
            pt[this._refreshBarAxis] = pos;
            this._header.setSize(pt.x, pt.y);
          } else {
            this._header.node.active = false;
          }
        }
        if (this._footer) {
          var max = this._overlapSize[this._refreshBarAxis];
          if (pos < -max || max == 0 && this._footerLockedSize > 0) {
            this._footer.node.active = true;
            pt = s_vec2$3;
            pt.x = this._footer.x;
            pt.y = this._footer.y;
            if (max > 0)
              pt[this._refreshBarAxis] = pos + this._contentSize[this._refreshBarAxis];
            else
              pt[this._refreshBarAxis] = Math.max(Math.min(pos + this._viewSize[this._refreshBarAxis], this._viewSize[this._refreshBarAxis] - this._footerLockedSize), this._viewSize[this._refreshBarAxis] - this._contentSize[this._refreshBarAxis]);
            this._footer.setPosition(pt.x, pt.y);
            pt.x = this._footer.width;
            pt.y = this._footer.height;
            if (max > 0)
              pt[this._refreshBarAxis] = -max - pos;
            else
              pt[this._refreshBarAxis] = this._viewSize[this._refreshBarAxis] - this._footer[this._refreshBarAxis];
            this._footer.setSize(pt.x, pt.y);
          } else {
            this._footer.node.active = false;
          }
        }
      }
      update(dt) {
        if (this._tweening == 0)
          return;
        var nx = this.runTween("x", dt);
        var ny = this.runTween("y", dt);
        this._container.setPosition(nx, -ny);
        if (this._tweening == 2) {
          if (this._overlapSize.x > 0)
            this._xPos = import_cc5.math.clamp(-nx, 0, this._overlapSize.x);
          if (this._overlapSize.y > 0)
            this._yPos = import_cc5.math.clamp(-ny, 0, this._overlapSize.y);
          if (this._pageMode)
            this.updatePageController();
        }
        if (this._tweenChange.x == 0 && this._tweenChange.y == 0) {
          this._tweening = 0;
          this.loopCheckingCurrent();
          this.updateScrollBarPos();
          this.updateScrollBarVisible();
          this._owner.node.emit(Event.SCROLL, this._owner);
          this._owner.node.emit(Event.SCROLL_END, this._owner);
        } else {
          this.updateScrollBarPos();
          this._owner.node.emit(Event.SCROLL, this._owner);
        }
        return true;
      }
      runTween(axis, dt) {
        var newValue;
        if (this._tweenChange[axis] != 0) {
          this._tweenTime[axis] += dt;
          if (this._tweenTime[axis] >= this._tweenDuration[axis]) {
            newValue = this._tweenStart[axis] + this._tweenChange[axis];
            this._tweenChange[axis] = 0;
          } else {
            var ratio = easeFunc(this._tweenTime[axis], this._tweenDuration[axis]);
            newValue = this._tweenStart[axis] + Math.floor(this._tweenChange[axis] * ratio);
          }
          var threshold1 = 0;
          var threshold2 = -this._overlapSize[axis];
          if (this._headerLockedSize > 0 && this._refreshBarAxis == axis)
            threshold1 = this._headerLockedSize;
          if (this._footerLockedSize > 0 && this._refreshBarAxis == axis) {
            var max = this._overlapSize[this._refreshBarAxis];
            if (max == 0)
              max = Math.max(this._contentSize[this._refreshBarAxis] + this._footerLockedSize - this._viewSize[this._refreshBarAxis], 0);
            else
              max += this._footerLockedSize;
            threshold2 = -max;
          }
          if (this._tweening == 2 && this._bouncebackEffect) {
            if (newValue > 20 + threshold1 && this._tweenChange[axis] > 0 || newValue > threshold1 && this._tweenChange[axis] == 0) {
              this._tweenTime[axis] = 0;
              this._tweenDuration[axis] = TWEEN_TIME_DEFAULT;
              this._tweenChange[axis] = -newValue + threshold1;
              this._tweenStart[axis] = newValue;
            } else if (newValue < threshold2 - 20 && this._tweenChange[axis] < 0 || newValue < threshold2 && this._tweenChange[axis] == 0) {
              this._tweenTime[axis] = 0;
              this._tweenDuration[axis] = TWEEN_TIME_DEFAULT;
              this._tweenChange[axis] = threshold2 - newValue;
              this._tweenStart[axis] = newValue;
            }
          } else {
            if (newValue > threshold1) {
              newValue = threshold1;
              this._tweenChange[axis] = 0;
            } else if (newValue < threshold2) {
              newValue = threshold2;
              this._tweenChange[axis] = 0;
            }
          }
        } else
          newValue = axis == "x" ? this._container.position.x : -this._container.position.y;
        return newValue;
      }
    };
    _gestureFlag = 0;
    TWEEN_TIME_GO = 0.5;
    TWEEN_TIME_DEFAULT = 0.3;
    PULL_RATIO = 0.5;
    s_vec2$3 = new import_cc5.Vec2();
    s_rect = new import_cc5.Rect();
    sEndPos = new import_cc5.Vec2();
    sOldChange = new import_cc5.Vec2();
    (function(CurveType2) {
      CurveType2[CurveType2["CRSpline"] = 0] = "CRSpline";
      CurveType2[CurveType2["Bezier"] = 1] = "Bezier";
      CurveType2[CurveType2["CubicBezier"] = 2] = "CubicBezier";
      CurveType2[CurveType2["Straight"] = 3] = "Straight";
    })(CurveType || (CurveType = {}));
    GPathPoint = class _GPathPoint {
      constructor() {
        this.x = 0;
        this.y = 0;
        this.control1_x = 0;
        this.control1_y = 0;
        this.control2_x = 0;
        this.control2_y = 0;
        this.curveType = 0;
      }
      static newPoint(x, y, curveType) {
        var pt = new _GPathPoint();
        pt.x = x || 0;
        pt.y = y || 0;
        pt.control1_x = 0;
        pt.control1_y = 0;
        pt.control2_x = 0;
        pt.control2_y = 0;
        pt.curveType = curveType || CurveType.CRSpline;
        return pt;
      }
      static newBezierPoint(x, y, control1_x, control1_y) {
        var pt = new _GPathPoint();
        pt.x = x || 0;
        pt.y = y || 0;
        pt.control1_x = control1_x || 0;
        pt.control1_y = control1_y || 0;
        pt.control2_x = 0;
        pt.control2_y = 0;
        pt.curveType = CurveType.Bezier;
        return pt;
      }
      static newCubicBezierPoint(x, y, control1_x, control1_y, control2_x, control2_y) {
        var pt = new _GPathPoint();
        pt.x = x || 0;
        pt.y = y || 0;
        pt.control1_x = control1_x || 0;
        pt.control1_y = control1_y || 0;
        pt.control2_x = control2_x || 0;
        pt.control2_y = control2_y || 0;
        pt.curveType = CurveType.CubicBezier;
        return pt;
      }
      clone() {
        var ret = new _GPathPoint();
        ret.x = this.x;
        ret.y = this.y;
        ret.control1_x = this.control1_x;
        ret.control1_y = this.control1_y;
        ret.control2_x = this.control2_x;
        ret.control2_y = this.control2_y;
        ret.curveType = this.curveType;
        return ret;
      }
    };
    GPath = class {
      constructor() {
        this._segments = new Array();
        this._points = new Array();
      }
      get length() {
        return this._fullLength;
      }
      create2(pt1, pt2, pt3, pt4) {
        var points = new Array();
        points.push(pt1);
        points.push(pt2);
        if (pt3)
          points.push(pt3);
        if (pt4)
          points.push(pt4);
        this.create(points);
      }
      create(points) {
        this._segments.length = 0;
        this._points.length = 0;
        this._fullLength = 0;
        var cnt = points.length;
        if (cnt == 0)
          return;
        var splinePoints = [];
        var prev = points[0];
        if (prev.curveType == CurveType.CRSpline)
          splinePoints.push(new import_cc5.Vec2(prev.x, prev.y));
        for (var i = 1; i < cnt; i++) {
          var current = points[i];
          if (prev.curveType != CurveType.CRSpline) {
            var seg = {};
            seg.type = prev.curveType;
            seg.ptStart = this._points.length;
            if (prev.curveType == CurveType.Straight) {
              seg.ptCount = 2;
              this._points.push(new import_cc5.Vec2(prev.x, prev.y));
              this._points.push(new import_cc5.Vec2(current.x, current.y));
            } else if (prev.curveType == CurveType.Bezier) {
              seg.ptCount = 3;
              this._points.push(new import_cc5.Vec2(prev.x, prev.y));
              this._points.push(new import_cc5.Vec2(current.x, current.y));
              this._points.push(new import_cc5.Vec2(prev.control1_x, prev.control1_y));
            } else if (prev.curveType == CurveType.CubicBezier) {
              seg.ptCount = 4;
              this._points.push(new import_cc5.Vec2(prev.x, prev.y));
              this._points.push(new import_cc5.Vec2(current.x, current.y));
              this._points.push(new import_cc5.Vec2(prev.control1_x, prev.control1_y));
              this._points.push(new import_cc5.Vec2(prev.control2_x, prev.control2_y));
            }
            seg.length = distance(prev.x, prev.y, current.x, current.y);
            this._fullLength += seg.length;
            this._segments.push(seg);
          }
          if (current.curveType != CurveType.CRSpline) {
            if (splinePoints.length > 0) {
              splinePoints.push(new import_cc5.Vec2(current.x, current.y));
              this.createSplineSegment(splinePoints);
            }
          } else
            splinePoints.push(new import_cc5.Vec2(current.x, current.y));
          prev = current;
        }
        if (splinePoints.length > 1)
          this.createSplineSegment(splinePoints);
      }
      createSplineSegment(splinePoints) {
        var cnt = splinePoints.length;
        splinePoints.splice(0, 0, splinePoints[0]);
        splinePoints.push(splinePoints[cnt]);
        splinePoints.push(splinePoints[cnt]);
        cnt += 3;
        var seg = {};
        seg.type = CurveType.CRSpline;
        seg.ptStart = this._points.length;
        seg.ptCount = cnt;
        this._points = this._points.concat(splinePoints);
        seg.length = 0;
        for (var i = 1; i < cnt; i++) {
          seg.length += distance(splinePoints[i - 1].x, splinePoints[i - 1].y, splinePoints[i].x, splinePoints[i].y);
        }
        this._fullLength += seg.length;
        this._segments.push(seg);
        splinePoints.length = 0;
      }
      clear() {
        this._segments.length = 0;
        this._points.length = 0;
      }
      getPointAt(t, result) {
        if (!result)
          result = new import_cc5.Vec2();
        else
          result.set(0, 0);
        t = import_cc5.math.clamp01(t);
        var cnt = this._segments.length;
        if (cnt == 0) {
          return result;
        }
        var seg;
        if (t == 1) {
          seg = this._segments[cnt - 1];
          if (seg.type == CurveType.Straight) {
            result.x = import_cc5.math.lerp(this._points[seg.ptStart].x, this._points[seg.ptStart + 1].x, t);
            result.y = import_cc5.math.lerp(this._points[seg.ptStart].y, this._points[seg.ptStart + 1].y, t);
            return result;
          } else if (seg.type == CurveType.Bezier || seg.type == CurveType.CubicBezier)
            return this.onBezierCurve(seg.ptStart, seg.ptCount, t, result);
          else
            return this.onCRSplineCurve(seg.ptStart, seg.ptCount, t, result);
        }
        var len = t * this._fullLength;
        for (var i = 0; i < cnt; i++) {
          seg = this._segments[i];
          len -= seg.length;
          if (len < 0) {
            t = 1 + len / seg.length;
            if (seg.type == CurveType.Straight) {
              result.x = import_cc5.math.lerp(this._points[seg.ptStart].x, this._points[seg.ptStart + 1].x, t);
              result.y = import_cc5.math.lerp(this._points[seg.ptStart].y, this._points[seg.ptStart + 1].y, t);
            } else if (seg.type == CurveType.Bezier || seg.type == CurveType.CubicBezier)
              result = this.onBezierCurve(seg.ptStart, seg.ptCount, t, result);
            else
              result = this.onCRSplineCurve(seg.ptStart, seg.ptCount, t, result);
            break;
          }
        }
        return result;
      }
      get segmentCount() {
        return this._segments.length;
      }
      getAnchorsInSegment(segmentIndex, points) {
        if (points == null)
          points = new Array();
        var seg = this._segments[segmentIndex];
        for (var i = 0; i < seg.ptCount; i++)
          points.push(new import_cc5.Vec2(this._points[seg.ptStart + i].x, this._points[seg.ptStart + i].y));
        return points;
      }
      getPointsInSegment(segmentIndex, t0, t1, points, ts, pointDensity) {
        if (points == null)
          points = new Array();
        if (!pointDensity || isNaN(pointDensity))
          pointDensity = 0.1;
        if (ts)
          ts.push(t0);
        var seg = this._segments[segmentIndex];
        if (seg.type == CurveType.Straight) {
          points.push(new import_cc5.Vec2(import_cc5.math.lerp(this._points[seg.ptStart].x, this._points[seg.ptStart + 1].x, t0), import_cc5.math.lerp(this._points[seg.ptStart].y, this._points[seg.ptStart + 1].y, t0)));
          points.push(new import_cc5.Vec2(import_cc5.math.lerp(this._points[seg.ptStart].x, this._points[seg.ptStart + 1].x, t1), import_cc5.math.lerp(this._points[seg.ptStart].y, this._points[seg.ptStart + 1].y, t1)));
        } else {
          var func;
          if (seg.type == CurveType.Bezier || seg.type == CurveType.CubicBezier)
            func = this.onBezierCurve;
          else
            func = this.onCRSplineCurve;
          points.push(func.call(this, seg.ptStart, seg.ptCount, t0, new import_cc5.Vec2()));
          var SmoothAmount = Math.min(seg.length * pointDensity, 50);
          for (var j = 0; j <= SmoothAmount; j++) {
            var t = j / SmoothAmount;
            if (t > t0 && t < t1) {
              points.push(func.call(this, seg.ptStart, seg.ptCount, t, new import_cc5.Vec2()));
              if (ts)
                ts.push(t);
            }
          }
          points.push(func.call(this, seg.ptStart, seg.ptCount, t1, new import_cc5.Vec2()));
        }
        if (ts)
          ts.push(t1);
        return points;
      }
      getAllPoints(points, ts, pointDensity) {
        if (points == null)
          points = new Array();
        if (!pointDensity || isNaN(pointDensity))
          pointDensity = 0.1;
        var cnt = this._segments.length;
        for (var i = 0; i < cnt; i++)
          this.getPointsInSegment(i, 0, 1, points, ts, pointDensity);
        return points;
      }
      onCRSplineCurve(ptStart, ptCount, t, result) {
        var adjustedIndex = Math.floor(t * (ptCount - 4)) + ptStart;
        var p0x = this._points[adjustedIndex].x;
        var p0y = this._points[adjustedIndex].y;
        var p1x = this._points[adjustedIndex + 1].x;
        var p1y = this._points[adjustedIndex + 1].y;
        var p2x = this._points[adjustedIndex + 2].x;
        var p2y = this._points[adjustedIndex + 2].y;
        var p3x = this._points[adjustedIndex + 3].x;
        var p3y = this._points[adjustedIndex + 3].y;
        var adjustedT = t == 1 ? 1 : import_cc5.math.repeat(t * (ptCount - 4), 1);
        var t0 = ((-adjustedT + 2) * adjustedT - 1) * adjustedT * 0.5;
        var t1 = ((3 * adjustedT - 5) * adjustedT * adjustedT + 2) * 0.5;
        var t2 = ((-3 * adjustedT + 4) * adjustedT + 1) * adjustedT * 0.5;
        var t3 = (adjustedT - 1) * adjustedT * adjustedT * 0.5;
        result.x = p0x * t0 + p1x * t1 + p2x * t2 + p3x * t3;
        result.y = p0y * t0 + p1y * t1 + p2y * t2 + p3y * t3;
        return result;
      }
      onBezierCurve(ptStart, ptCount, t, result) {
        var t2 = 1 - t;
        var p0x = this._points[ptStart].x;
        var p0y = this._points[ptStart].y;
        var p1x = this._points[ptStart + 1].x;
        var p1y = this._points[ptStart + 1].y;
        var cp0x = this._points[ptStart + 2].x;
        var cp0y = this._points[ptStart + 2].y;
        if (ptCount == 4) {
          var cp1x = this._points[ptStart + 3].x;
          var cp1y = this._points[ptStart + 3].y;
          result.x = t2 * t2 * t2 * p0x + 3 * t2 * t2 * t * cp0x + 3 * t2 * t * t * cp1x + t * t * t * p1x;
          result.y = t2 * t2 * t2 * p0y + 3 * t2 * t2 * t * cp0y + 3 * t2 * t * t * cp1y + t * t * t * p1y;
        } else {
          result.x = t2 * t2 * p0x + 2 * t2 * t * cp0x + t * t * p1x;
          result.y = t2 * t2 * p0y + 2 * t2 * t * cp0y + t * t * p1y;
        }
        return result;
      }
    };
    Transition = class {
      constructor(owner) {
        this._ownerBaseX = 0;
        this._ownerBaseY = 0;
        this._totalTimes = 0;
        this._totalTasks = 0;
        this._options = 0;
        this._totalDuration = 0;
        this._autoPlayTimes = 1;
        this._autoPlayDelay = 0;
        this._timeScale = 1;
        this._startTime = 0;
        this._endTime = 0;
        this._owner = owner;
        this._items = new Array();
      }
      play(onComplete, times, delay, startTime, endTime) {
        this._play(onComplete, times, delay, startTime, endTime, false);
      }
      playReverse(onComplete, times, delay) {
        this._play(onComplete, times, delay, 0, -1, true);
      }
      changePlayTimes(value) {
        this._totalTimes = value;
      }
      setAutoPlay(value, times, delay) {
        if (times == void 0)
          times = -1;
        if (delay == void 0)
          delay = 0;
        if (this._autoPlay != value) {
          this._autoPlay = value;
          this._autoPlayTimes = times;
          this._autoPlayDelay = delay;
          if (this._autoPlay) {
            if (this._owner.onStage)
              this.play(null, this._autoPlayTimes, this._autoPlayDelay);
          } else {
            if (!this._owner.onStage)
              this.stop(false, true);
          }
        }
      }
      _play(onComplete, times, delay, startTime, endTime, reversed) {
        if (times == void 0)
          times = 1;
        if (delay == void 0)
          delay = 0;
        if (startTime == void 0)
          startTime = 0;
        if (endTime == void 0)
          endTime = -1;
        this.stop(true, true);
        this._totalTimes = times;
        this._reversed = reversed;
        this._startTime = startTime;
        this._endTime = endTime;
        this._playing = true;
        this._paused = false;
        this._onComplete = onComplete;
        var cnt = this._items.length;
        for (var i = 0; i < cnt; i++) {
          var item = this._items[i];
          if (item.target == null) {
            if (item.targetId)
              item.target = this._owner.getChildById(item.targetId);
            else
              item.target = this._owner;
          } else if (item.target != this._owner && item.target.parent != this._owner)
            item.target = null;
          if (item.target && item.type == ActionType.Transition) {
            var trans = item.target.getTransition(item.value.transName);
            if (trans == this)
              trans = null;
            if (trans) {
              if (item.value.playTimes == 0) {
                var j;
                for (j = i - 1; j >= 0; j--) {
                  var item2 = this._items[j];
                  if (item2.type == ActionType.Transition) {
                    if (item2.value.trans == trans) {
                      item2.value.stopTime = item.time - item2.time;
                      break;
                    }
                  }
                }
                if (j < 0)
                  item.value.stopTime = 0;
                else
                  trans = null;
              } else
                item.value.stopTime = -1;
            }
            item.value.trans = trans;
          }
        }
        if (delay == 0)
          this.onDelayedPlay();
        else
          GTween.delayedCall(delay).setTarget(this).onComplete(this.onDelayedPlay, this);
      }
      stop(setToComplete, processCallback) {
        if (setToComplete == void 0)
          setToComplete = true;
        if (!this._playing)
          return;
        this._playing = false;
        this._totalTasks = 0;
        this._totalTimes = 0;
        var func = this._onComplete;
        this._onComplete = null;
        GTween.kill(this);
        var cnt = this._items.length;
        if (this._reversed) {
          for (var i = cnt - 1; i >= 0; i--) {
            var item = this._items[i];
            if (item.target == null)
              continue;
            this.stopItem(item, setToComplete);
          }
        } else {
          for (i = 0; i < cnt; i++) {
            item = this._items[i];
            if (item.target == null)
              continue;
            this.stopItem(item, setToComplete);
          }
        }
        if (processCallback && func != null) {
          func();
        }
      }
      stopItem(item, setToComplete) {
        if (item.displayLockToken != 0) {
          item.target.releaseDisplayLock(item.displayLockToken);
          item.displayLockToken = 0;
        }
        if (item.tweener) {
          item.tweener.kill(setToComplete);
          item.tweener = null;
          if (item.type == ActionType.Shake && !setToComplete) {
            item.target._gearLocked = true;
            item.target.setPosition(item.target.x - item.value.lastOffsetX, item.target.y - item.value.lastOffsetY);
            item.target._gearLocked = false;
          }
        }
        if (item.type == ActionType.Transition) {
          var trans = item.value.trans;
          if (trans)
            trans.stop(setToComplete, false);
        }
      }
      setPaused(paused) {
        if (!this._playing || this._paused == paused)
          return;
        this._paused = paused;
        var tweener = GTween.getTween(this);
        if (tweener)
          tweener.setPaused(paused);
        var cnt = this._items.length;
        for (var i = 0; i < cnt; i++) {
          var item = this._items[i];
          if (item.target == null)
            continue;
          if (item.type == ActionType.Transition) {
            if (item.value.trans)
              item.value.trans.setPaused(paused);
          } else if (item.type == ActionType.Animation) {
            if (paused) {
              item.value.flag = item.target.getProp(ObjectPropID.Playing);
              item.target.setProp(ObjectPropID.Playing, false);
            } else
              item.target.setProp(ObjectPropID.Playing, item.value.flag);
          }
          if (item.tweener)
            item.tweener.setPaused(paused);
        }
      }
      dispose() {
        if (this._playing)
          GTween.kill(this);
        var cnt = this._items.length;
        for (var i = 0; i < cnt; i++) {
          var item = this._items[i];
          if (item.tweener) {
            item.tweener.kill();
            item.tweener = null;
          }
          item.target = null;
          item.hook = null;
          if (item.tweenConfig)
            item.tweenConfig.endHook = null;
        }
        this._items.length = 0;
        this._playing = false;
        this._onComplete = null;
      }
      get playing() {
        return this._playing;
      }
      setValue(label, ...args) {
        var cnt = this._items.length;
        var value;
        for (var i = 0; i < cnt; i++) {
          var item = this._items[i];
          if (item.label == label) {
            if (item.tweenConfig)
              value = item.tweenConfig.startValue;
            else
              value = item.value;
          } else if (item.tweenConfig && item.tweenConfig.endLabel == label) {
            value = item.tweenConfig.endValue;
          } else
            continue;
          switch (item.type) {
            case ActionType.XY:
            case ActionType.Size:
            case ActionType.Pivot:
            case ActionType.Scale:
            case ActionType.Skew:
              value.b1 = true;
              value.b2 = true;
              value.f1 = parseFloat(args[0]);
              value.f2 = parseFloat(args[1]);
              break;
            case ActionType.Alpha:
              value.f1 = parseFloat(args[0]);
              break;
            case ActionType.Rotation:
              value.f1 = parseFloat(args[0]);
              break;
            case ActionType.Color:
              value.f1 = parseFloat(args[0]);
              break;
            case ActionType.Animation:
              value.frame = parseInt(args[0]);
              if (args.length > 1)
                value.playing = args[1];
              break;
            case ActionType.Visible:
              value.visible = args[0];
              break;
            case ActionType.Sound:
              value.sound = args[0];
              if (args.length > 1)
                value.volume = parseFloat(args[1]);
              break;
            case ActionType.Transition:
              value.transName = args[0];
              if (args.length > 1)
                value.playTimes = parseInt(args[1]);
              break;
            case ActionType.Shake:
              value.amplitude = parseFloat(args[0]);
              if (args.length > 1)
                value.duration = parseFloat(args[1]);
              break;
            case ActionType.ColorFilter:
              value.f1 = parseFloat(args[0]);
              value.f2 = parseFloat(args[1]);
              value.f3 = parseFloat(args[2]);
              value.f4 = parseFloat(args[3]);
              break;
            case ActionType.Text:
            case ActionType.Icon:
              value.text = args[0];
              break;
          }
        }
      }
      setHook(label, callback) {
        var cnt = this._items.length;
        for (var i = 0; i < cnt; i++) {
          var item = this._items[i];
          if (item.label == label) {
            item.hook = callback;
            break;
          } else if (item.tweenConfig && item.tweenConfig.endLabel == label) {
            item.tweenConfig.endHook = callback;
            break;
          }
        }
      }
      clearHooks() {
        var cnt = this._items.length;
        for (var i = 0; i < cnt; i++) {
          var item = this._items[i];
          item.hook = null;
          if (item.tweenConfig)
            item.tweenConfig.endHook = null;
        }
      }
      setTarget(label, newTarget) {
        var cnt = this._items.length;
        for (var i = 0; i < cnt; i++) {
          var item = this._items[i];
          if (item.label == label) {
            item.targetId = newTarget.id;
            item.target = null;
          }
        }
      }
      setDuration(label, value) {
        var cnt = this._items.length;
        for (var i = 0; i < cnt; i++) {
          var item = this._items[i];
          if (item.tweenConfig && item.label == label)
            item.tweenConfig.duration = value;
        }
      }
      getLabelTime(label) {
        var cnt = this._items.length;
        for (var i = 0; i < cnt; i++) {
          var item = this._items[i];
          if (item.label == label)
            return item.time;
          else if (item.tweenConfig && item.tweenConfig.endLabel == label)
            return item.time + item.tweenConfig.duration;
        }
        return Number.NaN;
      }
      get timeScale() {
        return this._timeScale;
      }
      set timeScale(value) {
        if (this._timeScale != value) {
          this._timeScale = value;
          if (this._playing) {
            var cnt = this._items.length;
            for (var i = 0; i < cnt; i++) {
              var item = this._items[i];
              if (item.tweener)
                item.tweener.setTimeScale(value);
              else if (item.type == ActionType.Transition) {
                if (item.value.trans)
                  item.value.trans.timeScale = value;
              } else if (item.type == ActionType.Animation) {
                if (item.target)
                  item.target.setProp(ObjectPropID.TimeScale, value);
              }
            }
          }
        }
      }
      updateFromRelations(targetId, dx, dy) {
        var cnt = this._items.length;
        if (cnt == 0)
          return;
        for (var i = 0; i < cnt; i++) {
          var item = this._items[i];
          if (item.type == ActionType.XY && item.targetId == targetId) {
            if (item.tweenConfig) {
              item.tweenConfig.startValue.f1 += dx;
              item.tweenConfig.startValue.f2 += dy;
              item.tweenConfig.endValue.f1 += dx;
              item.tweenConfig.endValue.f2 += dy;
            } else {
              item.value.f1 += dx;
              item.value.f2 += dy;
            }
          }
        }
      }
      onEnable() {
        if (this._autoPlay && !this._playing)
          this.play(null, this._autoPlayTimes, this._autoPlayDelay);
      }
      onDisable() {
        if ((this._options & OPTION_AUTO_STOP_DISABLED) == 0)
          this.stop((this._options & OPTION_AUTO_STOP_AT_END) != 0 ? true : false, false);
      }
      onDelayedPlay() {
        this.internalPlay();
        this._playing = this._totalTasks > 0;
        if (this._playing) {
          if ((this._options & OPTION_IGNORE_DISPLAY_CONTROLLER) != 0) {
            var cnt = this._items.length;
            for (var i = 0; i < cnt; i++) {
              var item = this._items[i];
              if (item.target && item.target != this._owner)
                item.displayLockToken = item.target.addDisplayLock();
            }
          }
        } else if (this._onComplete != null) {
          var func = this._onComplete;
          this._onComplete = null;
          func();
        }
      }
      internalPlay() {
        this._ownerBaseX = this._owner.x;
        this._ownerBaseY = this._owner.y;
        this._totalTasks = 1;
        var cnt = this._items.length;
        var item;
        var needSkipAnimations = false;
        var i;
        if (!this._reversed) {
          for (i = 0; i < cnt; i++) {
            item = this._items[i];
            if (item.target == null)
              continue;
            if (item.type == ActionType.Animation && this._startTime != 0 && item.time <= this._startTime) {
              needSkipAnimations = true;
              item.value.flag = false;
            } else
              this.playItem(item);
          }
        } else {
          for (i = cnt - 1; i >= 0; i--) {
            item = this._items[i];
            if (item.target == null)
              continue;
            this.playItem(item);
          }
        }
        if (needSkipAnimations)
          this.skipAnimations();
        this._totalTasks--;
      }
      playItem(item) {
        var time;
        if (item.tweenConfig) {
          if (this._reversed)
            time = this._totalDuration - item.time - item.tweenConfig.duration;
          else
            time = item.time;
          if (this._endTime == -1 || time <= this._endTime) {
            var startValue;
            var endValue;
            if (this._reversed) {
              startValue = item.tweenConfig.endValue;
              endValue = item.tweenConfig.startValue;
            } else {
              startValue = item.tweenConfig.startValue;
              endValue = item.tweenConfig.endValue;
            }
            item.value.b1 = startValue.b1 || endValue.b1;
            item.value.b2 = startValue.b2 || endValue.b2;
            switch (item.type) {
              case ActionType.XY:
              case ActionType.Size:
              case ActionType.Scale:
              case ActionType.Skew:
                item.tweener = GTween.to2(startValue.f1, startValue.f2, endValue.f1, endValue.f2, item.tweenConfig.duration);
                break;
              case ActionType.Alpha:
              case ActionType.Rotation:
                item.tweener = GTween.to(startValue.f1, endValue.f1, item.tweenConfig.duration);
                break;
              case ActionType.Color:
                item.tweener = GTween.toColor(startValue.f1, endValue.f1, item.tweenConfig.duration);
                break;
              case ActionType.ColorFilter:
                item.tweener = GTween.to4(startValue.f1, startValue.f2, startValue.f3, startValue.f4, endValue.f1, endValue.f2, endValue.f3, endValue.f4, item.tweenConfig.duration);
                break;
            }
            item.tweener.setDelay(time).setEase(item.tweenConfig.easeType).setRepeat(item.tweenConfig.repeat, item.tweenConfig.yoyo).setTimeScale(this._timeScale).setTarget(item).onStart(this.onTweenStart, this).onUpdate(this.onTweenUpdate, this).onComplete(this.onTweenComplete, this);
            if (this._endTime >= 0)
              item.tweener.setBreakpoint(this._endTime - time);
            this._totalTasks++;
          }
        } else if (item.type == ActionType.Shake) {
          if (this._reversed)
            time = this._totalDuration - item.time - item.value.duration;
          else
            time = item.time;
          item.value.offsetX = item.value.offsetY = 0;
          item.value.lastOffsetX = item.value.lastOffsetY = 0;
          item.tweener = GTween.shake(0, 0, item.value.amplitude, item.value.duration).setDelay(time).setTimeScale(this._timeScale).setTarget(item).onUpdate(this.onTweenUpdate, this).onComplete(this.onTweenComplete, this);
          if (this._endTime >= 0)
            item.tweener.setBreakpoint(this._endTime - item.time);
          this._totalTasks++;
        } else {
          if (this._reversed)
            time = this._totalDuration - item.time;
          else
            time = item.time;
          if (time <= this._startTime) {
            this.applyValue(item);
            this.callHook(item, false);
          } else if (this._endTime == -1 || time <= this._endTime) {
            this._totalTasks++;
            item.tweener = GTween.delayedCall(time).setTimeScale(this._timeScale).setTarget(item).onComplete(this.onDelayedPlayItem, this);
          }
        }
        if (item.tweener)
          item.tweener.seek(this._startTime);
      }
      skipAnimations() {
        var frame;
        var playStartTime;
        var playTotalTime;
        var value;
        var target;
        var item;
        var cnt = this._items.length;
        for (var i = 0; i < cnt; i++) {
          item = this._items[i];
          if (item.type != ActionType.Animation || item.time > this._startTime)
            continue;
          value = item.value;
          if (value.flag)
            continue;
          target = item.target;
          frame = target.getProp(ObjectPropID.Frame);
          playStartTime = target.getProp(ObjectPropID.Playing) ? 0 : -1;
          playTotalTime = 0;
          for (var j = i; j < cnt; j++) {
            item = this._items[j];
            if (item.type != ActionType.Animation || item.target != target || item.time > this._startTime)
              continue;
            value = item.value;
            value.flag = true;
            if (value.frame != -1) {
              frame = value.frame;
              if (value.playing)
                playStartTime = item.time;
              else
                playStartTime = -1;
              playTotalTime = 0;
            } else {
              if (value.playing) {
                if (playStartTime < 0)
                  playStartTime = item.time;
              } else {
                if (playStartTime >= 0)
                  playTotalTime += item.time - playStartTime;
                playStartTime = -1;
              }
            }
            this.callHook(item, false);
          }
          if (playStartTime >= 0)
            playTotalTime += this._startTime - playStartTime;
          target.setProp(ObjectPropID.Playing, playStartTime >= 0);
          target.setProp(ObjectPropID.Frame, frame);
          if (playTotalTime > 0)
            target.setProp(ObjectPropID.DeltaTime, playTotalTime);
        }
      }
      onDelayedPlayItem(tweener) {
        var item = tweener.target;
        item.tweener = null;
        this._totalTasks--;
        this.applyValue(item);
        this.callHook(item, false);
        this.checkAllComplete();
      }
      onTweenStart(tweener) {
        var item = tweener.target;
        if (item.type == ActionType.XY || item.type == ActionType.Size) {
          var startValue;
          var endValue;
          if (this._reversed) {
            startValue = item.tweenConfig.endValue;
            endValue = item.tweenConfig.startValue;
          } else {
            startValue = item.tweenConfig.startValue;
            endValue = item.tweenConfig.endValue;
          }
          if (item.type == ActionType.XY) {
            if (item.target != this._owner) {
              if (!startValue.b1)
                tweener.startValue.x = item.target.x;
              else if (startValue.b3)
                tweener.startValue.x = startValue.f1 * this._owner.width;
              if (!startValue.b2)
                tweener.startValue.y = item.target.y;
              else if (startValue.b3)
                tweener.startValue.y = startValue.f2 * this._owner.height;
              if (!endValue.b1)
                tweener.endValue.x = tweener.startValue.x;
              else if (endValue.b3)
                tweener.endValue.x = endValue.f1 * this._owner.width;
              if (!endValue.b2)
                tweener.endValue.y = tweener.startValue.y;
              else if (endValue.b3)
                tweener.endValue.y = endValue.f2 * this._owner.height;
            } else {
              if (!startValue.b1)
                tweener.startValue.x = item.target.x - this._ownerBaseX;
              if (!startValue.b2)
                tweener.startValue.y = item.target.y - this._ownerBaseY;
              if (!endValue.b1)
                tweener.endValue.x = tweener.startValue.x;
              if (!endValue.b2)
                tweener.endValue.y = tweener.startValue.y;
            }
          } else {
            if (!startValue.b1)
              tweener.startValue.x = item.target.width;
            if (!startValue.b2)
              tweener.startValue.y = item.target.height;
            if (!endValue.b1)
              tweener.endValue.x = tweener.startValue.x;
            if (!endValue.b2)
              tweener.endValue.y = tweener.startValue.y;
          }
          if (item.tweenConfig.path) {
            item.value.b1 = item.value.b2 = true;
            tweener.setPath(item.tweenConfig.path);
          }
        }
        this.callHook(item, false);
      }
      onTweenUpdate(tweener) {
        var item = tweener.target;
        switch (item.type) {
          case ActionType.XY:
          case ActionType.Size:
          case ActionType.Scale:
          case ActionType.Skew:
            item.value.f1 = tweener.value.x;
            item.value.f2 = tweener.value.y;
            if (item.tweenConfig.path) {
              item.value.f1 += tweener.startValue.x;
              item.value.f2 += tweener.startValue.y;
            }
            break;
          case ActionType.Alpha:
          case ActionType.Rotation:
            item.value.f1 = tweener.value.x;
            break;
          case ActionType.Color:
            item.value.f1 = tweener.value.color;
            break;
          case ActionType.ColorFilter:
            item.value.f1 = tweener.value.x;
            item.value.f2 = tweener.value.y;
            item.value.f3 = tweener.value.z;
            item.value.f4 = tweener.value.w;
            break;
          case ActionType.Shake:
            item.value.offsetX = tweener.deltaValue.x;
            item.value.offsetY = tweener.deltaValue.y;
            break;
        }
        this.applyValue(item);
      }
      onTweenComplete(tweener) {
        var item = tweener.target;
        item.tweener = null;
        this._totalTasks--;
        if (tweener.allCompleted)
          this.callHook(item, true);
        this.checkAllComplete();
      }
      onPlayTransCompleted(item) {
        this._totalTasks--;
        this.checkAllComplete();
      }
      callHook(item, tweenEnd) {
        if (tweenEnd) {
          if (item.tweenConfig && item.tweenConfig.endHook != null)
            item.tweenConfig.endHook(item.label);
        } else {
          if (item.time >= this._startTime && item.hook != null)
            item.hook(item.label);
        }
      }
      checkAllComplete() {
        if (this._playing && this._totalTasks == 0) {
          if (this._totalTimes < 0) {
            this.internalPlay();
            if (this._totalTasks == 0)
              GTween.delayedCall(0).setTarget(this).onComplete(this.checkAllComplete, this);
          } else {
            this._totalTimes--;
            if (this._totalTimes > 0) {
              this.internalPlay();
              if (this._totalTasks == 0)
                GTween.delayedCall(0).setTarget(this).onComplete(this.checkAllComplete, this);
            } else {
              this._playing = false;
              var cnt = this._items.length;
              for (var i = 0; i < cnt; i++) {
                var item = this._items[i];
                if (item.target && item.displayLockToken != 0) {
                  item.target.releaseDisplayLock(item.displayLockToken);
                  item.displayLockToken = 0;
                }
              }
              if (this._onComplete != null) {
                var func = this._onComplete;
                this._onComplete = null;
                func();
              }
            }
          }
        }
      }
      applyValue(item) {
        item.target._gearLocked = true;
        var value = item.value;
        switch (item.type) {
          case ActionType.XY:
            if (item.target == this._owner) {
              if (value.b1 && value.b2)
                item.target.setPosition(value.f1 + this._ownerBaseX, value.f2 + this._ownerBaseY);
              else if (value.b1)
                item.target.x = value.f1 + this._ownerBaseX;
              else
                item.target.y = value.f2 + this._ownerBaseY;
            } else {
              if (value.b3) {
                if (value.b1 && value.b2)
                  item.target.setPosition(value.f1 * this._owner.width, value.f2 * this._owner.height);
                else if (value.b1)
                  item.target.x = value.f1 * this._owner.width;
                else if (value.b2)
                  item.target.y = value.f2 * this._owner.height;
              } else {
                if (value.b1 && value.b2)
                  item.target.setPosition(value.f1, value.f2);
                else if (value.b1)
                  item.target.x = value.f1;
                else if (value.b2)
                  item.target.y = value.f2;
              }
            }
            break;
          case ActionType.Size:
            if (!value.b1)
              value.f1 = item.target.width;
            if (!value.b2)
              value.f2 = item.target.height;
            item.target.setSize(value.f1, value.f2);
            break;
          case ActionType.Pivot:
            item.target.setPivot(value.f1, value.f2, item.target.pivotAsAnchor);
            break;
          case ActionType.Alpha:
            item.target.alpha = value.f1;
            break;
          case ActionType.Rotation:
            item.target.rotation = value.f1;
            break;
          case ActionType.Scale:
            item.target.setScale(value.f1, value.f2);
            break;
          case ActionType.Skew:
            break;
          case ActionType.Color:
            let color = item.target.getProp(ObjectPropID.Color);
            if (color instanceof import_cc5.Color) {
              let i = Math.floor(value.f1);
              color.r = i >> 16 & 255;
              color.g = i >> 8 & 255;
              color.b = i & 255;
              item.target.setProp(ObjectPropID.Color, color);
            }
            break;
          case ActionType.Animation:
            if (value.frame >= 0)
              item.target.setProp(ObjectPropID.Frame, value.frame);
            item.target.setProp(ObjectPropID.Playing, value.playing);
            item.target.setProp(ObjectPropID.TimeScale, this._timeScale);
            break;
          case ActionType.Visible:
            item.target.visible = value.visible;
            break;
          case ActionType.Transition:
            if (this._playing) {
              var trans = value.trans;
              if (trans) {
                this._totalTasks++;
                var startTime = this._startTime > item.time ? this._startTime - item.time : 0;
                var endTime = this._endTime >= 0 ? this._endTime - item.time : -1;
                if (value.stopTime >= 0 && (endTime < 0 || endTime > value.stopTime))
                  endTime = value.stopTime;
                trans.timeScale = this._timeScale;
                let localThis = this;
                trans._play(() => {
                  localThis.onPlayTransCompleted(item);
                }, value.playTimes, 0, startTime, endTime, this._reversed);
              }
            }
            break;
          case ActionType.Sound:
            if (this._playing && item.time >= this._startTime) {
              if (value.audioClip == null) {
                var pi = UIPackage.getItemByURL(value.sound);
                if (pi)
                  value.audioClip = pi.owner.getItemAsset(pi);
              }
              if (value.audioClip)
                Decls$1.GRoot.inst.playOneShotSound(value.audioClip, value.volume);
            }
            break;
          case ActionType.Shake:
            item.target.setPosition(item.target.x - value.lastOffsetX + value.offsetX, item.target.y - value.lastOffsetY + value.offsetY);
            value.lastOffsetX = value.offsetX;
            value.lastOffsetY = value.offsetY;
            break;
          case ActionType.ColorFilter: {
            break;
          }
          case ActionType.Text:
            item.target.text = value.text;
            break;
          case ActionType.Icon:
            item.target.icon = value.text;
            break;
        }
        item.target._gearLocked = false;
      }
      setup(buffer) {
        this.name = buffer.readS();
        this._options = buffer.readInt();
        this._autoPlay = buffer.readBool();
        this._autoPlayTimes = buffer.readInt();
        this._autoPlayDelay = buffer.readFloat();
        var cnt = buffer.readShort();
        for (var i = 0; i < cnt; i++) {
          var dataLen = buffer.readShort();
          var curPos = buffer.position;
          buffer.seek(curPos, 0);
          var item = new Item(buffer.readByte());
          this._items[i] = item;
          item.time = buffer.readFloat();
          var targetId = buffer.readShort();
          if (targetId < 0)
            item.targetId = "";
          else
            item.targetId = this._owner.getChildAt(targetId).id;
          item.label = buffer.readS();
          if (buffer.readBool()) {
            buffer.seek(curPos, 1);
            item.tweenConfig = new TweenConfig();
            item.tweenConfig.duration = buffer.readFloat();
            if (item.time + item.tweenConfig.duration > this._totalDuration)
              this._totalDuration = item.time + item.tweenConfig.duration;
            item.tweenConfig.easeType = buffer.readByte();
            item.tweenConfig.repeat = buffer.readInt();
            item.tweenConfig.yoyo = buffer.readBool();
            item.tweenConfig.endLabel = buffer.readS();
            buffer.seek(curPos, 2);
            this.decodeValue(item, buffer, item.tweenConfig.startValue);
            buffer.seek(curPos, 3);
            this.decodeValue(item, buffer, item.tweenConfig.endValue);
            if (buffer.version >= 2) {
              var pathLen = buffer.readInt();
              if (pathLen > 0) {
                item.tweenConfig.path = new GPath();
                var pts = new Array();
                for (var j = 0; j < pathLen; j++) {
                  var curveType = buffer.readByte();
                  switch (curveType) {
                    case CurveType.Bezier:
                      pts.push(GPathPoint.newBezierPoint(buffer.readFloat(), buffer.readFloat(), buffer.readFloat(), buffer.readFloat()));
                      break;
                    case CurveType.CubicBezier:
                      pts.push(GPathPoint.newCubicBezierPoint(buffer.readFloat(), buffer.readFloat(), buffer.readFloat(), buffer.readFloat(), buffer.readFloat(), buffer.readFloat()));
                      break;
                    default:
                      pts.push(GPathPoint.newPoint(buffer.readFloat(), buffer.readFloat(), curveType));
                      break;
                  }
                }
                item.tweenConfig.path.create(pts);
              }
            }
          } else {
            if (item.time > this._totalDuration)
              this._totalDuration = item.time;
            buffer.seek(curPos, 2);
            this.decodeValue(item, buffer, item.value);
          }
          buffer.position = curPos + dataLen;
        }
      }
      decodeValue(item, buffer, value) {
        switch (item.type) {
          case ActionType.XY:
          case ActionType.Size:
          case ActionType.Pivot:
          case ActionType.Skew:
            value.b1 = buffer.readBool();
            value.b2 = buffer.readBool();
            value.f1 = buffer.readFloat();
            value.f2 = buffer.readFloat();
            if (buffer.version >= 2 && item.type == ActionType.XY)
              value.b3 = buffer.readBool();
            break;
          case ActionType.Alpha:
          case ActionType.Rotation:
            value.f1 = buffer.readFloat();
            break;
          case ActionType.Scale:
            value.f1 = buffer.readFloat();
            value.f2 = buffer.readFloat();
            break;
          case ActionType.Color:
            let color = buffer.readColor();
            value.f1 = (color.r << 16) + (color.g << 8) + color.b;
            break;
          case ActionType.Animation:
            value.playing = buffer.readBool();
            value.frame = buffer.readInt();
            break;
          case ActionType.Visible:
            value.visible = buffer.readBool();
            break;
          case ActionType.Sound:
            value.sound = buffer.readS();
            value.volume = buffer.readFloat();
            break;
          case ActionType.Transition:
            value.transName = buffer.readS();
            value.playTimes = buffer.readInt();
            break;
          case ActionType.Shake:
            value.amplitude = buffer.readFloat();
            value.duration = buffer.readFloat();
            break;
          case ActionType.ColorFilter:
            value.f1 = buffer.readFloat();
            value.f2 = buffer.readFloat();
            value.f3 = buffer.readFloat();
            value.f4 = buffer.readFloat();
            break;
          case ActionType.Text:
          case ActionType.Icon:
            value.text = buffer.readS();
            break;
        }
      }
      copyFrom(source, applyBaseValue = true) {
        let cnt = source._items.length;
        this.name = source.name;
        this._options = source._options;
        this._autoPlay = source._autoPlay;
        this._autoPlayTimes = source._autoPlayTimes;
        this._autoPlayDelay = source._autoPlayDelay;
        this._totalDuration = source._totalDuration;
        for (let i = 0; i < cnt; i++) {
          let item = source._items[i].clone();
          if (applyBaseValue) {
            let config = item.tweenConfig;
            let rawConfig = source._items[i].tweenConfig;
            if (config) {
              if (item.type == ActionType.Scale) {
                if (config.startValue) {
                  config.startValue.f1 = rawConfig.startValue.f1 * this._owner.scaleX;
                  config.startValue.f2 = rawConfig.startValue.f2 * this._owner.scaleY;
                }
                if (config.endValue) {
                  config.endValue.f1 = rawConfig.endValue.f1 * this._owner.scaleX;
                  config.endValue.f2 = rawConfig.endValue.f2 * this._owner.scaleY;
                }
              } else if (item.type == ActionType.Alpha) {
                if (config.startValue) {
                  config.startValue.f1 = rawConfig.startValue.f1 * this._owner.alpha;
                }
                if (config.endValue) {
                  config.endValue.f1 = rawConfig.endValue.f1 * this._owner.alpha;
                }
              }
            }
          }
          this._items.push(item);
        }
      }
    };
    OPTION_IGNORE_DISPLAY_CONTROLLER = 1;
    OPTION_AUTO_STOP_DISABLED = 2;
    OPTION_AUTO_STOP_AT_END = 4;
    (function(ActionType2) {
      ActionType2[ActionType2["XY"] = 0] = "XY";
      ActionType2[ActionType2["Size"] = 1] = "Size";
      ActionType2[ActionType2["Scale"] = 2] = "Scale";
      ActionType2[ActionType2["Pivot"] = 3] = "Pivot";
      ActionType2[ActionType2["Alpha"] = 4] = "Alpha";
      ActionType2[ActionType2["Rotation"] = 5] = "Rotation";
      ActionType2[ActionType2["Color"] = 6] = "Color";
      ActionType2[ActionType2["Animation"] = 7] = "Animation";
      ActionType2[ActionType2["Visible"] = 8] = "Visible";
      ActionType2[ActionType2["Sound"] = 9] = "Sound";
      ActionType2[ActionType2["Transition"] = 10] = "Transition";
      ActionType2[ActionType2["Shake"] = 11] = "Shake";
      ActionType2[ActionType2["ColorFilter"] = 12] = "ColorFilter";
      ActionType2[ActionType2["Skew"] = 13] = "Skew";
      ActionType2[ActionType2["Text"] = 14] = "Text";
      ActionType2[ActionType2["Icon"] = 15] = "Icon";
      ActionType2[ActionType2["Unknown"] = 16] = "Unknown";
    })(ActionType || (ActionType = {}));
    Item = class _Item {
      constructor(type) {
        this.type = type;
        this.value = {};
        this.displayLockToken = 0;
      }
      clone() {
        let item = new _Item(this.type);
        item.time = this.time;
        item.targetId = this.targetId;
        if (this.tweenConfig)
          item.tweenConfig = this.tweenConfig.clone();
        item.label = this.label;
        item.value = Object.assign({}, this.value);
        return item;
      }
    };
    TweenConfig = class _TweenConfig {
      constructor() {
        this.easeType = EaseType.QuadOut;
        this.startValue = { b1: true, b2: true };
        this.endValue = { b1: true, b2: true };
      }
      clone() {
        let keys = Object.keys(this);
        let tc = new _TweenConfig();
        for (let i = 0; i < keys.length; i++) {
          let k = keys[i];
          let value = this[k];
          if (value == null) {
            continue;
          }
          if (k == "endHook") {
            continue;
          }
          if (typeof value == "object") {
            value = Object.assign({}, value);
          }
          tc[k] = value;
        }
        return tc;
      }
    };
    GComponent = class _GComponent extends GObject {
      constructor() {
        super();
        this._sortingChildCount = 0;
        this._childrenRenderOrder = ChildrenRenderOrder.Ascent;
        this._apexIndex = 0;
        this._invertedMask = false;
        this._excludeInvisibles = false;
        this._node.name = "GComponent";
        this._children = new Array();
        this._controllers = new Array();
        this._transitions = new Array();
        this._margin = new Margin();
        this._alignOffset = new import_cc5.Vec2();
        this._container = new import_cc5.Node("Container");
        this._container.layer = UIConfig.defaultUILayer;
        this._container.addComponent(import_cc5.UITransform).setAnchorPoint(0, 1);
        this._node.addChild(this._container);
      }
      get excludeInvisibles() {
        return this._excludeInvisibles;
      }
      set excludeInvisibles(value) {
        if (this._excludeInvisibles != value) {
          this._excludeInvisibles = value;
          this.setBoundsChangedFlag();
        }
      }
      dispose() {
        var i;
        var cnt;
        cnt = this._transitions.length;
        for (i = 0; i < cnt; ++i) {
          var trans = this._transitions[i];
          trans.dispose();
        }
        cnt = this._controllers.length;
        for (i = 0; i < cnt; ++i) {
          var cc = this._controllers[i];
          cc.dispose();
        }
        if (this._scrollPane)
          this._scrollPane.destroy();
        cnt = this._children.length;
        for (i = cnt - 1; i >= 0; --i) {
          var obj = this._children[i];
          obj._parent = null;
          obj.dispose();
        }
        this._boundsChanged = false;
        super.dispose();
      }
      get displayListContainer() {
        return this._container;
      }
      addChild(child) {
        this.addChildAt(child, this._children.length);
        return child;
      }
      addChildAt(child, index) {
        if (!child)
          throw "child is null";
        var numChildren = this._children.length;
        if (index >= 0 && index <= numChildren) {
          if (child.parent == this) {
            this.setChildIndex(child, index);
          } else {
            child.removeFromParent();
            child._parent = this;
            var cnt = this._children.length;
            if (child.sortingOrder != 0) {
              this._sortingChildCount++;
              index = this.getInsertPosForSortingChild(child);
            } else if (this._sortingChildCount > 0) {
              if (index > cnt - this._sortingChildCount)
                index = cnt - this._sortingChildCount;
            }
            if (index == cnt)
              this._children.push(child);
            else
              this._children.splice(index, 0, child);
            this.onChildAdd(child, index);
            this.setBoundsChangedFlag();
          }
          return child;
        } else {
          throw "Invalid child index";
        }
      }
      getInsertPosForSortingChild(target) {
        var cnt = this._children.length;
        var i = 0;
        for (i = 0; i < cnt; i++) {
          var child = this._children[i];
          if (child == target)
            continue;
          if (target.sortingOrder < child.sortingOrder)
            break;
        }
        return i;
      }
      removeChild(child, dispose) {
        var childIndex = this._children.indexOf(child);
        if (childIndex != -1) {
          this.removeChildAt(childIndex, dispose);
        }
        return child;
      }
      removeChildAt(index, dispose) {
        if (index >= 0 && index < this.numChildren) {
          var child = this._children[index];
          child._parent = null;
          if (child.sortingOrder != 0)
            this._sortingChildCount--;
          this._children.splice(index, 1);
          child.group = null;
          this._container.removeChild(child.node);
          if (this._childrenRenderOrder == ChildrenRenderOrder.Arch)
            this._partner.callLater(this.buildNativeDisplayList);
          if (dispose)
            child.dispose();
          else
            child.node.parent = null;
          this.setBoundsChangedFlag();
          return child;
        } else {
          throw "Invalid child index";
        }
      }
      removeChildren(beginIndex, endIndex, dispose) {
        if (beginIndex == void 0)
          beginIndex = 0;
        if (endIndex == void 0)
          endIndex = -1;
        if (endIndex < 0 || endIndex >= this.numChildren)
          endIndex = this.numChildren - 1;
        for (var i = beginIndex; i <= endIndex; ++i)
          this.removeChildAt(beginIndex, dispose);
      }
      getChildAt(index, classType) {
        if (index >= 0 && index < this.numChildren)
          return this._children[index];
        else
          throw "Invalid child index";
      }
      getChild(name, classType) {
        var cnt = this._children.length;
        for (var i = 0; i < cnt; ++i) {
          if (this._children[i].name == name)
            return this._children[i];
        }
        return null;
      }
      getChildByPath(path4, classType) {
        var arr = path4.split(".");
        var cnt = arr.length;
        var gcom = this;
        var obj;
        for (var i = 0; i < cnt; ++i) {
          obj = gcom.getChild(arr[i]);
          if (!obj)
            break;
          if (i != cnt - 1) {
            if (!(obj instanceof _GComponent)) {
              obj = null;
              break;
            } else
              gcom = obj;
          }
        }
        return obj;
      }
      getVisibleChild(name) {
        var cnt = this._children.length;
        for (var i = 0; i < cnt; ++i) {
          var child = this._children[i];
          if (child._finalVisible && child.name == name)
            return child;
        }
        return null;
      }
      getChildInGroup(name, group) {
        var cnt = this._children.length;
        for (var i = 0; i < cnt; ++i) {
          var child = this._children[i];
          if (child.group == group && child.name == name)
            return child;
        }
        return null;
      }
      getChildById(id) {
        var cnt = this._children.length;
        for (var i = 0; i < cnt; ++i) {
          if (this._children[i]._id == id)
            return this._children[i];
        }
        return null;
      }
      getChildIndex(child) {
        return this._children.indexOf(child);
      }
      setChildIndex(child, index) {
        var oldIndex = this._children.indexOf(child);
        if (oldIndex == -1)
          throw "Not a child of this container";
        if (child.sortingOrder != 0)
          return;
        var cnt = this._children.length;
        if (this._sortingChildCount > 0) {
          if (index > cnt - this._sortingChildCount - 1)
            index = cnt - this._sortingChildCount - 1;
        }
        this._setChildIndex(child, oldIndex, index);
      }
      setChildIndexBefore(child, index) {
        var oldIndex = this._children.indexOf(child);
        if (oldIndex == -1)
          throw "Not a child of this container";
        if (child.sortingOrder != 0)
          return oldIndex;
        var cnt = this._children.length;
        if (this._sortingChildCount > 0) {
          if (index > cnt - this._sortingChildCount - 1)
            index = cnt - this._sortingChildCount - 1;
        }
        if (oldIndex < index)
          return this._setChildIndex(child, oldIndex, index - 1);
        else
          return this._setChildIndex(child, oldIndex, index);
      }
      _setChildIndex(child, oldIndex, index) {
        var cnt = this._children.length;
        if (index > cnt)
          index = cnt;
        if (oldIndex == index)
          return oldIndex;
        this._children.splice(oldIndex, 1);
        this._children.splice(index, 0, child);
        if (this._childrenRenderOrder == ChildrenRenderOrder.Ascent)
          child.node.setSiblingIndex(index);
        else if (this._childrenRenderOrder == ChildrenRenderOrder.Descent)
          child.node.setSiblingIndex(cnt - index);
        else
          this._partner.callLater(this.buildNativeDisplayList);
        this.setBoundsChangedFlag();
        return index;
      }
      swapChildren(child1, child2) {
        var index1 = this._children.indexOf(child1);
        var index2 = this._children.indexOf(child2);
        if (index1 == -1 || index2 == -1)
          throw "Not a child of this container";
        this.swapChildrenAt(index1, index2);
      }
      swapChildrenAt(index1, index2) {
        var child1 = this._children[index1];
        var child2 = this._children[index2];
        this.setChildIndex(child1, index2);
        this.setChildIndex(child2, index1);
      }
      get numChildren() {
        return this._children.length;
      }
      isAncestorOf(child) {
        if (child == null)
          return false;
        var p = child.parent;
        while (p) {
          if (p == this)
            return true;
          p = p.parent;
        }
        return false;
      }
      addController(controller) {
        this._controllers.push(controller);
        controller.parent = this;
        this.applyController(controller);
      }
      getControllerAt(index) {
        return this._controllers[index];
      }
      getController(name) {
        var cnt = this._controllers.length;
        for (var i = 0; i < cnt; ++i) {
          var c = this._controllers[i];
          if (c.name == name)
            return c;
        }
        return null;
      }
      removeController(c) {
        var index = this._controllers.indexOf(c);
        if (index == -1)
          throw "controller not exists";
        c.parent = null;
        this._controllers.splice(index, 1);
        var length = this._children.length;
        for (var i = 0; i < length; i++) {
          var child = this._children[i];
          child.handleControllerChanged(c);
        }
      }
      get controllers() {
        return this._controllers;
      }
      onChildAdd(child, index) {
        if (!child.node) {
          console.error("child.node is null");
          return;
        }
        child.node.parent = this._container;
        child.node.active = child._finalVisible;
        if (this._buildingDisplayList)
          return;
        let cnt = this._children.length;
        if (this._childrenRenderOrder == ChildrenRenderOrder.Ascent)
          child.node.setSiblingIndex(index);
        else if (this._childrenRenderOrder == ChildrenRenderOrder.Descent)
          child.node.setSiblingIndex(cnt - index);
        else
          this._partner.callLater(this.buildNativeDisplayList);
      }
      buildNativeDisplayList(dt) {
        if (!isNaN(dt)) {
          let _t = GObject.cast(this.node);
          _t.buildNativeDisplayList();
          return;
        }
        let cnt = this._children.length;
        if (cnt == 0)
          return;
        let child;
        switch (this._childrenRenderOrder) {
          case ChildrenRenderOrder.Ascent:
            {
              let j = 0;
              for (let i = 0; i < cnt; i++) {
                child = this._children[i];
                child.node.setSiblingIndex(j++);
              }
            }
            break;
          case ChildrenRenderOrder.Descent:
            {
              let j = 0;
              for (let i = cnt - 1; i >= 0; i--) {
                child = this._children[i];
                child.node.setSiblingIndex(j++);
              }
            }
            break;
          case ChildrenRenderOrder.Arch:
            {
              let j = 0;
              for (let i = 0; i < this._apexIndex; i++) {
                child = this._children[i];
                child.node.setSiblingIndex(j++);
              }
              for (let i = cnt - 1; i >= this._apexIndex; i--) {
                child = this._children[i];
                child.node.setSiblingIndex(j++);
              }
            }
            break;
        }
      }
      applyController(c) {
        this._applyingController = c;
        var child;
        var length = this._children.length;
        for (var i = 0; i < length; i++) {
          child = this._children[i];
          child.handleControllerChanged(c);
        }
        this._applyingController = null;
        c.runActions();
      }
      applyAllControllers() {
        var cnt = this._controllers.length;
        for (var i = 0; i < cnt; ++i) {
          this.applyController(this._controllers[i]);
        }
      }
      adjustRadioGroupDepth(obj, c) {
        var cnt = this._children.length;
        var i;
        var child;
        var myIndex = -1, maxIndex = -1;
        for (i = 0; i < cnt; i++) {
          child = this._children[i];
          if (child == obj) {
            myIndex = i;
          } else if ("relatedController" in child && child.relatedController == c) {
            if (i > maxIndex)
              maxIndex = i;
          }
        }
        if (myIndex < maxIndex) {
          if (this._applyingController)
            this._children[maxIndex].handleControllerChanged(this._applyingController);
          this.swapChildrenAt(myIndex, maxIndex);
        }
      }
      getTransitionAt(index) {
        return this._transitions[index];
      }
      getTransition(transName) {
        var cnt = this._transitions.length;
        for (var i = 0; i < cnt; ++i) {
          var trans = this._transitions[i];
          if (trans.name == transName)
            return trans;
        }
        return null;
      }
      isChildInView(child) {
        if (this._rectMask) {
          return child.x + child.width >= 0 && child.x <= this.width && child.y + child.height >= 0 && child.y <= this.height;
        } else if (this._scrollPane) {
          return this._scrollPane.isChildInView(child);
        } else
          return true;
      }
      getFirstChildInView() {
        var cnt = this._children.length;
        for (var i = 0; i < cnt; ++i) {
          var child = this._children[i];
          if (this.isChildInView(child))
            return i;
        }
        return -1;
      }
      get scrollPane() {
        return this._scrollPane;
      }
      get opaque() {
        return this._opaque;
      }
      set opaque(value) {
        this._opaque = value;
      }
      get margin() {
        return this._margin;
      }
      set margin(value) {
        this._margin.copy(value);
        this.handleSizeChanged();
      }
      get childrenRenderOrder() {
        return this._childrenRenderOrder;
      }
      set childrenRenderOrder(value) {
        if (this._childrenRenderOrder != value) {
          this._childrenRenderOrder = value;
          this.buildNativeDisplayList();
        }
      }
      get apexIndex() {
        return this._apexIndex;
      }
      set apexIndex(value) {
        if (this._apexIndex != value) {
          this._apexIndex = value;
          if (this._childrenRenderOrder == ChildrenRenderOrder.Arch)
            this.buildNativeDisplayList();
        }
      }
      get mask() {
        return this._maskContent;
      }
      set mask(value) {
        this.setMask(value, false);
      }
      setMask(value, inverted) {
        if (this._maskContent) {
          this._maskContent.node.off(import_cc5.Node.EventType.TRANSFORM_CHANGED, this.onMaskContentChanged, this);
          this._maskContent.node.off(import_cc5.Node.EventType.SIZE_CHANGED, this.onMaskContentChanged, this);
          this._maskContent.node.off(import_cc5.Node.EventType.ANCHOR_CHANGED, this.onMaskContentChanged, this);
          this._maskContent.visible = true;
        }
        this._maskContent = value;
        if (this._maskContent) {
          if (!(value instanceof GImage) && !(value instanceof GGraph))
            return;
          if (!this._customMask) {
            let maskNode = new import_cc5.Node("Mask");
            maskNode.layer = UIConfig.defaultUILayer;
            maskNode.addComponent(import_cc5.UITransform);
            maskNode.parent = this._node;
            if (this._scrollPane)
              this._container.parent.parent = maskNode;
            else
              this._container.parent = maskNode;
            this._customMask = maskNode.addComponent(import_cc5.Mask);
          }
          value.visible = false;
          value.node.on(import_cc5.Node.EventType.TRANSFORM_CHANGED, this.onMaskContentChanged, this);
          value.node.on(import_cc5.Node.EventType.SIZE_CHANGED, this.onMaskContentChanged, this);
          value.node.on(import_cc5.Node.EventType.ANCHOR_CHANGED, this.onMaskContentChanged, this);
          this._invertedMask = inverted;
          if (UIConfig.enableDelayLoad && this._maskContent instanceof GImage && !this._maskContent._content.spriteFrame) {
            this._maskContent.onReady = this.onMaskContentReady.bind(this);
          } else {
            this.onMaskContentReady();
          }
        } else if (this._customMask) {
          if (this._scrollPane)
            this._container.parent.parent = this._node;
          else
            this._container.parent = this._node;
          this._customMask.node.destroy();
          this._customMask = null;
          if (this._scrollPane)
            this._scrollPane.adjustMaskContainer();
          else
            this._container.setPosition(this._pivotCorrectX, this._pivotCorrectY);
        }
      }
      onMaskContentReady() {
        if (this._node.activeInHierarchy)
          this.onMaskReady();
        else
          this.on(Event.DISPLAY, this.onMaskReady, this);
        this.onMaskContentChanged();
        if (this._scrollPane)
          this._scrollPane.adjustMaskContainer();
        else
          this._container.setPosition(0, 0);
      }
      onMaskReady() {
        this.off(Event.DISPLAY, this.onMaskReady, this);
        if (this._maskContent instanceof GImage) {
          this._customMask.type = import_cc5.Mask.Type.SPRITE_STENCIL;
          this._customMask.alphaThreshold = 1e-4;
          this._customMask.spriteFrame = this._maskContent._content.spriteFrame;
        } else if (this._maskContent instanceof GGraph) {
          if (this._maskContent.type == 2)
            this._customMask.type = import_cc5.Mask.Type.GRAPHICS_ELLIPSE;
          else
            this._customMask.type = import_cc5.Mask.Type.GRAPHICS_RECT;
        }
        this._customMask.inverted = this._invertedMask;
      }
      onMaskContentChanged() {
        let maskNode = this._customMask.node;
        let maskUITrans = maskNode.getComponent(import_cc5.UITransform);
        let contentNode = this._maskContent.node;
        let contentUITrans = this._maskContent._uiTrans;
        let w = this._maskContent.width * this._maskContent.scaleX;
        let h = this._maskContent.height * this._maskContent.scaleY;
        maskUITrans.setContentSize(w, h);
        let left = contentNode.position.x - contentUITrans.anchorX * w;
        let top = contentNode.position.y - contentUITrans.anchorY * h;
        maskUITrans.setAnchorPoint(-left / maskUITrans.width, -top / maskUITrans.height);
        maskNode.setPosition(this._pivotCorrectX, this._pivotCorrectY);
      }
      get _pivotCorrectX() {
        return -this.pivotX * this._width + this._margin.left;
      }
      get _pivotCorrectY() {
        return this.pivotY * this._height - this._margin.top;
      }
      get baseUserData() {
        var buffer = this.packageItem.rawData;
        buffer.seek(0, 4);
        return buffer.readS();
      }
      setupScroll(buffer) {
        this._scrollPane = this._node.addComponent(ScrollPane);
        this._scrollPane.setup(buffer);
      }
      setupOverflow(overflow) {
        if (overflow == OverflowType.Hidden)
          this._rectMask = this._container.addComponent(import_cc5.Mask);
        if (!this._margin.isNone)
          this.handleSizeChanged();
      }
      handleAnchorChanged() {
        super.handleAnchorChanged();
        if (this._customMask)
          this._customMask.node.setPosition(this._pivotCorrectX, this._pivotCorrectY);
        else if (this._scrollPane)
          this._scrollPane.adjustMaskContainer();
        else
          this._container.setPosition(this._pivotCorrectX + this._alignOffset.x, this._pivotCorrectY - this._alignOffset.y);
      }
      handleSizeChanged() {
        super.handleSizeChanged();
        if (this._customMask)
          this._customMask.node.setPosition(this._pivotCorrectX, this._pivotCorrectY);
        else if (!this._scrollPane)
          this._container.setPosition(this._pivotCorrectX, this._pivotCorrectY);
        if (this._scrollPane)
          this._scrollPane.onOwnerSizeChanged();
        else
          this._container._uiProps.uiTransformComp.setContentSize(this.viewWidth, this.viewHeight);
      }
      handleGrayedChanged() {
        var c = this.getController("grayed");
        if (c) {
          c.selectedIndex = this.grayed ? 1 : 0;
          return;
        }
        var v = this.grayed;
        var cnt = this._children.length;
        for (var i = 0; i < cnt; ++i) {
          this._children[i].grayed = v;
        }
      }
      handleControllerChanged(c) {
        super.handleControllerChanged(c);
        if (this._scrollPane)
          this._scrollPane.handleControllerChanged(c);
      }
      _hitTest(pt, globalPt) {
        if (this._customMask) {
          s_vec2$2.set(globalPt);
          s_vec2$2.y = UIContentScaler.rootSize.height - globalPt.y;
          let b = this._customMask.isHit(s_vec2$2) || false;
          if (!b)
            return null;
        }
        if (this.hitArea) {
          if (!this.hitArea.hitTest(pt, globalPt))
            return null;
        } else if (this._rectMask) {
          s_vec2$2.set(pt);
          s_vec2$2.x += this._container.position.x;
          s_vec2$2.y += this._container.position.y;
          let clippingSize = this._container._uiProps.uiTransformComp.contentSize;
          if (s_vec2$2.x < 0 || s_vec2$2.y < 0 || s_vec2$2.x >= clippingSize.width || s_vec2$2.y >= clippingSize.height)
            return null;
        }
        if (this._scrollPane) {
          let target2 = this._scrollPane.hitTest(pt, globalPt);
          if (!target2)
            return null;
          if (target2 != this)
            return target2;
        }
        let target = null;
        let cnt = this._children.length;
        for (let i = cnt - 1; i >= 0; i--) {
          let child = this._children[i];
          if (this._maskContent == child || child._touchDisabled)
            continue;
          target = child.hitTest(globalPt);
          if (target)
            break;
        }
        if (!target && this._opaque && (this.hitArea || pt.x >= 0 && pt.y >= 0 && pt.x < this._width && pt.y < this._height))
          target = this;
        return target;
      }
      setBoundsChangedFlag() {
        if (!this._scrollPane && !this._trackBounds)
          return;
        if (!this._boundsChanged) {
          this._boundsChanged = true;
          this._partner.callLater(this.refresh);
        }
      }
      refresh(dt) {
        if (!isNaN(dt)) {
          let _t = GObject.cast(this.node);
          _t.refresh();
          return;
        }
        if (this._boundsChanged) {
          var len = this._children.length;
          if (len > 0) {
            for (var i = 0; i < len; i++) {
              var child = this._children[i];
              child.ensureSizeCorrect();
            }
          }
          this.updateBounds();
        }
      }
      ensureBoundsCorrect() {
        var len = this._children.length;
        if (len > 0) {
          for (var i = 0; i < len; i++) {
            var child = this._children[i];
            child.ensureSizeCorrect();
          }
        }
        if (this._boundsChanged)
          this.updateBounds();
      }
      updateBounds() {
        var ax = 0, ay = 0, aw = 0, ah = 0;
        var len = this._children.length;
        if (len > 0) {
          ax = Number.POSITIVE_INFINITY, ay = Number.POSITIVE_INFINITY;
          var ar = Number.NEGATIVE_INFINITY, ab = Number.NEGATIVE_INFINITY;
          var tmp = 0;
          var i = 0;
          for (var i = 0; i < len; i++) {
            var child = this._children[i];
            if (this._excludeInvisibles && !child.internalVisible3)
              continue;
            tmp = child.x;
            if (tmp < ax)
              ax = tmp;
            tmp = child.y;
            if (tmp < ay)
              ay = tmp;
            tmp = child.x + child.actualWidth;
            if (tmp > ar)
              ar = tmp;
            tmp = child.y + child.actualHeight;
            if (tmp > ab)
              ab = tmp;
          }
          aw = ar - ax;
          ah = ab - ay;
        }
        this.setBounds(ax, ay, aw, ah);
      }
      setBounds(ax, ay, aw, ah = 0) {
        this._boundsChanged = false;
        if (this._scrollPane)
          this._scrollPane.setContentSize(Math.round(ax + aw), Math.round(ay + ah));
      }
      get viewWidth() {
        if (this._scrollPane)
          return this._scrollPane.viewWidth;
        else
          return this.width - this._margin.left - this._margin.right;
      }
      set viewWidth(value) {
        if (this._scrollPane)
          this._scrollPane.viewWidth = value;
        else
          this.width = value + this._margin.left + this._margin.right;
      }
      get viewHeight() {
        if (this._scrollPane)
          return this._scrollPane.viewHeight;
        else
          return this.height - this._margin.top - this._margin.bottom;
      }
      set viewHeight(value) {
        if (this._scrollPane)
          this._scrollPane.viewHeight = value;
        else
          this.height = value + this._margin.top + this._margin.bottom;
      }
      getSnappingPosition(xValue, yValue, resultPoint) {
        if (!resultPoint)
          resultPoint = new import_cc5.Vec2();
        var cnt = this._children.length;
        if (cnt == 0) {
          resultPoint.x = 0;
          resultPoint.y = 0;
          return resultPoint;
        }
        this.ensureBoundsCorrect();
        var obj = null;
        var prev = null;
        var i = 0;
        if (yValue != 0) {
          for (; i < cnt; i++) {
            obj = this._children[i];
            if (yValue < obj.y) {
              if (i == 0) {
                yValue = 0;
                break;
              } else {
                prev = this._children[i - 1];
                if (yValue < prev.y + prev.actualHeight / 2)
                  yValue = prev.y;
                else
                  yValue = obj.y;
                break;
              }
            }
          }
          if (i == cnt)
            yValue = obj.y;
        }
        if (xValue != 0) {
          if (i > 0)
            i--;
          for (; i < cnt; i++) {
            obj = this._children[i];
            if (xValue < obj.x) {
              if (i == 0) {
                xValue = 0;
                break;
              } else {
                prev = this._children[i - 1];
                if (xValue < prev.x + prev.actualWidth / 2)
                  xValue = prev.x;
                else
                  xValue = obj.x;
                break;
              }
            }
          }
          if (i == cnt)
            xValue = obj.x;
        }
        resultPoint.x = xValue;
        resultPoint.y = yValue;
        return resultPoint;
      }
      childSortingOrderChanged(child, oldValue, newValue = 0) {
        if (newValue == 0) {
          this._sortingChildCount--;
          this.setChildIndex(child, this._children.length);
        } else {
          if (oldValue == 0)
            this._sortingChildCount++;
          var oldIndex = this._children.indexOf(child);
          var index = this.getInsertPosForSortingChild(child);
          if (oldIndex < index)
            this._setChildIndex(child, oldIndex, index - 1);
          else
            this._setChildIndex(child, oldIndex, index);
        }
      }
      constructFromResource() {
        this.constructFromResource2(null, 0);
      }
      constructFromResource2(objectPool, poolIndex) {
        var contentItem = this.packageItem.getBranch();
        if (!contentItem.decoded) {
          contentItem.decoded = true;
          TranslationHelper.translateComponent(contentItem);
        }
        var i;
        var dataLen;
        var curPos;
        var nextPos;
        var f1;
        var f2;
        var i1;
        var i2;
        var buffer = contentItem.rawData;
        buffer.seek(0, 0);
        this._underConstruct = true;
        this.sourceWidth = buffer.readInt();
        this.sourceHeight = buffer.readInt();
        this.initWidth = this.sourceWidth;
        this.initHeight = this.sourceHeight;
        this.setSize(this.sourceWidth, this.sourceHeight);
        if (buffer.readBool()) {
          this.minWidth = buffer.readInt();
          this.maxWidth = buffer.readInt();
          this.minHeight = buffer.readInt();
          this.maxHeight = buffer.readInt();
        }
        if (buffer.readBool()) {
          f1 = buffer.readFloat();
          f2 = buffer.readFloat();
          this.setPivot(f1, f2, buffer.readBool());
        }
        if (buffer.readBool()) {
          this._margin.top = buffer.readInt();
          this._margin.bottom = buffer.readInt();
          this._margin.left = buffer.readInt();
          this._margin.right = buffer.readInt();
        }
        var overflow = buffer.readByte();
        if (overflow == OverflowType.Scroll) {
          var savedPos = buffer.position;
          buffer.seek(0, 7);
          this.setupScroll(buffer);
          buffer.position = savedPos;
        } else
          this.setupOverflow(overflow);
        if (buffer.readBool())
          buffer.skip(8);
        this._buildingDisplayList = true;
        buffer.seek(0, 1);
        var controllerCount = buffer.readShort();
        for (i = 0; i < controllerCount; i++) {
          nextPos = buffer.readShort();
          nextPos += buffer.position;
          var controller = new Controller();
          this._controllers.push(controller);
          controller.parent = this;
          controller.setup(buffer);
          buffer.position = nextPos;
        }
        buffer.seek(0, 2);
        var child;
        var childCount = buffer.readShort();
        for (i = 0; i < childCount; i++) {
          dataLen = buffer.readShort();
          curPos = buffer.position;
          if (objectPool)
            child = objectPool[poolIndex + i];
          else {
            buffer.seek(curPos, 0);
            var type = buffer.readByte();
            var src = buffer.readS();
            var pkgId = buffer.readS();
            var pi = null;
            if (src != null) {
              var pkg;
              if (pkgId != null)
                pkg = UIPackage.getById(pkgId);
              else
                pkg = contentItem.owner;
              pi = pkg ? pkg.getItemById(src) : null;
            }
            if (pi) {
              child = Decls.UIObjectFactory.newObject(pi);
              child.constructFromResource();
            } else
              child = Decls.UIObjectFactory.newObject(type);
          }
          child._underConstruct = true;
          child.setup_beforeAdd(buffer, curPos);
          child._parent = this;
          child.node.parent = this._container;
          this._children.push(child);
          buffer.position = curPos + dataLen;
        }
        buffer.seek(0, 3);
        this.relations.setup(buffer, true);
        buffer.seek(0, 2);
        buffer.skip(2);
        for (i = 0; i < childCount; i++) {
          nextPos = buffer.readShort();
          nextPos += buffer.position;
          buffer.seek(buffer.position, 3);
          this._children[i].relations.setup(buffer, false);
          buffer.position = nextPos;
        }
        buffer.seek(0, 2);
        buffer.skip(2);
        for (i = 0; i < childCount; i++) {
          nextPos = buffer.readShort();
          nextPos += buffer.position;
          child = this._children[i];
          child.setup_afterAdd(buffer, buffer.position);
          child._underConstruct = false;
          buffer.position = nextPos;
        }
        buffer.seek(0, 4);
        buffer.skip(2);
        this.opaque = buffer.readBool();
        var maskId = buffer.readShort();
        if (maskId != -1) {
          this.setMask(this.getChildAt(maskId), buffer.readBool());
        }
        var hitTestId = buffer.readS();
        i1 = buffer.readInt();
        i2 = buffer.readInt();
        if (hitTestId != null) {
          pi = contentItem.owner.getItemById(hitTestId);
          if (pi && pi.hitTestData)
            this.hitArea = new PixelHitTest(pi.hitTestData, i1, i2);
        } else if (i1 != 0 && i2 != -1) {
          this.hitArea = new ChildHitArea(this.getChildAt(i2));
        }
        buffer.seek(0, 5);
        var transitionCount = buffer.readShort();
        for (i = 0; i < transitionCount; i++) {
          nextPos = buffer.readShort();
          nextPos += buffer.position;
          var trans = new Transition(this);
          trans.setup(buffer);
          this._transitions.push(trans);
          buffer.position = nextPos;
        }
        this.applyAllControllers();
        this._buildingDisplayList = false;
        this._underConstruct = false;
        this.buildNativeDisplayList();
        this.setBoundsChangedFlag();
        if (contentItem.objectType != ObjectType.Component)
          this.constructExtension(buffer);
        this.onConstruct();
      }
      constructExtension(buffer) {
      }
      onConstruct() {
      }
      setup_afterAdd(buffer, beginPos) {
        super.setup_afterAdd(buffer, beginPos);
        buffer.seek(beginPos, 4);
        var pageController = buffer.readShort();
        if (pageController != -1 && this._scrollPane)
          this._scrollPane.pageController = this._parent.getControllerAt(pageController);
        var cnt = buffer.readShort();
        for (var i = 0; i < cnt; i++) {
          var cc = this.getController(buffer.readS());
          var pageId = buffer.readS();
          if (cc)
            cc.selectedPageId = pageId;
        }
        if (buffer.version >= 2) {
          cnt = buffer.readShort();
          for (i = 0; i < cnt; i++) {
            var target = buffer.readS();
            var propertyId = buffer.readShort();
            var value = buffer.readS();
            var obj = this.getChildByPath(target);
            if (obj)
              obj.setProp(propertyId, value);
          }
        }
      }
      onEnable() {
        let cnt = this._transitions.length;
        for (let i = 0; i < cnt; ++i)
          this._transitions[i].onEnable();
      }
      onDisable() {
        let cnt = this._transitions.length;
        for (let i = 0; i < cnt; ++i)
          this._transitions[i].onDisable();
      }
      addTransition(transition, newName, applyBaseValue = true) {
        let trans = new Transition(this);
        trans.copyFrom(transition, applyBaseValue);
        if (newName) {
          trans.name = newName;
        }
        this._transitions.push(trans);
      }
      addControllerAction(controlName, transition, fromPages, toPages, applyBaseValue = true) {
        let ctrl = this.getController(controlName);
        if (!ctrl)
          return;
        this.addTransition(transition, null, applyBaseValue);
        var action = createAction(0);
        action.transitionName = transition.name;
        if (fromPages) {
          fromPages = fromPages.map((it) => {
            return ctrl.getPageIdByName(it);
          });
        }
        if (toPages) {
          toPages = toPages.map((it) => {
            return ctrl.getPageIdByName(it);
          });
        }
        action.fromPage = fromPages;
        action.toPage = toPages;
        ctrl.addAction(action);
      }
    };
    s_vec2$2 = new import_cc5.Vec2();
    Window = class extends GComponent {
      constructor() {
        super();
        this._requestingCmd = 0;
        this._uiSources = new Array();
        this.bringToFontOnClick = UIConfig.bringWindowToFrontOnClick;
        this._node.on(Event.TOUCH_BEGIN, this.onTouchBegin_1, this, true);
      }
      addUISource(source) {
        this._uiSources.push(source);
      }
      set contentPane(val) {
        if (this._contentPane != val) {
          if (this._contentPane)
            this.removeChild(this._contentPane);
          this._contentPane = val;
          if (this._contentPane) {
            this.addChild(this._contentPane);
            this.setSize(this._contentPane.width, this._contentPane.height);
            this._contentPane.addRelation(this, RelationType.Size);
            this._frame = this._contentPane.getChild("frame");
            if (this._frame) {
              this.closeButton = this._frame.getChild("closeButton");
              this.dragArea = this._frame.getChild("dragArea");
              this.contentArea = this._frame.getChild("contentArea");
            }
          }
        }
      }
      get contentPane() {
        return this._contentPane;
      }
      get frame() {
        return this._frame;
      }
      get closeButton() {
        return this._closeButton;
      }
      set closeButton(value) {
        if (this._closeButton)
          this._closeButton.offClick(this.closeEventHandler, this);
        this._closeButton = value;
        if (this._closeButton)
          this._closeButton.onClick(this.closeEventHandler, this);
      }
      get dragArea() {
        return this._dragArea;
      }
      set dragArea(value) {
        if (this._dragArea != value) {
          if (this._dragArea) {
            this._dragArea.draggable = false;
            this._dragArea.off(Event.DRAG_START, this.onDragStart_1, this);
          }
          this._dragArea = value;
          if (this._dragArea) {
            this._dragArea.draggable = true;
            this._dragArea.on(Event.DRAG_START, this.onDragStart_1, this);
          }
        }
      }
      get contentArea() {
        return this._contentArea;
      }
      set contentArea(value) {
        this._contentArea = value;
      }
      show() {
        GRoot.inst.showWindow(this);
      }
      showOn(root) {
        root.showWindow(this);
      }
      hide() {
        if (this.isShowing)
          this.doHideAnimation();
      }
      hideImmediately() {
        var r = this.parent instanceof GRoot ? this.parent : null;
        if (!r)
          r = GRoot.inst;
        r.hideWindowImmediately(this);
      }
      centerOn(r, restraint) {
        this.setPosition(Math.round((r.width - this.width) / 2), Math.round((r.height - this.height) / 2));
        if (restraint) {
          this.addRelation(r, RelationType.Center_Center);
          this.addRelation(r, RelationType.Middle_Middle);
        }
      }
      toggleStatus() {
        if (this.isTop)
          this.hide();
        else
          this.show();
      }
      get isShowing() {
        return this.parent != null;
      }
      get isTop() {
        return this.parent && this.parent.getChildIndex(this) == this.parent.numChildren - 1;
      }
      get modal() {
        return this._modal;
      }
      set modal(val) {
        this._modal = val;
      }
      bringToFront() {
        GRoot.inst.bringToFront(this);
      }
      showModalWait(requestingCmd) {
        if (requestingCmd != null)
          this._requestingCmd = requestingCmd;
        if (UIConfig.windowModalWaiting) {
          if (!this._modalWaitPane)
            this._modalWaitPane = UIPackage.createObjectFromURL(UIConfig.windowModalWaiting);
          this.layoutModalWaitPane();
          this.addChild(this._modalWaitPane);
        }
      }
      layoutModalWaitPane() {
        if (this._contentArea) {
          var pt = this._frame.localToGlobal();
          pt = this.globalToLocal(pt.x, pt.y, pt);
          this._modalWaitPane.setPosition(pt.x + this._contentArea.x, pt.y + this._contentArea.y);
          this._modalWaitPane.setSize(this._contentArea.width, this._contentArea.height);
        } else
          this._modalWaitPane.setSize(this.width, this.height);
      }
      closeModalWait(requestingCmd) {
        if (requestingCmd != null) {
          if (this._requestingCmd != requestingCmd)
            return false;
        }
        this._requestingCmd = 0;
        if (this._modalWaitPane && this._modalWaitPane.parent)
          this.removeChild(this._modalWaitPane);
        return true;
      }
      get modalWaiting() {
        return this._modalWaitPane && this._modalWaitPane.parent != null;
      }
      init() {
        if (this._inited || this._loading)
          return;
        if (this._uiSources.length > 0) {
          this._loading = false;
          var cnt = this._uiSources.length;
          for (var i = 0; i < cnt; i++) {
            var lib = this._uiSources[i];
            if (!lib.loaded) {
              lib.load(this.__uiLoadComplete, this);
              this._loading = true;
            }
          }
          if (!this._loading)
            this._init();
        } else
          this._init();
      }
      onInit() {
      }
      onShown() {
      }
      onHide() {
      }
      doShowAnimation() {
        this.onShown();
      }
      doHideAnimation() {
        this.hideImmediately();
      }
      __uiLoadComplete() {
        var cnt = this._uiSources.length;
        for (var i = 0; i < cnt; i++) {
          var lib = this._uiSources[i];
          if (!lib.loaded)
            return;
        }
        this._loading = false;
        this._init();
      }
      _init() {
        this._inited = true;
        this.onInit();
        if (this.isShowing)
          this.doShowAnimation();
      }
      dispose() {
        if (this.parent)
          this.hideImmediately();
        super.dispose();
      }
      closeEventHandler(evt) {
        this.hide();
      }
      onEnable() {
        super.onEnable();
        if (!this._inited)
          this.init();
        else
          this.doShowAnimation();
      }
      onDisable() {
        super.onDisable();
        this.closeModalWait();
        this.onHide();
      }
      onTouchBegin_1(evt) {
        if (this.isShowing && this.bringToFontOnClick)
          this.bringToFront();
      }
      onDragStart_1(evt) {
        var original = GObject.cast(evt.currentTarget);
        original.stopDrag();
        this.startDrag(evt.touchId);
      }
    };
    GRoot = class _GRoot extends GComponent {
      static get inst() {
        if (!_GRoot._inst)
          throw "Call GRoot.create first!";
        return _GRoot._inst;
      }
      static create() {
        _GRoot._inst = new _GRoot();
        import_cc5.director.getScene().getChildByName("Canvas").addChild(_GRoot._inst.node);
        _GRoot._inst.onWinResize();
        return _GRoot._inst;
      }
      constructor() {
        super();
        this.enableAutoClosePopup = true;
        this._node.name = "GRoot";
        this.opaque = false;
        this._volumeScale = 1;
        this._popupStack = new Array();
        this._justClosedPopups = new Array();
        this._modalLayer = new GGraph();
        this._modalLayer.setSize(this.width, this.height);
        this._modalLayer.drawRect(0, import_cc5.Color.TRANSPARENT, UIConfig.modalLayerColor);
        this._modalLayer.addRelation(this, RelationType.Size);
        this._thisOnResized = this.onWinResize.bind(this);
        this._inputProcessor = this.node.addComponent(InputProcessor);
        this._inputProcessor._captureCallback = this.onTouchBegin_1;
        import_cc5.View.instance.on("design-resolution-changed", this.onWinResize, this);
        if (!import_env2.EDITOR) {
          import_cc5.View.instance.on("canvas-resize", this._thisOnResized);
          window.addEventListener("orientationchange", this._thisOnResized);
        }
      }
      onDestroy() {
        import_cc5.View.instance.off("design-resolution-changed", this.onWinResize, this);
        if (!import_env2.EDITOR) {
          import_cc5.View.instance.off("canvas-resize", this._thisOnResized);
          window.removeEventListener("orientationchange", this._thisOnResized);
        }
        if (this == _GRoot._inst)
          _GRoot._inst = null;
      }
      getTouchPosition(touchId) {
        return this._inputProcessor.getTouchPosition(touchId);
      }
      get touchTarget() {
        return this._inputProcessor.getTouchTarget();
      }
      get inputProcessor() {
        return this._inputProcessor;
      }
      showWindow(win) {
        this.addChild(win);
        win.requestFocus();
        if (win.x > this.width)
          win.x = this.width - win.width;
        else if (win.x + win.width < 0)
          win.x = 0;
        if (win.y > this.height)
          win.y = this.height - win.height;
        else if (win.y + win.height < 0)
          win.y = 0;
        this.adjustModalLayer();
      }
      hideWindow(win) {
        win.hide();
      }
      hideWindowImmediately(win) {
        if (win.parent == this)
          this.removeChild(win);
        this.adjustModalLayer();
      }
      bringToFront(win) {
        var cnt = this.numChildren;
        var i;
        if (this._modalLayer.parent && !win.modal)
          i = this.getChildIndex(this._modalLayer) - 1;
        else
          i = cnt - 1;
        for (; i >= 0; i--) {
          var g = this.getChildAt(i);
          if (g == win)
            return;
          if (g instanceof Window)
            break;
        }
        if (i >= 0)
          this.setChildIndex(win, i);
      }
      showModalWait(msg) {
        var _a;
        if (UIConfig.globalModalWaiting != null) {
          if ((_a = this._modalWaitPane) === null || _a === void 0 ? void 0 : _a.isDisposed) {
            this._modalWaitPane = null;
          }
          if (this._modalWaitPane == null)
            this._modalWaitPane = UIPackage.createObjectFromURL(UIConfig.globalModalWaiting);
          this._modalWaitPane.setSize(this.width, this.height);
          this._modalWaitPane.addRelation(this, RelationType.Size);
          this.addChild(this._modalWaitPane);
          this._modalWaitPane.text = msg;
        }
      }
      closeModalWait() {
        if (this._modalWaitPane && this._modalWaitPane.parent)
          this.removeChild(this._modalWaitPane);
      }
      closeAllExceptModals() {
        var arr = this._children.slice();
        var cnt = arr.length;
        for (var i = 0; i < cnt; i++) {
          var g = arr[i];
          if (g instanceof Window && !g.modal)
            g.hide();
        }
      }
      closeAllWindows() {
        var arr = this._children.slice();
        var cnt = arr.length;
        for (var i = 0; i < cnt; i++) {
          var g = arr[i];
          if (g instanceof Window)
            g.hide();
        }
      }
      getTopWindow() {
        var cnt = this.numChildren;
        for (var i = cnt - 1; i >= 0; i--) {
          var g = this.getChildAt(i);
          if (g instanceof Window) {
            return g;
          }
        }
        return null;
      }
      get modalLayer() {
        return this._modalLayer;
      }
      get hasModalWindow() {
        return this._modalLayer.parent != null;
      }
      get modalWaiting() {
        return this._modalWaitPane && this._modalWaitPane.node.activeInHierarchy;
      }
      getPopupPosition(popup, target, dir, result) {
        let pos = result || new import_cc5.Vec2();
        var sizeW = 0, sizeH = 0;
        if (target) {
          pos = target.localToGlobal();
          _GRoot.inst.globalToLocal(pos.x, pos.y, pos);
          let pos2 = target.localToGlobal(target.width, target.height);
          _GRoot.inst.globalToLocal(pos2.x, pos2.y, pos2);
          sizeW = pos2.x - pos.x;
          sizeH = pos2.y - pos.y;
        } else {
          pos = this.getTouchPosition();
          pos = this.globalToLocal(pos.x, pos.y);
        }
        if (pos.x + popup.width > this.width)
          pos.x = pos.x + sizeW - popup.width;
        pos.y += sizeH;
        if ((dir === void 0 || dir === PopupDirection.Auto) && pos.y + popup.height > this.height || dir === false || dir === PopupDirection.Up) {
          pos.y = pos.y - sizeH - popup.height - 1;
          if (pos.y < 0) {
            pos.y = 0;
            pos.x += sizeW / 2;
          }
        }
        return pos;
      }
      removeChildAt(index, dispose) {
        let ret = super.removeChildAt(index, dispose);
        if (dispose) {
          if (ret == this._modalWaitPane) {
            this._modalWaitPane = null;
          }
        }
        return ret;
      }
      showPopup(popup, target, dir) {
        if (this._popupStack.length > 0) {
          var k = this._popupStack.indexOf(popup);
          if (k != -1) {
            for (var i = this._popupStack.length - 1; i >= k; i--)
              this.removeChild(this._popupStack.pop());
          }
        }
        this._popupStack.push(popup);
        if (target) {
          var p = target;
          while (p) {
            if (p.parent == this) {
              if (popup.sortingOrder < p.sortingOrder) {
                popup.sortingOrder = p.sortingOrder;
              }
              break;
            }
            p = p.parent;
          }
        }
        this.addChild(popup);
        this.adjustModalLayer();
        let pt = this.getPopupPosition(popup, target, dir);
        popup.setPosition(pt.x, pt.y);
      }
      togglePopup(popup, target, dir) {
        if (this._justClosedPopups.indexOf(popup) != -1)
          return;
        this.showPopup(popup, target, dir);
      }
      hidePopup(popup) {
        if (popup) {
          var k = this._popupStack.indexOf(popup);
          if (k != -1) {
            for (var i = this._popupStack.length - 1; i >= k; i--)
              this.closePopup(this._popupStack.pop());
          }
        } else {
          var cnt = this._popupStack.length;
          for (i = cnt - 1; i >= 0; i--)
            this.closePopup(this._popupStack[i]);
          this._popupStack.length = 0;
        }
      }
      get hasAnyPopup() {
        return this._popupStack.length != 0;
      }
      closePopup(target) {
        if (target.parent) {
          if (target instanceof Window)
            target.hide();
          else
            this.removeChild(target);
        }
      }
      showTooltips(msg) {
        if (this._defaultTooltipWin == null) {
          var resourceURL = UIConfig.tooltipsWin;
          if (!resourceURL) {
            console.error("UIConfig.tooltipsWin not defined");
            return;
          }
          this._defaultTooltipWin = UIPackage.createObjectFromURL(resourceURL);
        }
        this._defaultTooltipWin.text = msg;
        this.showTooltipsWin(this._defaultTooltipWin);
      }
      showTooltipsWin(tooltipWin) {
        this.hideTooltips();
        this._tooltipWin = tooltipWin;
        let pt = this.getTouchPosition();
        pt.x += 10;
        pt.y += 20;
        this.globalToLocal(pt.x, pt.y, pt);
        if (pt.x + this._tooltipWin.width > this.width) {
          pt.x = pt.x - this._tooltipWin.width - 1;
          if (pt.x < 0)
            pt.x = 10;
        }
        if (pt.y + this._tooltipWin.height > this.height) {
          pt.y = pt.y - this._tooltipWin.height - 1;
          if (pt.y < 0)
            pt.y = 10;
        }
        this._tooltipWin.setPosition(pt.x, pt.y);
        this.addChild(this._tooltipWin);
      }
      hideTooltips() {
        if (this._tooltipWin) {
          if (this._tooltipWin.parent)
            this.removeChild(this._tooltipWin);
          this._tooltipWin = null;
        }
      }
      get volumeScale() {
        return this._volumeScale;
      }
      set volumeScale(value) {
        this._volumeScale = value;
      }
      playOneShotSound(clip, volumeScale) {
        if (!this.audioEngine) {
          this.audioEngine = this.node.addComponent(import_cc5.AudioSourceComponent);
        }
        if (volumeScale === void 0)
          volumeScale = 1;
        if (this.audioEngine.isValid) {
          this.audioEngine.clip = clip;
          this.audioEngine.volume = this._volumeScale * volumeScale;
          this.audioEngine.loop = false;
          this.audioEngine.play();
        }
      }
      adjustModalLayer() {
        var cnt = this.numChildren;
        if (this._modalWaitPane && this._modalWaitPane.parent)
          this.setChildIndex(this._modalWaitPane, cnt - 1);
        for (var i = cnt - 1; i >= 0; i--) {
          var g = this.getChildAt(i);
          if (g instanceof Window && g.modal) {
            if (this._modalLayer.parent == null)
              this.addChildAt(this._modalLayer, i);
            else
              this.setChildIndexBefore(this._modalLayer, i);
            return;
          }
        }
        if (this._modalLayer.parent)
          this.removeChild(this._modalLayer);
      }
      onTouchBegin_1(evt) {
        if (this._tooltipWin)
          this.hideTooltips();
        this._justClosedPopups.length = 0;
        if (this.enableAutoClosePopup && this._popupStack.length > 0) {
          let mc = evt.initiator;
          while (mc && mc != this) {
            let pindex = this._popupStack.indexOf(mc);
            if (pindex != -1) {
              for (let i = this._popupStack.length - 1; i > pindex; i--) {
                var popup = this._popupStack.pop();
                this.closePopup(popup);
                this._justClosedPopups.push(popup);
              }
              return;
            }
            mc = mc.findParent();
          }
          let cnt = this._popupStack.length;
          for (let i = cnt - 1; i >= 0; i--) {
            popup = this._popupStack[i];
            this.closePopup(popup);
            this._justClosedPopups.push(popup);
          }
          this._popupStack.length = 0;
        }
      }
      onWinResize() {
        updateScaler();
        this.setSize(UIContentScaler.rootSize.width, UIContentScaler.rootSize.height);
        let anchorPoint = this.node.getParent()._uiProps.uiTransformComp.anchorPoint;
        this.node.setPosition(-this._width * anchorPoint.x, this._height * (1 - anchorPoint.y));
      }
      handlePositionChanged() {
      }
      onUpdate() {
        super.onUpdate();
        if (!this._inputProcessor.touching) {
          RefMannager.update(import_cc5.game.frameTime / 1e3);
        }
      }
    };
    Decls$1.GRoot = GRoot;
    GTextInput = class extends GTextField {
      constructor() {
        super();
        this._node.name = "GTextInput";
        this._touchDisabled = false;
      }
      createRenderer() {
        this._editBox = this._node.addComponent(MyEditBox);
        this._editBox.maxLength = -1;
        this._editBox["_updateTextLabel"]();
        this._node.on("text-changed", this.onTextChanged, this);
        this.on(Event.TOUCH_END, this.onTouchEnd1, this);
        this.autoSize = AutoSizeType.None;
      }
      set editable(val) {
        this._editBox.enabled = val;
      }
      get editable() {
        return this._editBox.enabled;
      }
      set maxLength(val) {
        if (val == 0)
          val = -1;
        this._editBox.maxLength = val;
      }
      get maxLength() {
        return this._editBox.maxLength;
      }
      set promptText(val) {
        this._promptText = val;
        let newCreate = !this._editBox.placeholderLabel;
        this._editBox["_updatePlaceholderLabel"]();
        if (newCreate)
          this.assignFont(this._editBox.placeholderLabel, this._realFont);
        this._editBox.placeholderLabel.string = defaultParser.parse(this._promptText, true);
        if (defaultParser.lastColor) {
          let c = this._editBox.placeholderLabel.color;
          if (!c)
            c = new import_cc5.Color();
          c.fromHEX(defaultParser.lastColor);
          this.assignFontColor(this._editBox.placeholderLabel, c);
        } else
          this.assignFontColor(this._editBox.placeholderLabel, this._color);
        if (defaultParser.lastSize)
          this._editBox.placeholderLabel.fontSize = parseInt(defaultParser.lastSize);
        else
          this._editBox.placeholderLabel.fontSize = this._fontSize;
      }
      get promptText() {
        return this._promptText;
      }
      set restrict(value) {
      }
      get restrict() {
        return "";
      }
      get password() {
        return this._editBox.inputFlag == import_cc5.EditBox.InputFlag.PASSWORD;
      }
      set password(val) {
        this._editBox.inputFlag = val ? import_cc5.EditBox.InputFlag.PASSWORD : import_cc5.EditBox.InputFlag.DEFAULT;
      }
      get align() {
        return this._editBox.textLabel.horizontalAlign;
      }
      set align(value) {
        this._editBox.textLabel.horizontalAlign = value;
        if (this._editBox.placeholderLabel) {
          this._editBox.placeholderLabel.horizontalAlign = value;
        }
      }
      get verticalAlign() {
        return this._editBox.textLabel.verticalAlign;
      }
      set verticalAlign(value) {
        this._editBox.textLabel.verticalAlign = value;
        if (this._editBox.placeholderLabel) {
          this._editBox.placeholderLabel.verticalAlign = value;
        }
      }
      get singleLine() {
        return this._editBox.inputMode != import_cc5.EditBox.InputMode.ANY;
      }
      set singleLine(value) {
        this._editBox.inputMode = value ? import_cc5.EditBox.InputMode.SINGLE_LINE : import_cc5.EditBox.InputMode.ANY;
      }
      requestFocus() {
        this._editBox.focus();
      }
      markSizeChanged() {
      }
      updateText() {
        var text2 = this._text;
        if (this._templateVars)
          text2 = this.parseTemplate(text2);
        if (this._ubbEnabled)
          text2 = defaultParser.parse(text2, true);
        this._editBox.string = text2;
      }
      updateFont() {
        this.assignFont(this._editBox.textLabel, this._realFont);
        if (this._editBox.placeholderLabel)
          this.assignFont(this._editBox.placeholderLabel, this._realFont);
      }
      updateFontColor() {
        this.assignFontColor(this._editBox.textLabel, this._color);
      }
      updateFontSize() {
        this._editBox.textLabel.fontSize = this._fontSize;
        this._editBox.textLabel.lineHeight = this._fontSize + this._leading;
        if (this._editBox.placeholderLabel)
          this._editBox.placeholderLabel.fontSize = this._editBox.textLabel.fontSize;
      }
      updateOverflow() {
      }
      onTextChanged() {
        this._text = this._editBox.string;
      }
      onTouchEnd1(evt) {
        this._editBox.openKeyboard();
      }
      setup_beforeAdd(buffer, beginPos) {
        super.setup_beforeAdd(buffer, beginPos);
        buffer.seek(beginPos, 4);
        var str = buffer.readS();
        if (str != null)
          this.promptText = str;
        else if (this._editBox.placeholderLabel)
          this._editBox.placeholderLabel.string = "";
        str = buffer.readS();
        if (str != null)
          this.restrict = str;
        var iv = buffer.readInt();
        if (iv != 0)
          this.maxLength = iv;
        iv = buffer.readInt();
        if (buffer.readBool())
          this.password = true;
        if (this._editBox.placeholderLabel) {
          let hAlign = this._editBox.textLabel.horizontalAlign;
          this._editBox.placeholderLabel.horizontalAlign = hAlign;
          let vAlign = this._editBox.textLabel.verticalAlign;
          this._editBox.placeholderLabel.verticalAlign = vAlign;
        }
      }
    };
    MyEditBox = class extends import_cc5.EditBox {
      _registerEvent() {
        this.placeholderLabel.getComponent(import_cc5.UITransform).setAnchorPoint(0, 1);
        this.textLabel.getComponent(import_cc5.UITransform).setAnchorPoint(0, 1);
        this.placeholderLabel.overflow = import_cc5.Overflow.CLAMP;
        this.textLabel.overflow = import_cc5.Overflow.CLAMP;
      }
      // _syncSize() {
      //     let size = this.node._uiProps.uiTransformComp.contentSize;
      //     let impl = this["_impl"];
      //     impl.setSize(size.width, size.height);
      //     if (this.textLabel)
      //         this.textLabel.node._uiProps.uiTransformComp.setContentSize(size.width, size.height);
      //     if (this.placeholderLabel)
      //         this.placeholderLabel.node._uiProps.uiTransformComp.setContentSize(size.width, size.height);
      // }
      openKeyboard() {
        let impl = this["_impl"];
        if (impl) {
          impl.beginEditing();
        }
      }
    };
    GObjectPool = class {
      constructor() {
        this._count = 0;
        this._pool = {};
      }
      clear() {
        for (var i1 in this._pool) {
          var arr = this._pool[i1];
          var cnt = arr.length;
          for (var i = 0; i < cnt; i++)
            arr[i].dispose();
        }
        this._pool = {};
        this._count = 0;
      }
      get count() {
        return this._count;
      }
      getObject(url) {
        url = UIPackage.normalizeURL(url);
        if (url == null)
          return null;
        var arr = this._pool[url];
        if (arr && arr.length) {
          this._count--;
          return arr.shift();
        }
        var child = UIPackage.createObjectFromURL(url);
        return child;
      }
      returnObject(obj) {
        var url = obj.resourceURL;
        if (!url)
          return;
        var arr = this._pool[url];
        if (arr == null) {
          arr = new Array();
          this._pool[url] = arr;
        }
        this._count++;
        arr.push(obj);
      }
    };
    SpritePool = new import_cc5.Pool(() => new import_cc5.SpriteFrame(), 1);
    GLoader = class _GLoader extends GObject {
      constructor() {
        super();
        this.extension = "";
        this._frame = 0;
        this._dirtyVersion = 0;
        this._externalAssets = {};
        this._node.name = "GLoader";
        this._playing = true;
        this._url = "";
        this._fill = LoaderFillType.None;
        this._align = AlignType.Left;
        this._verticalAlign = VertAlignType.Top;
        this._showErrorSign = true;
        this._color = new import_cc5.Color(255, 255, 255, 255);
        this._container = new import_cc5.Node("Image");
        this._container.layer = UIConfig.defaultUILayer;
        this._container.addComponent(import_cc5.UITransform).setAnchorPoint(0, 1);
        this._node.addChild(this._container);
        this._content = this._container.addComponent(MovieClip);
        this._content.sizeMode = import_cc5.Sprite.SizeMode.CUSTOM;
        this._content.trim = false;
        this._content.setPlaySettings();
      }
      dispose() {
        if (this._content2) {
          this._content2.dispose();
          this._content2 = null;
        }
        super.dispose();
        this.clearContent();
      }
      get url() {
        return this._url;
      }
      set url(value) {
        if (this._url == value)
          return;
        this._url = value;
        this.loadContent();
        this.updateGear(7);
      }
      get icon() {
        return this._url;
      }
      set icon(value) {
        this.url = value;
      }
      get align() {
        return this._align;
      }
      set align(value) {
        if (this._align != value) {
          this._align = value;
          this.updateLayout();
        }
      }
      get verticalAlign() {
        return this._verticalAlign;
      }
      set verticalAlign(value) {
        if (this._verticalAlign != value) {
          this._verticalAlign = value;
          this.updateLayout();
        }
      }
      get fill() {
        return this._fill;
      }
      set fill(value) {
        if (this._fill != value) {
          this._fill = value;
          this.updateLayout();
        }
      }
      get shrinkOnly() {
        return this._shrinkOnly;
      }
      set shrinkOnly(value) {
        if (this._shrinkOnly != value) {
          this._shrinkOnly = value;
          this.updateLayout();
        }
      }
      get autoSize() {
        return this._autoSize;
      }
      set autoSize(value) {
        if (this._autoSize != value) {
          this._autoSize = value;
          this.updateLayout();
        }
      }
      get playing() {
        return this._playing;
      }
      set playing(value) {
        if (this._playing != value) {
          this._playing = value;
          if (this._content instanceof MovieClip)
            this._content.playing = value;
          this.updateGear(5);
        }
      }
      get frame() {
        return this._frame;
      }
      set frame(value) {
        if (this._frame != value) {
          this._frame = value;
          if (this._content instanceof MovieClip)
            this._content.frame = value;
          this.updateGear(5);
        }
      }
      get color() {
        return this._color;
      }
      set color(value) {
        this._color.set(value);
        this.updateGear(4);
        this._content.color = value;
      }
      get fillMethod() {
        return this._content.fillMethod;
      }
      set fillMethod(value) {
        this._content.fillMethod = value;
      }
      get fillOrigin() {
        return this._content.fillOrigin;
      }
      set fillOrigin(value) {
        this._content.fillOrigin = value;
      }
      get fillClockwise() {
        return this._content.fillClockwise;
      }
      set fillClockwise(value) {
        this._content.fillClockwise = value;
      }
      get fillAmount() {
        return this._content.fillAmount;
      }
      set fillAmount(value) {
        this._content.fillAmount = value;
      }
      get showErrorSign() {
        return this._showErrorSign;
      }
      set showErrorSign(value) {
        this._showErrorSign = value;
      }
      get component() {
        return this._content2;
      }
      get texture() {
        return this._content.spriteFrame;
      }
      set texture(value) {
        this.url = null;
        this.clearContent();
        this._content.spriteFrame = value;
        this._content.type = import_cc5.Sprite.Type.SIMPLE;
        if (value != null) {
          this.sourceWidth = value.getRect().width;
          this.sourceHeight = value.getRect().height;
        } else {
          this.sourceWidth = this.sourceHeight = 0;
        }
        this.updateLayout();
      }
      loadContent() {
        this.clearContent();
        if (!this._url)
          return;
        if (this._url.startsWith("ui://"))
          this.loadFromPackage(this._url);
        else
          this.loadExternal();
      }
      init(contentItem, itemURL, dirtyVersion) {
        if (!(0, import_cc5.isValid)(this.node) || this._dirtyVersion != dirtyVersion) {
          return;
        }
        this._contentItem = contentItem;
        this._contentItem.addRef();
        if (this._autoSize)
          this.setSize(this.sourceWidth, this.sourceHeight);
        if (this._contentItem.type == PackageItemType.Image) {
          if (!this._contentItem.asset) {
            this.setErrorState();
          } else {
            this._content.spriteFrame = this._contentItem.asset;
            if (this._content.fillMethod == 0) {
              if (this._contentItem.scale9Grid)
                this._content.type = import_cc5.Sprite.Type.SLICED;
              else if (this._contentItem.scaleByTile)
                this._content.type = import_cc5.Sprite.Type.TILED;
              else
                this._content.type = import_cc5.Sprite.Type.SIMPLE;
            } else {
              this._content.type = import_cc5.Sprite.Type.FILLED;
            }
            this._content.__update();
            this.updateLayout();
          }
        } else if (this._contentItem.type == PackageItemType.MovieClip) {
          this._content.interval = this._contentItem.interval;
          this._content.swing = this._contentItem.swing;
          this._content.repeatDelay = this._contentItem.repeatDelay;
          this._content.frames = this._contentItem.frames;
          this.updateLayout();
        } else if (this._contentItem.type == PackageItemType.Component) {
          var obj = UIPackage.createObjectFromURL(itemURL);
          if (!obj)
            this.setErrorState();
          else if (!(obj instanceof GComponent)) {
            obj.dispose();
            this.setErrorState();
          } else {
            this._content2 = obj;
            this._container.addChild(this._content2.node);
            this.updateLayout();
          }
        } else
          this.setErrorState();
      }
      loadFromPackage(itemURL) {
        this._dirtyVersion++;
        let dirtyVersion = this._dirtyVersion;
        let contentItem = UIPackage.getItemByURL(itemURL);
        if (contentItem) {
          contentItem = contentItem.getBranch();
          this.sourceWidth = contentItem.width;
          this.sourceHeight = contentItem.height;
          contentItem = contentItem.getHighResolution();
          if (!UIConfig.enableDelayLoad || contentItem.__loaded && contentItem.decoded || contentItem.type == PackageItemType.Component) {
            contentItem.load();
            this.init(contentItem, itemURL, dirtyVersion);
          } else {
            contentItem.loadAsync().then(() => {
              this.init(contentItem, itemURL, dirtyVersion);
            });
          }
        } else
          this.setErrorState();
      }
      loadExternal() {
        let url = this.url;
        let callback = (err, asset) => {
          if (this.url != url || !(0, import_cc5.isValid)(this._node))
            return;
          if (err) {
            console.warn(err);
            return;
          }
          let assets = [asset];
          if (asset instanceof import_cc5.SpriteFrame)
            this.onExternalLoadSuccess(asset);
          else if (asset instanceof import_cc5.Texture2D) {
            let sp4 = SpritePool.alloc();
            sp4.texture = asset;
            assets.push(sp4);
            this.onExternalLoadSuccess(sp4);
          } else if (asset instanceof import_cc5.ImageAsset) {
            let tex = new import_cc5.Texture2D();
            if (import_cc5.sys.isNative) {
              tex.image = asset;
            } else {
              tex.reset({
                width: asset.width,
                height: asset.height
              });
              tex.uploadData(asset.data);
            }
            let sp4 = SpritePool.alloc();
            sp4.texture = tex;
            assets.push(tex);
            assets.push(sp4);
            this.onExternalLoadSuccess(sp4);
          }
          this.addExternalAssetRef(this._url, assets);
        };
        if (this.url.startsWith("http://") || this.url.startsWith("https://") || this.url.startsWith("/")) {
          if (this.extension) {
            import_cc5.assetManager.loadRemote(this.url, { ext: this.extension }, callback);
          } else {
            import_cc5.assetManager.loadRemote(this.url, callback);
          }
        } else {
          let pkg = import_cc5.resources;
          let assetUrl = this.url;
          if (this.url.startsWith("db://")) {
            let url2 = this.url.substring(5);
            let startIdx = url2.indexOf("/");
            const pkgName = url2.substring(0, startIdx);
            assetUrl = url2.substring(startIdx + 1);
            pkg = import_cc5.assetManager.getBundle(pkgName);
            if (!pkg) {
              console.error(`bundle '${pkgName}' not found`);
              return;
            }
          }
          pkg.load(assetUrl, import_cc5.Asset, callback);
        }
      }
      addExternalAssetRef(url, assets) {
        if (!this._externalAssets[url]) {
          this._externalAssets[url] = assets;
          for (let i = 0; i < assets.length; i++) {
            assets[i].addRef();
          }
        }
      }
      freeExternal() {
        for (const key in this._externalAssets) {
          if (!Object.prototype.hasOwnProperty.call(this._externalAssets, key)) {
            continue;
          }
          const assets = this._externalAssets[key];
          const asset = assets[0];
          for (let i = 0; i < assets.length; i++) {
            let asset2 = assets[i];
            asset2.decRef(UIConfig.autoReleaseAssets);
          }
          if (asset.refCount <= 0 && UIConfig.autoReleaseAssets) {
            for (let i = 1; i < assets.length; i++) {
              let asset2 = assets[i];
              if (asset2.refCount <= 0) {
                if (asset2 instanceof import_cc5.SpriteFrame) {
                  SpritePool.free(asset2);
                } else {
                  import_cc5.assetManager.releaseAsset(asset2);
                }
              }
            }
          }
        }
        this._externalAssets = {};
      }
      onExternalLoadSuccess(texture) {
        this._content.spriteFrame = texture;
        this._content.type = import_cc5.Sprite.Type.SIMPLE;
        this.sourceWidth = texture.getRect().width;
        this.sourceHeight = texture.getRect().height;
        if (this._autoSize)
          this.setSize(this.sourceWidth, this.sourceHeight);
        this.updateLayout();
      }
      onExternalLoadFailed() {
        this.setErrorState();
      }
      setErrorState() {
        if (!this._showErrorSign)
          return;
        if (this._errorSign == null) {
          if (UIConfig.loaderErrorSign != null) {
            this._errorSign = _GLoader._errorSignPool.getObject(UIConfig.loaderErrorSign);
          }
        }
        if (this._errorSign) {
          this._errorSign.setSize(this.width, this.height);
          this._container.addChild(this._errorSign.node);
        }
      }
      clearErrorState() {
        if (this._errorSign) {
          this._container.removeChild(this._errorSign.node);
          _GLoader._errorSignPool.returnObject(this._errorSign);
          this._errorSign = null;
        }
      }
      updateLayout() {
        if (this._content2 == null && this._content == null) {
          if (this._autoSize) {
            this._updatingLayout = true;
            this.setSize(50, 30);
            this._updatingLayout = false;
          }
          return;
        }
        let cw = this.sourceWidth;
        let ch = this.sourceHeight;
        let pivotCorrectX = -this.pivotX * this._width;
        let pivotCorrectY = this.pivotY * this._height;
        if (this._autoSize) {
          this._updatingLayout = true;
          if (cw == 0)
            cw = 50;
          if (ch == 0)
            ch = 30;
          this.setSize(cw, ch);
          this._updatingLayout = false;
          this._container._uiProps.uiTransformComp.setContentSize(this._width, this._height);
          this._container.setPosition(pivotCorrectX, pivotCorrectY);
          if (this._content2) {
            this._content2.setPosition(pivotCorrectX + this._width * this.pivotX, pivotCorrectY - this._height * this.pivotY);
            this._content2.setScale(1, 1);
          }
          if (cw == this._width && ch == this._height)
            return;
        }
        var sx = 1, sy = 1;
        if (this._fill != LoaderFillType.None) {
          sx = this.width / this.sourceWidth;
          sy = this.height / this.sourceHeight;
          if (sx != 1 || sy != 1) {
            if (this._fill == LoaderFillType.ScaleMatchHeight)
              sx = sy;
            else if (this._fill == LoaderFillType.ScaleMatchWidth)
              sy = sx;
            else if (this._fill == LoaderFillType.Scale) {
              if (sx > sy)
                sx = sy;
              else
                sy = sx;
            } else if (this._fill == LoaderFillType.ScaleNoBorder) {
              if (sx > sy)
                sy = sx;
              else
                sx = sy;
            }
            if (this._shrinkOnly) {
              if (sx > 1)
                sx = 1;
              if (sy > 1)
                sy = 1;
            }
            cw = this.sourceWidth * sx;
            ch = this.sourceHeight * sy;
          }
        }
        this._container._uiProps.uiTransformComp.setContentSize(cw, ch);
        if (this._content2) {
          this._content2.setPosition(pivotCorrectX + this._width * this.pivotX, pivotCorrectY - this._height * this.pivotY);
          this._content2.setScale(sx, sy);
        }
        var nx, ny;
        if (this._align == AlignType.Left)
          nx = 0;
        else if (this._align == AlignType.Center)
          nx = Math.floor((this._width - cw) / 2);
        else
          nx = this._width - cw;
        if (this._verticalAlign == VertAlignType.Top)
          ny = 0;
        else if (this._verticalAlign == VertAlignType.Middle)
          ny = Math.floor((this._height - ch) / 2);
        else
          ny = this._height - ch;
        ny = -ny;
        this._container.setPosition(pivotCorrectX + nx, pivotCorrectY + ny);
      }
      clearContent() {
        this.clearErrorState();
        if (this._contentItem) {
          this._contentItem.decRef();
        }
        if (this._content2) {
          this._container.removeChild(this._content2.node);
          this._content2.dispose();
          this._content2 = null;
        }
        this._content.frames = null;
        this._content.spriteFrame = null;
        this._contentItem = null;
        this.freeExternal();
      }
      handleSizeChanged() {
        super.handleSizeChanged();
        if (!this._updatingLayout)
          this.updateLayout();
      }
      handleAnchorChanged() {
        super.handleAnchorChanged();
        if (!this._updatingLayout)
          this.updateLayout();
      }
      handleGrayedChanged() {
        this._content.grayscale = this._grayed;
      }
      _hitTest(pt, globalPt) {
        if (this._content2) {
          let obj = this._content2.hitTest(globalPt);
          if (obj)
            return obj;
        }
        if (pt.x >= 0 && pt.y >= 0 && pt.x < this._width && pt.y < this._height)
          return this;
        else
          return null;
      }
      getProp(index) {
        switch (index) {
          case ObjectPropID.Color:
            return this.color;
          case ObjectPropID.Playing:
            return this.playing;
          case ObjectPropID.Frame:
            return this.frame;
          case ObjectPropID.TimeScale:
            return this._content.timeScale;
          default:
            return super.getProp(index);
        }
      }
      setProp(index, value) {
        switch (index) {
          case ObjectPropID.Color:
            this.color = value;
            break;
          case ObjectPropID.Playing:
            this.playing = value;
            break;
          case ObjectPropID.Frame:
            this.frame = value;
            break;
          case ObjectPropID.TimeScale:
            this._content.timeScale = value;
            break;
          case ObjectPropID.DeltaTime:
            this._content.advance(value);
            break;
          default:
            super.setProp(index, value);
            break;
        }
      }
      setup_beforeAdd(buffer, beginPos) {
        super.setup_beforeAdd(buffer, beginPos);
        buffer.seek(beginPos, 5);
        this._url = buffer.readS();
        this._align = buffer.readByte();
        this._verticalAlign = buffer.readByte();
        this._fill = buffer.readByte();
        this._shrinkOnly = buffer.readBool();
        this._autoSize = buffer.readBool();
        this._showErrorSign = buffer.readBool();
        this._playing = buffer.readBool();
        this._frame = buffer.readInt();
        if (buffer.readBool())
          this.color = buffer.readColor();
        if (this._url)
          this.loadContent();
        this._content.fillMethod = buffer.readByte();
        if (this._content.fillMethod != 0) {
          this._content.fillOrigin = buffer.readByte();
          this._content.fillClockwise = buffer.readBool();
          this._content.fillAmount = buffer.readFloat();
        }
      }
    };
    GLoader._errorSignPool = new GObjectPool();
    GLoader3D = class extends GObject {
      constructor() {
        super();
        this._frame = 0;
        this._node.name = "GLoader3D";
        this._playing = true;
        this._url = "";
        this._fill = LoaderFillType.None;
        this._align = AlignType.Left;
        this._verticalAlign = VertAlignType.Top;
        this._color = new import_cc5.Color(255, 255, 255, 255);
        this._container = new import_cc5.Node("Wrapper");
        this._container.layer = UIConfig.defaultUILayer;
        this._container.addComponent(import_cc5.UITransform).setAnchorPoint(0, 1);
        this._node.addChild(this._container);
      }
      dispose() {
        super.dispose();
      }
      get url() {
        return this._url;
      }
      set url(value) {
        if (this._url == value)
          return;
        this._url = value;
        this.loadContent();
        this.updateGear(7);
      }
      get icon() {
        return this._url;
      }
      set icon(value) {
        this.url = value;
      }
      get align() {
        return this._align;
      }
      set align(value) {
        if (this._align != value) {
          this._align = value;
          this.updateLayout();
        }
      }
      get verticalAlign() {
        return this._verticalAlign;
      }
      set verticalAlign(value) {
        if (this._verticalAlign != value) {
          this._verticalAlign = value;
          this.updateLayout();
        }
      }
      get fill() {
        return this._fill;
      }
      set fill(value) {
        if (this._fill != value) {
          this._fill = value;
          this.updateLayout();
        }
      }
      get shrinkOnly() {
        return this._shrinkOnly;
      }
      set shrinkOnly(value) {
        if (this._shrinkOnly != value) {
          this._shrinkOnly = value;
          this.updateLayout();
        }
      }
      get autoSize() {
        return this._autoSize;
      }
      set autoSize(value) {
        if (this._autoSize != value) {
          this._autoSize = value;
          this.updateLayout();
        }
      }
      get playing() {
        return this._playing;
      }
      set playing(value) {
        if (this._playing != value) {
          this._playing = value;
          this.updateGear(5);
          this.onChange();
        }
      }
      get frame() {
        return this._frame;
      }
      set frame(value) {
        if (this._frame != value) {
          this._frame = value;
          this.updateGear(5);
          this.onChange();
        }
      }
      get animationName() {
        return this._animationName;
      }
      set animationName(value) {
        if (this._animationName != value) {
          this._animationName = value;
          this.onChange();
        }
      }
      get skinName() {
        return this._skinName;
      }
      set skinName(value) {
        if (this._skinName != value) {
          this._skinName = value;
          this.onChange();
        }
      }
      get loop() {
        return this._loop;
      }
      set loop(value) {
        if (this._loop != value) {
          this._loop = value;
          this.onChange();
        }
      }
      get color() {
        return this._color;
      }
      set color(value) {
        this._color.set(value);
        this.updateGear(4);
        if (this._content)
          this._content.color = value;
      }
      get content() {
        return this._content;
      }
      loadContent() {
        this.clearContent();
        if (!this._url)
          return;
        if (this._url.startsWith("ui://"))
          this.loadFromPackage(this._url);
        else
          this.loadExternal();
      }
      loadFromPackage(itemURL) {
        this._contentItem = UIPackage.getItemByURL(itemURL);
        if (this._contentItem) {
          this._contentItem = this._contentItem.getBranch();
          this.sourceWidth = this._contentItem.width;
          this.sourceHeight = this._contentItem.height;
          this._contentItem = this._contentItem.getHighResolution();
          if (this._autoSize)
            this.setSize(this.sourceWidth, this.sourceHeight);
          if (this._contentItem.type == PackageItemType.Spine || this._contentItem.type == PackageItemType.DragonBones)
            this._contentItem.owner.getItemAssetAsync(this._contentItem, this.onLoaded.bind(this));
        }
      }
      onLoaded(err, item) {
        if (this._contentItem != item)
          return;
        if (err)
          console.warn(err);
        if (!this._contentItem.asset)
          return;
        if (this._contentItem.type == PackageItemType.Spine)
          this.setSpine(this._contentItem.asset, this._contentItem.skeletonAnchor);
        else if (this._contentItem.type == PackageItemType.DragonBones)
          this.setDragonBones(this._contentItem.asset, this._contentItem.atlasAsset, this._contentItem.skeletonAnchor);
      }
      setSpine(asset, anchor, pma) {
        this.freeSpine();
        let node = new import_cc5.Node();
        this._container.addChild(node);
        node.layer = UIConfig.defaultUILayer;
        node.setPosition(anchor.x, -anchor.y);
        this._content = node.addComponent(import_cc5.sp.Skeleton);
        this._content.premultipliedAlpha = pma;
        this._content.skeletonData = asset;
        this._content.color = this._color;
        this.onChangeSpine();
        this.updateLayout();
      }
      freeSpine() {
        if (this._content) {
          this._content.destroy();
        }
      }
      setDragonBones(asset, atlasAsset, anchor, pma) {
        this.freeDragonBones();
        let node = new import_cc5.Node();
        node.layer = UIConfig.defaultUILayer;
        this._container.addChild(node);
        node.setPosition(anchor.x, -anchor.y);
        this._content = node.addComponent(import_cc5.dragonBones.ArmatureDisplay);
        this._content.premultipliedAlpha = pma;
        this._content.dragonAsset = asset;
        this._content.dragonAtlasAsset = atlasAsset;
        this._content.color = this._color;
        let armatureKey = asset["init"](import_cc5.dragonBones.CCFactory.getInstance(), atlasAsset["_uuid"]);
        let dragonBonesData = this._content["_factory"].getDragonBonesData(armatureKey);
        this._content.armatureName = dragonBonesData.armatureNames[0];
        this.onChangeDragonBones();
        this.updateLayout();
      }
      freeDragonBones() {
        if (this._content) {
          this._content.destroy();
        }
      }
      onChange() {
        if (this._contentItem == null)
          return;
        if (this._contentItem.type == PackageItemType.Spine) {
          this.onChangeSpine();
        }
        if (this._contentItem.type == PackageItemType.DragonBones) {
          this.onChangeDragonBones();
        }
      }
      onChangeSpine() {
        var _a;
        if (!(this._content instanceof import_cc5.sp.Skeleton))
          return;
        if (this._animationName) {
          let trackEntry = this._content.getCurrent(0);
          if (!trackEntry || trackEntry.animation.name != this._animationName || trackEntry.isComplete() && !trackEntry.loop) {
            this._content.animation = this._animationName;
            trackEntry = this._content.setAnimation(0, this._animationName, this._loop);
          }
          if (this._playing)
            this._content.paused = false;
          else {
            this._content.paused = true;
            trackEntry.trackTime = import_cc5.math.lerp(0, trackEntry.animationEnd - trackEntry.animationStart, this._frame / 100);
          }
        } else
          this._content.clearTrack(0);
        let skin = this._skinName || this._content.skeletonData.getRuntimeData().skins[0].name;
        if (((_a = this._content["_skeleton"].skin) === null || _a === void 0 ? void 0 : _a.name) != skin)
          this._content.setSkin(skin);
      }
      onChangeDragonBones() {
        if (!(this._content instanceof import_cc5.dragonBones.ArmatureDisplay))
          return;
        if (this._animationName) {
          if (this._playing)
            this._content.playAnimation(this._animationName, this._loop ? 0 : 1);
          else
            this._content.armature().animation.gotoAndStopByFrame(this._animationName, this._frame);
        } else
          this._content.armature().animation.reset();
      }
      loadExternal() {
        if (this._url.startsWith("http://") || this._url.startsWith("https://") || this._url.startsWith("/"))
          import_cc5.assetManager.loadRemote(this._url, import_cc5.sp.SkeletonData, this.onLoaded2.bind(this));
        else
          import_cc5.resources.load(this._url, import_cc5.sp.SkeletonData, this.onLoaded2.bind(this));
      }
      onLoaded2(err, asset) {
        if (!this._url || !(0, import_cc5.isValid)(this._node))
          return;
        if (err)
          console.warn(err);
      }
      updateLayout() {
        let cw = this.sourceWidth;
        let ch = this.sourceHeight;
        let pivotCorrectX = -this.pivotX * this._width;
        let pivotCorrectY = this.pivotY * this._height;
        if (this._autoSize) {
          this._updatingLayout = true;
          if (cw == 0)
            cw = 50;
          if (ch == 0)
            ch = 30;
          this.setSize(cw, ch);
          this._updatingLayout = false;
          if (cw == this._width && ch == this._height) {
            this._container.setScale(1, 1);
            this._container.setPosition(pivotCorrectX, pivotCorrectY);
            return;
          }
        }
        var sx = 1, sy = 1;
        if (this._fill != LoaderFillType.None) {
          sx = this.width / this.sourceWidth;
          sy = this.height / this.sourceHeight;
          if (sx != 1 || sy != 1) {
            if (this._fill == LoaderFillType.ScaleMatchHeight)
              sx = sy;
            else if (this._fill == LoaderFillType.ScaleMatchWidth)
              sy = sx;
            else if (this._fill == LoaderFillType.Scale) {
              if (sx > sy)
                sx = sy;
              else
                sy = sx;
            } else if (this._fill == LoaderFillType.ScaleNoBorder) {
              if (sx > sy)
                sy = sx;
              else
                sx = sy;
            }
            if (this._shrinkOnly) {
              if (sx > 1)
                sx = 1;
              if (sy > 1)
                sy = 1;
            }
            cw = this.sourceWidth * sx;
            ch = this.sourceHeight * sy;
          }
        }
        this._container.setScale(sx, sy);
        var nx, ny;
        if (this._align == AlignType.Left)
          nx = 0;
        else if (this._align == AlignType.Center)
          nx = Math.floor((this._width - cw) / 2);
        else
          nx = this._width - cw;
        if (this._verticalAlign == VertAlignType.Top)
          ny = 0;
        else if (this._verticalAlign == VertAlignType.Middle)
          ny = Math.floor((this._height - ch) / 2);
        else
          ny = this._height - ch;
        ny = -ny;
        this._container.setPosition(pivotCorrectX + nx, pivotCorrectY + ny);
      }
      clearContent() {
        this._contentItem = null;
        if (this._content) {
          this._content.node.destroy();
          this._content = null;
        }
      }
      handleSizeChanged() {
        super.handleSizeChanged();
        if (!this._updatingLayout)
          this.updateLayout();
      }
      handleAnchorChanged() {
        super.handleAnchorChanged();
        if (!this._updatingLayout)
          this.updateLayout();
      }
      handleGrayedChanged() {
      }
      getProp(index) {
        switch (index) {
          case ObjectPropID.Color:
            return this.color;
          case ObjectPropID.Playing:
            return this.playing;
          case ObjectPropID.Frame:
            return this.frame;
          case ObjectPropID.TimeScale:
            return 1;
          default:
            return super.getProp(index);
        }
      }
      setProp(index, value) {
        switch (index) {
          case ObjectPropID.Color:
            this.color = value;
            break;
          case ObjectPropID.Playing:
            this.playing = value;
            break;
          case ObjectPropID.Frame:
            this.frame = value;
            break;
          case ObjectPropID.TimeScale:
            break;
          case ObjectPropID.DeltaTime:
            break;
          default:
            super.setProp(index, value);
            break;
        }
      }
      setup_beforeAdd(buffer, beginPos) {
        super.setup_beforeAdd(buffer, beginPos);
        buffer.seek(beginPos, 5);
        this._url = buffer.readS();
        this._align = buffer.readByte();
        this._verticalAlign = buffer.readByte();
        this._fill = buffer.readByte();
        this._shrinkOnly = buffer.readBool();
        this._autoSize = buffer.readBool();
        this._animationName = buffer.readS();
        this._skinName = buffer.readS();
        this._playing = buffer.readBool();
        this._frame = buffer.readInt();
        this._loop = buffer.readBool();
        if (buffer.readBool())
          this.color = buffer.readColor();
        if (this._url)
          this.loadContent();
      }
    };
    GLabel = class extends GComponent {
      constructor() {
        super();
        this._node.name = "GLabel";
      }
      get icon() {
        if (this._iconObject)
          return this._iconObject.icon;
      }
      set icon(value) {
        if (this._iconObject)
          this._iconObject.icon = value;
        this.updateGear(7);
      }
      get title() {
        if (this._titleObject)
          return this._titleObject.text;
        else
          return null;
      }
      set title(value) {
        if (this._titleObject)
          this._titleObject.text = value;
        this.updateGear(6);
      }
      get text() {
        return this.title;
      }
      set text(value) {
        this.title = value;
      }
      get titleColor() {
        var tf = this.getTextField();
        if (tf)
          return tf.color;
        else
          return import_cc5.Color.WHITE;
      }
      set titleColor(value) {
        var tf = this.getTextField();
        if (tf)
          tf.color = value;
        this.updateGear(4);
      }
      get titleFontSize() {
        var tf = this.getTextField();
        if (tf)
          return tf.fontSize;
        else
          return 0;
      }
      set titleFontSize(value) {
        var tf = this.getTextField();
        if (tf)
          tf.fontSize = value;
      }
      set editable(val) {
        if (this._titleObject && this._titleObject instanceof GTextInput)
          this._titleObject.editable = val;
      }
      get editable() {
        if (this._titleObject && this._titleObject instanceof GTextInput)
          return this._titleObject.editable;
        else
          return false;
      }
      getTextField() {
        if (this._titleObject instanceof GTextField)
          return this._titleObject;
        else if ("getTextField" in this._titleObject)
          return this._titleObject.getTextField();
        else
          return null;
      }
      getProp(index) {
        switch (index) {
          case ObjectPropID.Color:
            return this.titleColor;
          case ObjectPropID.OutlineColor: {
            var tf = this.getTextField();
            if (tf)
              return tf.strokeColor;
            else
              return 0;
          }
          case ObjectPropID.FontSize:
            return this.titleFontSize;
          default:
            return super.getProp(index);
        }
      }
      setProp(index, value) {
        switch (index) {
          case ObjectPropID.Color:
            this.titleColor = value;
            break;
          case ObjectPropID.OutlineColor:
            {
              var tf = this.getTextField();
              if (tf)
                tf.strokeColor = value;
            }
            break;
          case ObjectPropID.FontSize:
            this.titleFontSize = value;
            break;
          default:
            super.setProp(index, value);
            break;
        }
      }
      constructExtension(buffer) {
        this._titleObject = this.getChild("title");
        this._iconObject = this.getChild("icon");
      }
      setup_afterAdd(buffer, beginPos) {
        super.setup_afterAdd(buffer, beginPos);
        if (!buffer.seek(beginPos, 6))
          return;
        if (buffer.readByte() != this.packageItem.objectType)
          return;
        var str;
        str = buffer.readS();
        if (str != null)
          this.title = str;
        str = buffer.readS();
        if (str != null)
          this.icon = str;
        if (buffer.readBool())
          this.titleColor = buffer.readColor();
        var iv = buffer.readInt();
        if (iv != 0)
          this.titleFontSize = iv;
        if (buffer.readBool()) {
          var input = this.getTextField();
          if (input instanceof GTextInput) {
            str = buffer.readS();
            if (str != null)
              input.promptText = str;
            str = buffer.readS();
            if (str != null)
              input.restrict = str;
            iv = buffer.readInt();
            if (iv != 0)
              input.maxLength = iv;
            iv = buffer.readInt();
            if (buffer.readBool())
              input.password = true;
          } else
            buffer.skip(13);
        }
        str = buffer.readS();
        if (str != null) {
          this._sound = str;
          if (buffer.readBool()) {
            this._soundVolumeScale = buffer.readFloat();
          }
          this._node.on(Event.CLICK, this.onClick_1, this);
        }
      }
      onClick_1() {
        if (this._sound) {
          var pi = UIPackage.getItemByURL(this._sound);
          if (pi) {
            var sound = pi.owner.getItemAsset(pi);
            if (sound)
              GRoot.inst.playOneShotSound(sound, this._soundVolumeScale);
          }
        }
      }
    };
    GButton = class _GButton extends GComponent {
      constructor() {
        super();
        this._node.name = "GButton";
        this._mode = ButtonMode.Common;
        this._title = "";
        this._icon = "";
        this._sound = UIConfig.buttonSound;
        this._soundVolumeScale = UIConfig.buttonSoundVolumeScale;
        this._changeStateOnClick = true;
        this._downEffect = 0;
        this._downEffectValue = 0.8;
      }
      get downEffect() {
        return this._downEffect;
      }
      set downEffect(value) {
        this._downEffect = value;
      }
      get icon() {
        return this._icon;
      }
      set icon(value) {
        this._icon = value;
        value = this._selected && this._selectedIcon ? this._selectedIcon : this._icon;
        if (this._iconObject)
          this._iconObject.icon = value;
        this.updateGear(7);
      }
      get selectedIcon() {
        return this._selectedIcon;
      }
      set selectedIcon(value) {
        this._selectedIcon = value;
        value = this._selected && this._selectedIcon ? this._selectedIcon : this._icon;
        if (this._iconObject)
          this._iconObject.icon = value;
      }
      get title() {
        return this._title;
      }
      set title(value) {
        this._title = value;
        if (this._titleObject)
          this._titleObject.text = this._selected && this._selectedTitle ? this._selectedTitle : this._title;
        this.updateGear(6);
      }
      get text() {
        return this.title;
      }
      set text(value) {
        this.title = value;
      }
      get selectedTitle() {
        return this._selectedTitle;
      }
      set selectedTitle(value) {
        this._selectedTitle = value;
        if (this._titleObject)
          this._titleObject.text = this._selected && this._selectedTitle ? this._selectedTitle : this._title;
      }
      get titleColor() {
        var tf = this.getTextField();
        if (tf)
          return tf.color;
        else
          return import_cc5.Color.BLACK;
      }
      set titleColor(value) {
        var tf = this.getTextField();
        if (tf)
          tf.color = value;
      }
      get titleFontSize() {
        var tf = this.getTextField();
        if (tf)
          return tf.fontSize;
        else
          return 0;
      }
      set titleFontSize(value) {
        var tf = this.getTextField();
        if (tf)
          tf.fontSize = value;
      }
      get sound() {
        return this._sound;
      }
      set sound(val) {
        this._sound = val;
      }
      get soundVolumeScale() {
        return this._soundVolumeScale;
      }
      set soundVolumeScale(value) {
        this._soundVolumeScale = value;
      }
      set selected(val) {
        if (this._mode == ButtonMode.Common)
          return;
        if (this._selected != val) {
          this._selected = val;
          this.setCurrentState();
          if (this._selectedTitle && this._titleObject)
            this._titleObject.text = this._selected ? this._selectedTitle : this._title;
          if (this._selectedIcon) {
            var str = this._selected ? this._selectedIcon : this._icon;
            if (this._iconObject)
              this._iconObject.icon = str;
          }
          if (this._relatedController && this._parent && !this._parent._buildingDisplayList) {
            if (this._selected) {
              this._relatedController.selectedPageId = this._relatedPageId;
              if (this._relatedController.autoRadioGroupDepth)
                this._parent.adjustRadioGroupDepth(this, this._relatedController);
            } else if (this._mode == ButtonMode.Check && this._relatedController.selectedPageId == this._relatedPageId)
              this._relatedController.oppositePageId = this._relatedPageId;
          }
        }
      }
      get selected() {
        return this._selected;
      }
      get mode() {
        return this._mode;
      }
      set mode(value) {
        if (this._mode != value) {
          if (value == ButtonMode.Common)
            this.selected = false;
          this._mode = value;
        }
      }
      get relatedController() {
        return this._relatedController;
      }
      set relatedController(val) {
        this._relatedController = val;
      }
      get relatedPageId() {
        return this._relatedPageId;
      }
      set relatedPageId(val) {
        this._relatedPageId = val;
      }
      get changeStateOnClick() {
        return this._changeStateOnClick;
      }
      set changeStateOnClick(value) {
        this._changeStateOnClick = value;
      }
      get linkedPopup() {
        return this._linkedPopup;
      }
      set linkedPopup(value) {
        this._linkedPopup = value;
      }
      getTextField() {
        if (this._titleObject instanceof GTextField)
          return this._titleObject;
        else if ("getTextField" in this._titleObject)
          return this._titleObject.getTextField();
        else
          return null;
      }
      fireClick() {
        GRoot.inst.inputProcessor.simulateClick(this);
      }
      setState(val) {
        if (this._buttonController)
          this._buttonController.selectedPage = val;
        if (this._downEffect == 1) {
          var cnt = this.numChildren;
          if (val == _GButton.DOWN || val == _GButton.SELECTED_OVER || val == _GButton.SELECTED_DISABLED) {
            if (!this._downColor)
              this._downColor = new import_cc5.Color();
            var r = this._downEffectValue * 255;
            this._downColor.r = this._downColor.g = this._downColor.b = r;
            for (var i = 0; i < cnt; i++) {
              var obj = this.getChildAt(i);
              if (!(obj instanceof GTextField))
                obj.setProp(ObjectPropID.Color, this._downColor);
            }
          } else {
            for (var i = 0; i < cnt; i++) {
              var obj = this.getChildAt(i);
              if (!(obj instanceof GTextField))
                obj.setProp(ObjectPropID.Color, import_cc5.Color.WHITE);
            }
          }
        } else if (this._downEffect == 2) {
          if (val == _GButton.DOWN || val == _GButton.SELECTED_OVER || val == _GButton.SELECTED_DISABLED) {
            if (!this._downScaled) {
              this._downScaled = true;
              this.setScale(this.scaleX * this._downEffectValue, this.scaleY * this._downEffectValue);
            }
          } else {
            if (this._downScaled) {
              this._downScaled = false;
              this.setScale(this.scaleX / this._downEffectValue, this.scaleY / this._downEffectValue);
            }
          }
        }
      }
      setCurrentState() {
        if (this.grayed && this._buttonController && this._buttonController.hasPage(_GButton.DISABLED)) {
          if (this._selected)
            this.setState(_GButton.SELECTED_DISABLED);
          else
            this.setState(_GButton.DISABLED);
        } else {
          if (this._selected)
            this.setState(this._over ? _GButton.SELECTED_OVER : _GButton.DOWN);
          else
            this.setState(this._over ? _GButton.OVER : _GButton.UP);
        }
      }
      handleControllerChanged(c) {
        super.handleControllerChanged(c);
        if (this._relatedController == c)
          this.selected = this._relatedPageId == c.selectedPageId;
      }
      handleGrayedChanged() {
        if (this._buttonController && this._buttonController.hasPage(_GButton.DISABLED)) {
          if (this.grayed) {
            if (this._selected && this._buttonController.hasPage(_GButton.SELECTED_DISABLED))
              this.setState(_GButton.SELECTED_DISABLED);
            else
              this.setState(_GButton.DISABLED);
          } else if (this._selected)
            this.setState(_GButton.DOWN);
          else
            this.setState(_GButton.UP);
        } else
          super.handleGrayedChanged();
      }
      getProp(index) {
        switch (index) {
          case ObjectPropID.Color:
            return this.titleColor;
          case ObjectPropID.OutlineColor: {
            var tf = this.getTextField();
            if (tf)
              return tf.strokeColor;
            else
              return 0;
          }
          case ObjectPropID.FontSize:
            return this.titleFontSize;
          case ObjectPropID.Selected:
            return this.selected;
          default:
            return super.getProp(index);
        }
      }
      setProp(index, value) {
        switch (index) {
          case ObjectPropID.Color:
            this.titleColor = value;
            break;
          case ObjectPropID.OutlineColor:
            {
              var tf = this.getTextField();
              if (tf)
                tf.strokeColor = value;
            }
            break;
          case ObjectPropID.FontSize:
            this.titleFontSize = value;
            break;
          case ObjectPropID.Selected:
            this.selected = value;
            break;
          default:
            super.setProp(index, value);
            break;
        }
      }
      constructExtension(buffer) {
        buffer.seek(0, 6);
        this._mode = buffer.readByte();
        var str = buffer.readS();
        if (str)
          this._sound = str;
        this._soundVolumeScale = buffer.readFloat();
        this._downEffect = buffer.readByte();
        this._downEffectValue = buffer.readFloat();
        if (this._downEffect == 2)
          this.setPivot(0.5, 0.5, this.pivotAsAnchor);
        this._buttonController = this.getController("button");
        this._titleObject = this.getChild("title");
        this._iconObject = this.getChild("icon");
        if (this._titleObject)
          this._title = this._titleObject.text;
        if (this._iconObject)
          this._icon = this._iconObject.icon;
        if (this._mode == ButtonMode.Common)
          this.setState(_GButton.UP);
        this._node.on(Event.TOUCH_BEGIN, this.onTouchBegin_1, this);
        this._node.on(Event.TOUCH_END, this.onTouchEnd_1, this);
        this._node.on(Event.ROLL_OVER, this.onRollOver_1, this);
        this._node.on(Event.ROLL_OUT, this.onRollOut_1, this);
        this._node.on(Event.CLICK, this.onClick_1, this);
      }
      setup_afterAdd(buffer, beginPos) {
        super.setup_afterAdd(buffer, beginPos);
        if (!buffer.seek(beginPos, 6))
          return;
        if (buffer.readByte() != this.packageItem.objectType)
          return;
        var str;
        var iv;
        str = buffer.readS();
        if (str != null)
          this.title = str;
        str = buffer.readS();
        if (str != null)
          this.selectedTitle = str;
        str = buffer.readS();
        if (str != null)
          this.icon = str;
        str = buffer.readS();
        if (str != null)
          this.selectedIcon = str;
        if (buffer.readBool())
          this.titleColor = buffer.readColor();
        iv = buffer.readInt();
        if (iv != 0)
          this.titleFontSize = iv;
        iv = buffer.readShort();
        if (iv >= 0)
          this._relatedController = this.parent.getControllerAt(iv);
        this._relatedPageId = buffer.readS();
        str = buffer.readS();
        if (str != null)
          this._sound = str;
        if (buffer.readBool())
          this._soundVolumeScale = buffer.readFloat();
        this.selected = buffer.readBool();
      }
      onRollOver_1() {
        if (!this._buttonController || !this._buttonController.hasPage(_GButton.OVER))
          return;
        this._over = true;
        if (this._down)
          return;
        if (this.grayed && this._buttonController.hasPage(_GButton.DISABLED))
          return;
        this.setState(this._selected ? _GButton.SELECTED_OVER : _GButton.OVER);
      }
      onRollOut_1() {
        if (!this._buttonController || !this._buttonController.hasPage(_GButton.OVER))
          return;
        this._over = false;
        if (this._down)
          return;
        if (this.grayed && this._buttonController.hasPage(_GButton.DISABLED))
          return;
        this.setState(this._selected ? _GButton.DOWN : _GButton.UP);
      }
      onTouchBegin_1(evt) {
        if (evt.button != import_cc5.EventMouse.BUTTON_LEFT)
          return;
        this._down = true;
        evt.captureTouch();
        if (this._mode == ButtonMode.Common) {
          if (this.grayed && this._buttonController && this._buttonController.hasPage(_GButton.DISABLED))
            this.setState(_GButton.SELECTED_DISABLED);
          else
            this.setState(_GButton.DOWN);
        }
        if (this._linkedPopup) {
          if (this._linkedPopup instanceof Window)
            this._linkedPopup.toggleStatus();
          else
            GRoot.inst.togglePopup(this._linkedPopup, this);
        }
      }
      onTouchEnd_1(evt) {
        if (evt.button != import_cc5.EventMouse.BUTTON_LEFT)
          return;
        if (this._down) {
          this._down = false;
          if (this._node == null)
            return;
          if (this._mode == ButtonMode.Common) {
            if (this.grayed && this._buttonController && this._buttonController.hasPage(_GButton.DISABLED))
              this.setState(_GButton.DISABLED);
            else if (this._over)
              this.setState(_GButton.OVER);
            else
              this.setState(_GButton.UP);
          } else {
            if (!this._over && this._buttonController != null && (this._buttonController.selectedPage == _GButton.OVER || this._buttonController.selectedPage == _GButton.SELECTED_OVER)) {
              this.setCurrentState();
            }
          }
        }
      }
      onClick_1() {
        if (this._sound) {
          var pi = UIPackage.getItemByURL(this._sound);
          if (pi) {
            var sound = pi.owner.getItemAsset(pi);
            if (sound)
              GRoot.inst.playOneShotSound(sound, this._soundVolumeScale);
          }
        }
        if (this._mode == ButtonMode.Check) {
          if (this._changeStateOnClick) {
            this.selected = !this._selected;
            this._node.emit(Event.STATUS_CHANGED, this);
          }
        } else if (this._mode == ButtonMode.Radio) {
          if (this._changeStateOnClick && !this._selected) {
            this.selected = true;
            this._node.emit(Event.STATUS_CHANGED, this);
          }
        } else {
          if (this._relatedController)
            this._relatedController.selectedPageId = this._relatedPageId;
        }
      }
    };
    GButton.UP = "up";
    GButton.DOWN = "down";
    GButton.OVER = "over";
    GButton.SELECTED_OVER = "selectedOver";
    GButton.DISABLED = "disabled";
    GButton.SELECTED_DISABLED = "selectedDisabled";
    GList = class extends GComponent {
      constructor() {
        super();
        this.scrollItemToViewOnClick = true;
        this.foldInvisibleItems = false;
        this._lineCount = 0;
        this._columnCount = 0;
        this._lineGap = 0;
        this._columnGap = 0;
        this._lastSelectedIndex = 0;
        this._numItems = 0;
        this._realNumItems = 0;
        this._firstIndex = 0;
        this._curLineItemCount = 0;
        this._curLineItemCount2 = 0;
        this._virtualListChanged = 0;
        this.itemInfoVer = 0;
        this._node.name = "GList";
        this._trackBounds = true;
        this._pool = new GObjectPool();
        this._layout = ListLayoutType.SingleColumn;
        this._autoResizeItem = true;
        this._lastSelectedIndex = -1;
        this._selectionMode = ListSelectionMode.Single;
        this.opaque = true;
        this._align = AlignType.Left;
        this._verticalAlign = VertAlignType.Top;
      }
      dispose() {
        this._partner.unschedule(this._refreshVirtualList);
        this._pool.clear();
        super.dispose();
      }
      get layout() {
        return this._layout;
      }
      set layout(value) {
        if (this._layout != value) {
          this._layout = value;
          this.setBoundsChangedFlag();
          if (this._virtual)
            this.setVirtualListChangedFlag(true);
        }
      }
      get lineCount() {
        return this._lineCount;
      }
      set lineCount(value) {
        if (this._lineCount != value) {
          this._lineCount = value;
          this.setBoundsChangedFlag();
          if (this._virtual)
            this.setVirtualListChangedFlag(true);
        }
      }
      get columnCount() {
        return this._columnCount;
      }
      set columnCount(value) {
        if (this._columnCount != value) {
          this._columnCount = value;
          this.setBoundsChangedFlag();
          if (this._virtual)
            this.setVirtualListChangedFlag(true);
        }
      }
      get lineGap() {
        return this._lineGap;
      }
      set lineGap(value) {
        if (this._lineGap != value) {
          this._lineGap = value;
          this.setBoundsChangedFlag();
          if (this._virtual)
            this.setVirtualListChangedFlag(true);
        }
      }
      get columnGap() {
        return this._columnGap;
      }
      set columnGap(value) {
        if (this._columnGap != value) {
          this._columnGap = value;
          this.setBoundsChangedFlag();
          if (this._virtual)
            this.setVirtualListChangedFlag(true);
        }
      }
      get align() {
        return this._align;
      }
      set align(value) {
        if (this._align != value) {
          this._align = value;
          this.setBoundsChangedFlag();
          if (this._virtual)
            this.setVirtualListChangedFlag(true);
        }
      }
      get verticalAlign() {
        return this._verticalAlign;
      }
      set verticalAlign(value) {
        if (this._verticalAlign != value) {
          this._verticalAlign = value;
          this.setBoundsChangedFlag();
          if (this._virtual)
            this.setVirtualListChangedFlag(true);
        }
      }
      get virtualItemSize() {
        return this._itemSize;
      }
      set virtualItemSize(value) {
        if (this._virtual) {
          if (this._itemSize == null)
            this._itemSize = new import_cc5.Size(0, 0);
          this._itemSize.width = value.width;
          this._itemSize.height = value.height;
          this.setVirtualListChangedFlag(true);
        }
      }
      get defaultItem() {
        return this._defaultItem;
      }
      set defaultItem(val) {
        this._defaultItem = UIPackage.normalizeURL(val);
      }
      get autoResizeItem() {
        return this._autoResizeItem;
      }
      set autoResizeItem(value) {
        if (this._autoResizeItem != value) {
          this._autoResizeItem = value;
          this.setBoundsChangedFlag();
          if (this._virtual)
            this.setVirtualListChangedFlag(true);
        }
      }
      get selectionMode() {
        return this._selectionMode;
      }
      set selectionMode(value) {
        this._selectionMode = value;
      }
      get selectionController() {
        return this._selectionController;
      }
      set selectionController(value) {
        this._selectionController = value;
      }
      get itemPool() {
        return this._pool;
      }
      getFromPool(url) {
        if (!url)
          url = this._defaultItem;
        var obj = this._pool.getObject(url);
        if (obj)
          obj.visible = true;
        return obj;
      }
      returnToPool(obj) {
        this._pool.returnObject(obj);
      }
      addChildAt(child, index) {
        super.addChildAt(child, index);
        if (child instanceof GButton) {
          child.selected = false;
          child.changeStateOnClick = false;
        }
        child.on(Event.CLICK, this.onClickItem, this);
        return child;
      }
      addItem(url) {
        if (!url)
          url = this._defaultItem;
        return this.addChild(UIPackage.createObjectFromURL(url));
      }
      addItemFromPool(url) {
        return this.addChild(this.getFromPool(url));
      }
      removeChildAt(index, dispose) {
        var child = super.removeChildAt(index, dispose);
        if (!dispose)
          child.off(Event.CLICK, this.onClickItem, this);
        return child;
      }
      removeChildToPoolAt(index) {
        var child = super.removeChildAt(index);
        this.returnToPool(child);
      }
      removeChildToPool(child) {
        super.removeChild(child);
        this.returnToPool(child);
      }
      removeChildrenToPool(beginIndex, endIndex) {
        if (beginIndex == void 0)
          beginIndex = 0;
        if (endIndex == void 0)
          endIndex = -1;
        if (endIndex < 0 || endIndex >= this._children.length)
          endIndex = this._children.length - 1;
        for (var i = beginIndex; i <= endIndex; ++i)
          this.removeChildToPoolAt(beginIndex);
      }
      get selectedIndex() {
        var i;
        if (this._virtual) {
          for (i = 0; i < this._realNumItems; i++) {
            var ii = this._virtualItems[i];
            if (ii.obj instanceof GButton && ii.obj.selected || !ii.obj && ii.selected) {
              if (this._loop)
                return i % this._numItems;
              else
                return i;
            }
          }
        } else {
          var cnt = this._children.length;
          for (i = 0; i < cnt; i++) {
            var obj = this._children[i];
            if (obj instanceof GButton && obj.selected)
              return i;
          }
        }
        return -1;
      }
      set selectedIndex(value) {
        if (value >= 0 && value < this.numItems) {
          if (this._selectionMode != ListSelectionMode.Single)
            this.clearSelection();
          this.addSelection(value);
        } else
          this.clearSelection();
      }
      getSelection(result) {
        if (!result)
          result = new Array();
        var i;
        if (this._virtual) {
          for (i = 0; i < this._realNumItems; i++) {
            var ii = this._virtualItems[i];
            if (ii.obj instanceof GButton && ii.obj.selected || !ii.obj && ii.selected) {
              var j = i;
              if (this._loop) {
                j = i % this._numItems;
                if (result.indexOf(j) != -1)
                  continue;
              }
              result.push(j);
            }
          }
        } else {
          var cnt = this._children.length;
          for (i = 0; i < cnt; i++) {
            var obj = this._children[i];
            if (obj instanceof GButton && obj.selected)
              result.push(i);
          }
        }
        return result;
      }
      addSelection(index, scrollItToView) {
        if (this._selectionMode == ListSelectionMode.None)
          return;
        this.checkVirtualList();
        if (this._selectionMode == ListSelectionMode.Single)
          this.clearSelection();
        if (scrollItToView)
          this.scrollToView(index);
        this._lastSelectedIndex = index;
        var obj;
        if (this._virtual) {
          var ii = this._virtualItems[index];
          if (ii.obj)
            obj = ii.obj;
          ii.selected = true;
        } else
          obj = this.getChildAt(index);
        if (obj instanceof GButton && !obj.selected) {
          obj.selected = true;
          this.updateSelectionController(index);
        }
      }
      removeSelection(index) {
        if (this._selectionMode == ListSelectionMode.None)
          return;
        var obj;
        if (this._virtual) {
          var ii = this._virtualItems[index];
          if (ii.obj)
            obj = ii.obj;
          ii.selected = false;
        } else
          obj = this.getChildAt(index);
        if (obj instanceof GButton)
          obj.selected = false;
      }
      clearSelection() {
        var i;
        if (this._virtual) {
          for (i = 0; i < this._realNumItems; i++) {
            var ii = this._virtualItems[i];
            if (ii.obj instanceof GButton)
              ii.obj.selected = false;
            ii.selected = false;
          }
        } else {
          var cnt = this._children.length;
          for (i = 0; i < cnt; i++) {
            var obj = this._children[i];
            if (obj instanceof GButton)
              obj.selected = false;
          }
        }
      }
      clearSelectionExcept(g) {
        var i;
        if (this._virtual) {
          for (i = 0; i < this._realNumItems; i++) {
            var ii = this._virtualItems[i];
            if (ii.obj != g) {
              if (ii.obj instanceof GButton)
                ii.obj.selected = false;
              ii.selected = false;
            }
          }
        } else {
          var cnt = this._children.length;
          for (i = 0; i < cnt; i++) {
            var obj = this._children[i];
            if (obj instanceof GButton && obj != g)
              obj.selected = false;
          }
        }
      }
      selectAll() {
        this.checkVirtualList();
        var last = -1;
        var i;
        if (this._virtual) {
          for (i = 0; i < this._realNumItems; i++) {
            var ii = this._virtualItems[i];
            if (ii.obj instanceof GButton && !ii.obj.selected) {
              ii.obj.selected = true;
              last = i;
            }
            ii.selected = true;
          }
        } else {
          var cnt = this._children.length;
          for (i = 0; i < cnt; i++) {
            var obj = this._children[i];
            if (obj instanceof GButton && !obj.selected) {
              obj.selected = true;
              last = i;
            }
          }
        }
        if (last != -1)
          this.updateSelectionController(last);
      }
      selectNone() {
        this.clearSelection();
      }
      selectReverse() {
        this.checkVirtualList();
        var last = -1;
        var i;
        if (this._virtual) {
          for (i = 0; i < this._realNumItems; i++) {
            var ii = this._virtualItems[i];
            if (ii.obj instanceof GButton) {
              ii.obj.selected = !ii.obj.selected;
              if (ii.obj.selected)
                last = i;
            }
            ii.selected = !ii.selected;
          }
        } else {
          var cnt = this._children.length;
          for (i = 0; i < cnt; i++) {
            var obj = this._children[i];
            if (obj instanceof GButton) {
              obj.selected = !obj.selected;
              if (obj.selected)
                last = i;
            }
          }
        }
        if (last != -1)
          this.updateSelectionController(last);
      }
      handleArrowKey(dir) {
        var index = this.selectedIndex;
        if (index == -1)
          return;
        switch (dir) {
          case 1:
            if (this._layout == ListLayoutType.SingleColumn || this._layout == ListLayoutType.FlowVertical) {
              index--;
              if (index >= 0) {
                this.clearSelection();
                this.addSelection(index, true);
              }
            } else if (this._layout == ListLayoutType.FlowHorizontal || this._layout == ListLayoutType.Pagination) {
              var current = this._children[index];
              var k = 0;
              for (var i = index - 1; i >= 0; i--) {
                var obj = this._children[i];
                if (obj.y != current.y) {
                  current = obj;
                  break;
                }
                k++;
              }
              for (; i >= 0; i--) {
                obj = this._children[i];
                if (obj.y != current.y) {
                  this.clearSelection();
                  this.addSelection(i + k + 1, true);
                  break;
                }
              }
            }
            break;
          case 3:
            if (this._layout == ListLayoutType.SingleRow || this._layout == ListLayoutType.FlowHorizontal || this._layout == ListLayoutType.Pagination) {
              index++;
              if (index < this._children.length) {
                this.clearSelection();
                this.addSelection(index, true);
              }
            } else if (this._layout == ListLayoutType.FlowVertical) {
              current = this._children[index];
              k = 0;
              var cnt = this._children.length;
              for (i = index + 1; i < cnt; i++) {
                obj = this._children[i];
                if (obj.x != current.x) {
                  current = obj;
                  break;
                }
                k++;
              }
              for (; i < cnt; i++) {
                obj = this._children[i];
                if (obj.x != current.x) {
                  this.clearSelection();
                  this.addSelection(i - k - 1, true);
                  break;
                }
              }
            }
            break;
          case 5:
            if (this._layout == ListLayoutType.SingleColumn || this._layout == ListLayoutType.FlowVertical) {
              index++;
              if (index < this._children.length) {
                this.clearSelection();
                this.addSelection(index, true);
              }
            } else if (this._layout == ListLayoutType.FlowHorizontal || this._layout == ListLayoutType.Pagination) {
              current = this._children[index];
              k = 0;
              cnt = this._children.length;
              for (i = index + 1; i < cnt; i++) {
                obj = this._children[i];
                if (obj.y != current.y) {
                  current = obj;
                  break;
                }
                k++;
              }
              for (; i < cnt; i++) {
                obj = this._children[i];
                if (obj.y != current.y) {
                  this.clearSelection();
                  this.addSelection(i - k - 1, true);
                  break;
                }
              }
            }
            break;
          case 7:
            if (this._layout == ListLayoutType.SingleRow || this._layout == ListLayoutType.FlowHorizontal || this._layout == ListLayoutType.Pagination) {
              index--;
              if (index >= 0) {
                this.clearSelection();
                this.addSelection(index, true);
              }
            } else if (this._layout == ListLayoutType.FlowVertical) {
              current = this._children[index];
              k = 0;
              for (i = index - 1; i >= 0; i--) {
                obj = this._children[i];
                if (obj.x != current.x) {
                  current = obj;
                  break;
                }
                k++;
              }
              for (; i >= 0; i--) {
                obj = this._children[i];
                if (obj.x != current.x) {
                  this.clearSelection();
                  this.addSelection(i + k + 1, true);
                  break;
                }
              }
            }
            break;
        }
      }
      onClickItem(evt) {
        if (this._scrollPane && this._scrollPane.isDragged)
          return;
        var item = GObject.cast(evt.currentTarget);
        this.setSelectionOnEvent(item, evt);
        if (this._scrollPane && this.scrollItemToViewOnClick)
          this._scrollPane.scrollToView(item, true);
        this.dispatchItemEvent(item, evt);
      }
      dispatchItemEvent(item, evt) {
        this._node.emit(Event.CLICK_ITEM, item, evt);
      }
      setSelectionOnEvent(item, evt) {
        if (!(item instanceof GButton) || this._selectionMode == ListSelectionMode.None)
          return;
        var dontChangeLastIndex = false;
        var index = this.childIndexToItemIndex(this.getChildIndex(item));
        if (this._selectionMode == ListSelectionMode.Single) {
          if (!item.selected) {
            this.clearSelectionExcept(item);
            item.selected = true;
          }
        } else {
          if (evt.isShiftDown) {
            if (!item.selected) {
              if (this._lastSelectedIndex != -1) {
                var min = Math.min(this._lastSelectedIndex, index);
                var max = Math.max(this._lastSelectedIndex, index);
                max = Math.min(max, this.numItems - 1);
                var i;
                if (this._virtual) {
                  for (i = min; i <= max; i++) {
                    var ii = this._virtualItems[i];
                    if (ii.obj instanceof GButton)
                      ii.obj.selected = true;
                    ii.selected = true;
                  }
                } else {
                  for (i = min; i <= max; i++) {
                    var obj = this.getChildAt(i);
                    if (obj instanceof GButton)
                      obj.selected = true;
                  }
                }
                dontChangeLastIndex = true;
              } else {
                item.selected = true;
              }
            }
          } else if (evt.isCtrlDown || this._selectionMode == ListSelectionMode.Multiple_SingleClick) {
            item.selected = !item.selected;
          } else {
            if (!item.selected) {
              this.clearSelectionExcept(item);
              item.selected = true;
            } else
              this.clearSelectionExcept(item);
          }
        }
        if (!dontChangeLastIndex)
          this._lastSelectedIndex = index;
        if (item.selected)
          this.updateSelectionController(index);
      }
      resizeToFit(itemCount = Number.POSITIVE_INFINITY, minSize = 0) {
        this.ensureBoundsCorrect();
        var curCount = this.numItems;
        if (itemCount > curCount)
          itemCount = curCount;
        if (this._virtual) {
          var lineCount = Math.ceil(itemCount / this._curLineItemCount);
          if (this._layout == ListLayoutType.SingleColumn || this._layout == ListLayoutType.FlowHorizontal)
            this.viewHeight = lineCount * this._itemSize.height + Math.max(0, lineCount - 1) * this._lineGap;
          else
            this.viewWidth = lineCount * this._itemSize.width + Math.max(0, lineCount - 1) * this._columnGap;
        } else if (itemCount == 0) {
          if (this._layout == ListLayoutType.SingleColumn || this._layout == ListLayoutType.FlowHorizontal)
            this.viewHeight = minSize;
          else
            this.viewWidth = minSize;
        } else {
          var i = itemCount - 1;
          var obj = null;
          while (i >= 0) {
            obj = this.getChildAt(i);
            if (!this.foldInvisibleItems || obj.visible)
              break;
            i--;
          }
          if (i < 0) {
            if (this._layout == ListLayoutType.SingleColumn || this._layout == ListLayoutType.FlowHorizontal)
              this.viewHeight = minSize;
            else
              this.viewWidth = minSize;
          } else {
            var size = 0;
            if (this._layout == ListLayoutType.SingleColumn || this._layout == ListLayoutType.FlowHorizontal) {
              size = obj.y + obj.height;
              if (size < minSize)
                size = minSize;
              this.viewHeight = size;
            } else {
              size = obj.x + obj.width;
              if (size < minSize)
                size = minSize;
              this.viewWidth = size;
            }
          }
        }
      }
      getMaxItemWidth() {
        var cnt = this._children.length;
        var max = 0;
        for (var i = 0; i < cnt; i++) {
          var child = this.getChildAt(i);
          if (child.width > max)
            max = child.width;
        }
        return max;
      }
      handleSizeChanged() {
        super.handleSizeChanged();
        this.setBoundsChangedFlag();
        if (this._virtual)
          this.setVirtualListChangedFlag(true);
      }
      handleControllerChanged(c) {
        super.handleControllerChanged(c);
        if (this._selectionController == c)
          this.selectedIndex = c.selectedIndex;
      }
      updateSelectionController(index) {
        if (this._selectionController && !this._selectionController.changing && index < this._selectionController.pageCount) {
          var c = this._selectionController;
          this._selectionController = null;
          c.selectedIndex = index;
          this._selectionController = c;
        }
      }
      getSnappingPosition(xValue, yValue, resultPoint) {
        if (this._virtual) {
          resultPoint = resultPoint || new import_cc5.Vec2();
          var saved;
          var index;
          if (this._layout == ListLayoutType.SingleColumn || this._layout == ListLayoutType.FlowHorizontal) {
            saved = yValue;
            s_n = yValue;
            index = this.getIndexOnPos1(false);
            yValue = s_n;
            if (index < this._virtualItems.length && saved - yValue > this._virtualItems[index].height / 2 && index < this._realNumItems)
              yValue += this._virtualItems[index].height + this._lineGap;
          } else if (this._layout == ListLayoutType.SingleRow || this._layout == ListLayoutType.FlowVertical) {
            saved = xValue;
            s_n = xValue;
            index = this.getIndexOnPos2(false);
            xValue = s_n;
            if (index < this._virtualItems.length && saved - xValue > this._virtualItems[index].width / 2 && index < this._realNumItems)
              xValue += this._virtualItems[index].width + this._columnGap;
          } else {
            saved = xValue;
            s_n = xValue;
            index = this.getIndexOnPos3(false);
            xValue = s_n;
            if (index < this._virtualItems.length && saved - xValue > this._virtualItems[index].width / 2 && index < this._realNumItems)
              xValue += this._virtualItems[index].width + this._columnGap;
          }
          resultPoint.x = xValue;
          resultPoint.y = yValue;
          return resultPoint;
        } else {
          return super.getSnappingPosition(xValue, yValue, resultPoint);
        }
      }
      scrollToView(index, ani, setFirst) {
        if (this._virtual) {
          if (this._numItems == 0)
            return;
          this.checkVirtualList();
          if (index >= this._virtualItems.length)
            throw "Invalid child index: " + index + ">" + this._virtualItems.length;
          if (this._loop)
            index = Math.floor(this._firstIndex / this._numItems) * this._numItems + index;
          var rect;
          var ii = this._virtualItems[index];
          var pos = 0;
          var i;
          if (this._layout == ListLayoutType.SingleColumn || this._layout == ListLayoutType.FlowHorizontal) {
            for (i = this._curLineItemCount - 1; i < index; i += this._curLineItemCount)
              pos += this._virtualItems[i].height + this._lineGap;
            rect = new import_cc5.Rect(0, pos, this._itemSize.width, ii.height);
          } else if (this._layout == ListLayoutType.SingleRow || this._layout == ListLayoutType.FlowVertical) {
            for (i = this._curLineItemCount - 1; i < index; i += this._curLineItemCount)
              pos += this._virtualItems[i].width + this._columnGap;
            rect = new import_cc5.Rect(pos, 0, ii.width, this._itemSize.height);
          } else {
            var page = index / (this._curLineItemCount * this._curLineItemCount2);
            rect = new import_cc5.Rect(page * this.viewWidth + index % this._curLineItemCount * (ii.width + this._columnGap), index / this._curLineItemCount % this._curLineItemCount2 * (ii.height + this._lineGap), ii.width, ii.height);
          }
          if (this._scrollPane)
            this._scrollPane.scrollToView(rect, ani, setFirst);
        } else {
          var obj = this.getChildAt(index);
          if (obj) {
            if (this._scrollPane)
              this._scrollPane.scrollToView(obj, ani, setFirst);
            else if (this.parent && this.parent.scrollPane)
              this.parent.scrollPane.scrollToView(obj, ani, setFirst);
          }
        }
      }
      getFirstChildInView() {
        return this.childIndexToItemIndex(super.getFirstChildInView());
      }
      childIndexToItemIndex(index) {
        if (!this._virtual)
          return index;
        if (this._layout == ListLayoutType.Pagination) {
          for (var i = this._firstIndex; i < this._realNumItems; i++) {
            if (this._virtualItems[i].obj) {
              index--;
              if (index < 0)
                return i;
            }
          }
          return index;
        } else {
          index += this._firstIndex;
          if (this._loop && this._numItems > 0)
            index = index % this._numItems;
          return index;
        }
      }
      itemIndexToChildIndex(index) {
        if (!this._virtual)
          return index;
        if (this._layout == ListLayoutType.Pagination) {
          return this.getChildIndex(this._virtualItems[index].obj);
        } else {
          if (this._loop && this._numItems > 0) {
            var j = this._firstIndex % this._numItems;
            if (index >= j)
              index = index - j;
            else
              index = this._numItems - j + index;
          } else
            index -= this._firstIndex;
          return index;
        }
      }
      setVirtual() {
        this._setVirtual(false);
      }
      /// <summary>
      /// Set the list to be virtual list, and has loop behavior.
      /// </summary>
      setVirtualAndLoop() {
        this._setVirtual(true);
      }
      /// <summary>
      /// Set the list to be virtual list.
      /// </summary>
      _setVirtual(loop) {
        if (!this._virtual) {
          if (!this._scrollPane)
            throw "Virtual list must be scrollable!";
          if (loop) {
            if (this._layout == ListLayoutType.FlowHorizontal || this._layout == ListLayoutType.FlowVertical)
              throw "Loop list is not supported for FlowHorizontal or FlowVertical layout!";
            this._scrollPane.bouncebackEffect = false;
          }
          this._virtual = true;
          this._loop = loop;
          this._virtualItems = new Array();
          this.removeChildrenToPool();
          if (this._itemSize == null) {
            this._itemSize = new import_cc5.Size(0, 0);
            var obj = this.getFromPool(null);
            if (!obj) {
              throw "Virtual List must have a default list item resource.";
            } else {
              this._itemSize.width = obj.width;
              this._itemSize.height = obj.height;
            }
            this.returnToPool(obj);
          }
          if (this._layout == ListLayoutType.SingleColumn || this._layout == ListLayoutType.FlowHorizontal) {
            this._scrollPane.scrollStep = this._itemSize.height;
            if (this._loop)
              this._scrollPane._loop = 2;
          } else {
            this._scrollPane.scrollStep = this._itemSize.width;
            if (this._loop)
              this._scrollPane._loop = 1;
          }
          this._node.on(Event.SCROLL, this.__scrolled, this);
          this.setVirtualListChangedFlag(true);
        }
      }
      /// <summary>
      /// Set the list item count. 
      /// If the list is not virtual, specified number of items will be created. 
      /// If the list is virtual, only items in view will be created.
      /// </summary>
      get numItems() {
        if (this._virtual)
          return this._numItems;
        else
          return this._children.length;
      }
      set numItems(value) {
        if (this._virtual) {
          if (this.itemRenderer == null)
            throw "Set itemRenderer first!";
          this._numItems = value;
          if (this._loop)
            this._realNumItems = this._numItems * 6;
          else
            this._realNumItems = this._numItems;
          var oldCount = this._virtualItems.length;
          if (this._realNumItems > oldCount) {
            for (i = oldCount; i < this._realNumItems; i++) {
              var ii = {
                width: this._itemSize.width,
                height: this._itemSize.height,
                updateFlag: 0
              };
              this._virtualItems.push(ii);
            }
          } else {
            for (i = this._realNumItems; i < oldCount; i++)
              this._virtualItems[i].selected = false;
          }
          if (this._virtualListChanged != 0)
            this._partner.unschedule(this._refreshVirtualList);
          this._refreshVirtualList();
        } else {
          var cnt = this._children.length;
          if (value > cnt) {
            for (var i = cnt; i < value; i++) {
              if (this.itemProvider == null)
                this.addItemFromPool();
              else
                this.addItemFromPool(this.itemProvider(i));
            }
          } else {
            this.removeChildrenToPool(value, cnt);
          }
          if (this.itemRenderer != null) {
            for (i = 0; i < value; i++)
              this.itemRenderer(i, this.getChildAt(i));
          }
        }
      }
      refreshVirtualList() {
        this.setVirtualListChangedFlag(false);
      }
      checkVirtualList() {
        if (this._virtualListChanged != 0) {
          this._refreshVirtualList();
          this._partner.unschedule(this._refreshVirtualList);
        }
      }
      setVirtualListChangedFlag(layoutChanged) {
        if (layoutChanged)
          this._virtualListChanged = 2;
        else if (this._virtualListChanged == 0)
          this._virtualListChanged = 1;
        this._partner.callLater(this._refreshVirtualList);
      }
      _refreshVirtualList(dt) {
        if (!isNaN(dt)) {
          let _t = GObject.cast(this.node);
          _t._refreshVirtualList();
          return;
        }
        var layoutChanged = this._virtualListChanged == 2;
        this._virtualListChanged = 0;
        this._eventLocked = true;
        if (layoutChanged) {
          if (this._layout == ListLayoutType.SingleColumn || this._layout == ListLayoutType.SingleRow)
            this._curLineItemCount = 1;
          else if (this._layout == ListLayoutType.FlowHorizontal) {
            if (this._columnCount > 0)
              this._curLineItemCount = this._columnCount;
            else {
              this._curLineItemCount = Math.floor((this._scrollPane.viewWidth + this._columnGap) / (this._itemSize.width + this._columnGap));
              if (this._curLineItemCount <= 0)
                this._curLineItemCount = 1;
            }
          } else if (this._layout == ListLayoutType.FlowVertical) {
            if (this._lineCount > 0)
              this._curLineItemCount = this._lineCount;
            else {
              this._curLineItemCount = Math.floor((this._scrollPane.viewHeight + this._lineGap) / (this._itemSize.height + this._lineGap));
              if (this._curLineItemCount <= 0)
                this._curLineItemCount = 1;
            }
          } else {
            if (this._columnCount > 0)
              this._curLineItemCount = this._columnCount;
            else {
              this._curLineItemCount = Math.floor((this._scrollPane.viewWidth + this._columnGap) / (this._itemSize.width + this._columnGap));
              if (this._curLineItemCount <= 0)
                this._curLineItemCount = 1;
            }
            if (this._lineCount > 0)
              this._curLineItemCount2 = this._lineCount;
            else {
              this._curLineItemCount2 = Math.floor((this._scrollPane.viewHeight + this._lineGap) / (this._itemSize.height + this._lineGap));
              if (this._curLineItemCount2 <= 0)
                this._curLineItemCount2 = 1;
            }
          }
        }
        var ch = 0, cw = 0;
        if (this._realNumItems > 0) {
          var i;
          var len = Math.ceil(this._realNumItems / this._curLineItemCount) * this._curLineItemCount;
          var len2 = Math.min(this._curLineItemCount, this._realNumItems);
          if (this._layout == ListLayoutType.SingleColumn || this._layout == ListLayoutType.FlowHorizontal) {
            for (i = 0; i < len; i += this._curLineItemCount)
              ch += this._virtualItems[i].height + this._lineGap;
            if (ch > 0)
              ch -= this._lineGap;
            if (this._autoResizeItem)
              cw = this._scrollPane.viewWidth;
            else {
              for (i = 0; i < len2; i++)
                cw += this._virtualItems[i].width + this._columnGap;
              if (cw > 0)
                cw -= this._columnGap;
            }
          } else if (this._layout == ListLayoutType.SingleRow || this._layout == ListLayoutType.FlowVertical) {
            for (i = 0; i < len; i += this._curLineItemCount)
              cw += this._virtualItems[i].width + this._columnGap;
            if (cw > 0)
              cw -= this._columnGap;
            if (this._autoResizeItem)
              ch = this._scrollPane.viewHeight;
            else {
              for (i = 0; i < len2; i++)
                ch += this._virtualItems[i].height + this._lineGap;
              if (ch > 0)
                ch -= this._lineGap;
            }
          } else {
            var pageCount = Math.ceil(len / (this._curLineItemCount * this._curLineItemCount2));
            cw = pageCount * this.viewWidth;
            ch = this.viewHeight;
          }
        }
        this.handleAlign(cw, ch);
        this._scrollPane.setContentSize(cw, ch);
        this._eventLocked = false;
        this.handleScroll(true);
      }
      __scrolled(evt) {
        this.handleScroll(false);
      }
      getIndexOnPos1(forceUpdate) {
        if (this._realNumItems < this._curLineItemCount) {
          s_n = 0;
          return 0;
        }
        var i;
        var pos2;
        var pos3;
        if (this.numChildren > 0 && !forceUpdate) {
          pos2 = this.getChildAt(0).y;
          if (pos2 > s_n) {
            for (i = this._firstIndex - this._curLineItemCount; i >= 0; i -= this._curLineItemCount) {
              pos2 -= this._virtualItems[i].height + this._lineGap;
              if (pos2 <= s_n) {
                s_n = pos2;
                return i;
              }
            }
            s_n = 0;
            return 0;
          } else {
            for (i = this._firstIndex; i < this._realNumItems; i += this._curLineItemCount) {
              pos3 = pos2 + this._virtualItems[i].height + this._lineGap;
              if (pos3 > s_n) {
                s_n = pos2;
                return i;
              }
              pos2 = pos3;
            }
            s_n = pos2;
            return this._realNumItems - this._curLineItemCount;
          }
        } else {
          pos2 = 0;
          for (i = 0; i < this._realNumItems; i += this._curLineItemCount) {
            pos3 = pos2 + this._virtualItems[i].height + this._lineGap;
            if (pos3 > s_n) {
              s_n = pos2;
              return i;
            }
            pos2 = pos3;
          }
          s_n = pos2;
          return this._realNumItems - this._curLineItemCount;
        }
      }
      getIndexOnPos2(forceUpdate) {
        if (this._realNumItems < this._curLineItemCount) {
          s_n = 0;
          return 0;
        }
        var i;
        var pos2;
        var pos3;
        if (this.numChildren > 0 && !forceUpdate) {
          pos2 = this.getChildAt(0).x;
          if (pos2 > s_n) {
            for (i = this._firstIndex - this._curLineItemCount; i >= 0; i -= this._curLineItemCount) {
              pos2 -= this._virtualItems[i].width + this._columnGap;
              if (pos2 <= s_n) {
                s_n = pos2;
                return i;
              }
            }
            s_n = 0;
            return 0;
          } else {
            for (i = this._firstIndex; i < this._realNumItems; i += this._curLineItemCount) {
              pos3 = pos2 + this._virtualItems[i].width + this._columnGap;
              if (pos3 > s_n) {
                s_n = pos2;
                return i;
              }
              pos2 = pos3;
            }
            s_n = pos2;
            return this._realNumItems - this._curLineItemCount;
          }
        } else {
          pos2 = 0;
          for (i = 0; i < this._realNumItems; i += this._curLineItemCount) {
            pos3 = pos2 + this._virtualItems[i].width + this._columnGap;
            if (pos3 > s_n) {
              s_n = pos2;
              return i;
            }
            pos2 = pos3;
          }
          s_n = pos2;
          return this._realNumItems - this._curLineItemCount;
        }
      }
      getIndexOnPos3(forceUpdate) {
        if (this._realNumItems < this._curLineItemCount) {
          s_n = 0;
          return 0;
        }
        var viewWidth = this.viewWidth;
        var page = Math.floor(s_n / viewWidth);
        var startIndex = page * (this._curLineItemCount * this._curLineItemCount2);
        var pos2 = page * viewWidth;
        var i;
        var pos3;
        for (i = 0; i < this._curLineItemCount; i++) {
          pos3 = pos2 + this._virtualItems[startIndex + i].width + this._columnGap;
          if (pos3 > s_n) {
            s_n = pos2;
            return startIndex + i;
          }
          pos2 = pos3;
        }
        s_n = pos2;
        return startIndex + this._curLineItemCount - 1;
      }
      handleScroll(forceUpdate) {
        if (this._eventLocked)
          return;
        if (this._layout == ListLayoutType.SingleColumn || this._layout == ListLayoutType.FlowHorizontal) {
          var enterCounter = 0;
          while (this.handleScroll1(forceUpdate)) {
            enterCounter++;
            forceUpdate = false;
            if (enterCounter > 20) {
              console.log("FairyGUI: list will never be filled as the item renderer function always returns a different size.");
              break;
            }
          }
          this.handleArchOrder1();
        } else if (this._layout == ListLayoutType.SingleRow || this._layout == ListLayoutType.FlowVertical) {
          enterCounter = 0;
          while (this.handleScroll2(forceUpdate)) {
            enterCounter++;
            forceUpdate = false;
            if (enterCounter > 20) {
              console.log("FairyGUI: list will never be filled as the item renderer function always returns a different size.");
              break;
            }
          }
          this.handleArchOrder2();
        } else {
          this.handleScroll3(forceUpdate);
        }
        this._boundsChanged = false;
      }
      handleScroll1(forceUpdate) {
        var pos = this._scrollPane.scrollingPosY;
        var max = pos + this._scrollPane.viewHeight;
        var end = max == this._scrollPane.contentHeight;
        s_n = pos;
        var newFirstIndex = this.getIndexOnPos1(forceUpdate);
        pos = s_n;
        if (newFirstIndex == this._firstIndex && !forceUpdate) {
          return false;
        }
        var oldFirstIndex = this._firstIndex;
        this._firstIndex = newFirstIndex;
        var curIndex = newFirstIndex;
        var forward = oldFirstIndex > newFirstIndex;
        var childCount = this.numChildren;
        var lastIndex = oldFirstIndex + childCount - 1;
        var reuseIndex = forward ? lastIndex : oldFirstIndex;
        var curX = 0, curY = pos;
        var needRender;
        var deltaSize = 0;
        var firstItemDeltaSize = 0;
        var url = this._defaultItem;
        var ii, ii2;
        var i, j;
        var partSize = (this._scrollPane.viewWidth - this._columnGap * (this._curLineItemCount - 1)) / this._curLineItemCount;
        this.itemInfoVer++;
        while (curIndex < this._realNumItems && (end || curY < max)) {
          ii = this._virtualItems[curIndex];
          if (!ii.obj || forceUpdate) {
            if (this.itemProvider != null) {
              url = this.itemProvider(curIndex % this._numItems);
              if (url == null)
                url = this._defaultItem;
              url = UIPackage.normalizeURL(url);
            }
            if (ii.obj && ii.obj.resourceURL != url) {
              if (ii.obj instanceof GButton)
                ii.selected = ii.obj.selected;
              this.removeChildToPool(ii.obj);
              ii.obj = null;
            }
          }
          if (!ii.obj) {
            if (forward) {
              for (j = reuseIndex; j >= oldFirstIndex; j--) {
                ii2 = this._virtualItems[j];
                if (ii2.obj && ii2.updateFlag != this.itemInfoVer && ii2.obj.resourceURL == url) {
                  if (ii2.obj instanceof GButton)
                    ii2.selected = ii2.obj.selected;
                  ii.obj = ii2.obj;
                  ii2.obj = null;
                  if (j == reuseIndex)
                    reuseIndex--;
                  break;
                }
              }
            } else {
              for (j = reuseIndex; j <= lastIndex; j++) {
                ii2 = this._virtualItems[j];
                if (ii2.obj && ii2.updateFlag != this.itemInfoVer && ii2.obj.resourceURL == url) {
                  if (ii2.obj instanceof GButton)
                    ii2.selected = ii2.obj.selected;
                  ii.obj = ii2.obj;
                  ii2.obj = null;
                  if (j == reuseIndex)
                    reuseIndex++;
                  break;
                }
              }
            }
            if (ii.obj) {
              this.setChildIndex(ii.obj, forward ? curIndex - newFirstIndex : this.numChildren);
            } else {
              ii.obj = this._pool.getObject(url);
              if (forward)
                this.addChildAt(ii.obj, curIndex - newFirstIndex);
              else
                this.addChild(ii.obj);
            }
            if (ii.obj instanceof GButton)
              ii.obj.selected = ii.selected;
            needRender = true;
          } else
            needRender = forceUpdate;
          if (needRender) {
            if (this._autoResizeItem && (this._layout == ListLayoutType.SingleColumn || this._columnCount > 0))
              ii.obj.setSize(partSize, ii.obj.height, true);
            this.itemRenderer(curIndex % this._numItems, ii.obj);
            if (curIndex % this._curLineItemCount == 0) {
              deltaSize += Math.ceil(ii.obj.height) - ii.height;
              if (curIndex == newFirstIndex && oldFirstIndex > newFirstIndex) {
                firstItemDeltaSize = Math.ceil(ii.obj.height) - ii.height;
              }
            }
            ii.width = Math.ceil(ii.obj.width);
            ii.height = Math.ceil(ii.obj.height);
          }
          ii.updateFlag = this.itemInfoVer;
          ii.obj.setPosition(curX, curY);
          if (curIndex == newFirstIndex)
            max += ii.height;
          curX += ii.width + this._columnGap;
          if (curIndex % this._curLineItemCount == this._curLineItemCount - 1) {
            curX = 0;
            curY += ii.height + this._lineGap;
          }
          curIndex++;
        }
        for (i = 0; i < childCount; i++) {
          ii = this._virtualItems[oldFirstIndex + i];
          if (ii.updateFlag != this.itemInfoVer && ii.obj) {
            if (ii.obj instanceof GButton)
              ii.selected = ii.obj.selected;
            this.removeChildToPool(ii.obj);
            ii.obj = null;
          }
        }
        childCount = this._children.length;
        for (i = 0; i < childCount; i++) {
          let obj = this._virtualItems[newFirstIndex + i].obj;
          if (this._children[i] != obj)
            this.setChildIndex(obj, i);
        }
        if (deltaSize != 0 || firstItemDeltaSize != 0)
          this._scrollPane.changeContentSizeOnScrolling(0, deltaSize, 0, firstItemDeltaSize);
        if (curIndex > 0 && this.numChildren > 0 && this._container.position.y <= 0 && this.getChildAt(0).y > -this._container.position.y)
          return true;
        else
          return false;
      }
      handleScroll2(forceUpdate) {
        var pos = this._scrollPane.scrollingPosX;
        var max = pos + this._scrollPane.viewWidth;
        var end = pos == this._scrollPane.contentWidth;
        s_n = pos;
        var newFirstIndex = this.getIndexOnPos2(forceUpdate);
        pos = s_n;
        if (newFirstIndex == this._firstIndex && !forceUpdate) {
          return false;
        }
        var oldFirstIndex = this._firstIndex;
        this._firstIndex = newFirstIndex;
        var curIndex = newFirstIndex;
        var forward = oldFirstIndex > newFirstIndex;
        var childCount = this.numChildren;
        var lastIndex = oldFirstIndex + childCount - 1;
        var reuseIndex = forward ? lastIndex : oldFirstIndex;
        var curX = pos, curY = 0;
        var needRender;
        var deltaSize = 0;
        var firstItemDeltaSize = 0;
        var url = this._defaultItem;
        var ii, ii2;
        var i, j;
        var partSize = (this._scrollPane.viewHeight - this._lineGap * (this._curLineItemCount - 1)) / this._curLineItemCount;
        this.itemInfoVer++;
        while (curIndex < this._realNumItems && (end || curX < max)) {
          ii = this._virtualItems[curIndex];
          if (!ii.obj || forceUpdate) {
            if (this.itemProvider != null) {
              url = this.itemProvider(curIndex % this._numItems);
              if (url == null)
                url = this._defaultItem;
              url = UIPackage.normalizeURL(url);
            }
            if (ii.obj && ii.obj.resourceURL != url) {
              if (ii.obj instanceof GButton)
                ii.selected = ii.obj.selected;
              this.removeChildToPool(ii.obj);
              ii.obj = null;
            }
          }
          if (!ii.obj) {
            if (forward) {
              for (j = reuseIndex; j >= oldFirstIndex; j--) {
                ii2 = this._virtualItems[j];
                if (ii2.obj && ii2.updateFlag != this.itemInfoVer && ii2.obj.resourceURL == url) {
                  if (ii2.obj instanceof GButton)
                    ii2.selected = ii2.obj.selected;
                  ii.obj = ii2.obj;
                  ii2.obj = null;
                  if (j == reuseIndex)
                    reuseIndex--;
                  break;
                }
              }
            } else {
              for (j = reuseIndex; j <= lastIndex; j++) {
                ii2 = this._virtualItems[j];
                if (ii2.obj && ii2.updateFlag != this.itemInfoVer && ii2.obj.resourceURL == url) {
                  if (ii2.obj instanceof GButton)
                    ii2.selected = ii2.obj.selected;
                  ii.obj = ii2.obj;
                  ii2.obj = null;
                  if (j == reuseIndex)
                    reuseIndex++;
                  break;
                }
              }
            }
            if (ii.obj) {
              this.setChildIndex(ii.obj, forward ? curIndex - newFirstIndex : this.numChildren);
            } else {
              ii.obj = this._pool.getObject(url);
              if (forward)
                this.addChildAt(ii.obj, curIndex - newFirstIndex);
              else
                this.addChild(ii.obj);
            }
            if (ii.obj instanceof GButton)
              ii.obj.selected = ii.selected;
            needRender = true;
          } else
            needRender = forceUpdate;
          if (needRender) {
            if (this._autoResizeItem && (this._layout == ListLayoutType.SingleRow || this._lineCount > 0))
              ii.obj.setSize(ii.obj.width, partSize, true);
            this.itemRenderer(curIndex % this._numItems, ii.obj);
            if (curIndex % this._curLineItemCount == 0) {
              deltaSize += Math.ceil(ii.obj.width) - ii.width;
              if (curIndex == newFirstIndex && oldFirstIndex > newFirstIndex) {
                firstItemDeltaSize = Math.ceil(ii.obj.width) - ii.width;
              }
            }
            ii.width = Math.ceil(ii.obj.width);
            ii.height = Math.ceil(ii.obj.height);
          }
          ii.updateFlag = this.itemInfoVer;
          ii.obj.setPosition(curX, curY);
          if (curIndex == newFirstIndex)
            max += ii.width;
          curY += ii.height + this._lineGap;
          if (curIndex % this._curLineItemCount == this._curLineItemCount - 1) {
            curY = 0;
            curX += ii.width + this._columnGap;
          }
          curIndex++;
        }
        for (i = 0; i < childCount; i++) {
          ii = this._virtualItems[oldFirstIndex + i];
          if (ii.updateFlag != this.itemInfoVer && ii.obj) {
            if (ii.obj instanceof GButton)
              ii.selected = ii.obj.selected;
            this.removeChildToPool(ii.obj);
            ii.obj = null;
          }
        }
        childCount = this._children.length;
        for (i = 0; i < childCount; i++) {
          let obj = this._virtualItems[newFirstIndex + i].obj;
          if (this._children[i] != obj)
            this.setChildIndex(obj, i);
        }
        if (deltaSize != 0 || firstItemDeltaSize != 0)
          this._scrollPane.changeContentSizeOnScrolling(deltaSize, 0, firstItemDeltaSize, 0);
        if (curIndex > 0 && this.numChildren > 0 && this._container.position.x <= 0 && this.getChildAt(0).x > -this._container.position.x)
          return true;
        else
          return false;
      }
      handleScroll3(forceUpdate) {
        var pos = this._scrollPane.scrollingPosX;
        s_n = pos;
        var newFirstIndex = this.getIndexOnPos3(forceUpdate);
        pos = s_n;
        if (newFirstIndex == this._firstIndex && !forceUpdate)
          return;
        var oldFirstIndex = this._firstIndex;
        this._firstIndex = newFirstIndex;
        var reuseIndex = oldFirstIndex;
        var virtualItemCount = this._virtualItems.length;
        var pageSize = this._curLineItemCount * this._curLineItemCount2;
        var startCol = newFirstIndex % this._curLineItemCount;
        var viewWidth = this.viewWidth;
        var page = Math.floor(newFirstIndex / pageSize);
        var startIndex = page * pageSize;
        var lastIndex = startIndex + pageSize * 2;
        var needRender;
        var i;
        var ii, ii2;
        var col;
        var url = this._defaultItem;
        var partWidth = (this._scrollPane.viewWidth - this._columnGap * (this._curLineItemCount - 1)) / this._curLineItemCount;
        var partHeight = (this._scrollPane.viewHeight - this._lineGap * (this._curLineItemCount2 - 1)) / this._curLineItemCount2;
        this.itemInfoVer++;
        for (i = startIndex; i < lastIndex; i++) {
          if (i >= this._realNumItems)
            continue;
          col = i % this._curLineItemCount;
          if (i - startIndex < pageSize) {
            if (col < startCol)
              continue;
          } else {
            if (col > startCol)
              continue;
          }
          ii = this._virtualItems[i];
          ii.updateFlag = this.itemInfoVer;
        }
        var lastObj = null;
        var insertIndex = 0;
        for (i = startIndex; i < lastIndex; i++) {
          if (i >= this._realNumItems)
            continue;
          ii = this._virtualItems[i];
          if (ii.updateFlag != this.itemInfoVer)
            continue;
          if (!ii.obj) {
            while (reuseIndex < virtualItemCount) {
              ii2 = this._virtualItems[reuseIndex];
              if (ii2.obj && ii2.updateFlag != this.itemInfoVer) {
                if (ii2.obj instanceof GButton)
                  ii2.selected = ii2.obj.selected;
                ii.obj = ii2.obj;
                ii2.obj = null;
                break;
              }
              reuseIndex++;
            }
            if (insertIndex == -1)
              insertIndex = this.getChildIndex(lastObj) + 1;
            if (!ii.obj) {
              if (this.itemProvider != null) {
                url = this.itemProvider(i % this._numItems);
                if (url == null)
                  url = this._defaultItem;
                url = UIPackage.normalizeURL(url);
              }
              ii.obj = this._pool.getObject(url);
              this.addChildAt(ii.obj, insertIndex);
            } else {
              insertIndex = this.setChildIndexBefore(ii.obj, insertIndex);
            }
            insertIndex++;
            if (ii.obj instanceof GButton)
              ii.obj.selected = ii.selected;
            needRender = true;
          } else {
            needRender = forceUpdate;
            insertIndex = -1;
            lastObj = ii.obj;
          }
          if (needRender) {
            if (this._autoResizeItem) {
              if (this._curLineItemCount == this._columnCount && this._curLineItemCount2 == this._lineCount)
                ii.obj.setSize(partWidth, partHeight, true);
              else if (this._curLineItemCount == this._columnCount)
                ii.obj.setSize(partWidth, ii.obj.height, true);
              else if (this._curLineItemCount2 == this._lineCount)
                ii.obj.setSize(ii.obj.width, partHeight, true);
            }
            this.itemRenderer(i % this._numItems, ii.obj);
            ii.width = Math.ceil(ii.obj.width);
            ii.height = Math.ceil(ii.obj.height);
          }
        }
        var borderX = startIndex / pageSize * viewWidth;
        var xx = borderX;
        var yy = 0;
        var lineHeight = 0;
        for (i = startIndex; i < lastIndex; i++) {
          if (i >= this._realNumItems)
            continue;
          ii = this._virtualItems[i];
          if (ii.updateFlag == this.itemInfoVer)
            ii.obj.setPosition(xx, yy);
          if (ii.height > lineHeight)
            lineHeight = ii.height;
          if (i % this._curLineItemCount == this._curLineItemCount - 1) {
            xx = borderX;
            yy += lineHeight + this._lineGap;
            lineHeight = 0;
            if (i == startIndex + pageSize - 1) {
              borderX += viewWidth;
              xx = borderX;
              yy = 0;
            }
          } else
            xx += ii.width + this._columnGap;
        }
        for (i = reuseIndex; i < virtualItemCount; i++) {
          ii = this._virtualItems[i];
          if (ii.updateFlag != this.itemInfoVer && ii.obj) {
            if (ii.obj instanceof GButton)
              ii.selected = ii.obj.selected;
            this.removeChildToPool(ii.obj);
            ii.obj = null;
          }
        }
      }
      handleArchOrder1() {
        if (this._childrenRenderOrder == ChildrenRenderOrder.Arch) {
          var mid = this._scrollPane.posY + this.viewHeight / 2;
          var minDist = Number.POSITIVE_INFINITY;
          var dist = 0;
          var apexIndex = 0;
          var cnt = this.numChildren;
          for (var i = 0; i < cnt; i++) {
            var obj = this.getChildAt(i);
            if (!this.foldInvisibleItems || obj.visible) {
              dist = Math.abs(mid - obj.y - obj.height / 2);
              if (dist < minDist) {
                minDist = dist;
                apexIndex = i;
              }
            }
          }
          this.apexIndex = apexIndex;
        }
      }
      handleArchOrder2() {
        if (this._childrenRenderOrder == ChildrenRenderOrder.Arch) {
          var mid = this._scrollPane.posX + this.viewWidth / 2;
          var minDist = Number.POSITIVE_INFINITY;
          var dist = 0;
          var apexIndex = 0;
          var cnt = this.numChildren;
          for (var i = 0; i < cnt; i++) {
            var obj = this.getChildAt(i);
            if (!this.foldInvisibleItems || obj.visible) {
              dist = Math.abs(mid - obj.x - obj.width / 2);
              if (dist < minDist) {
                minDist = dist;
                apexIndex = i;
              }
            }
          }
          this.apexIndex = apexIndex;
        }
      }
      handleAlign(contentWidth, contentHeight) {
        var newOffsetX = 0;
        var newOffsetY = 0;
        if (contentHeight < this.viewHeight) {
          if (this._verticalAlign == VertAlignType.Middle)
            newOffsetY = Math.floor((this.viewHeight - contentHeight) / 2);
          else if (this._verticalAlign == VertAlignType.Bottom)
            newOffsetY = this.viewHeight - contentHeight;
        }
        if (contentWidth < this.viewWidth) {
          if (this._align == AlignType.Center)
            newOffsetX = Math.floor((this.viewWidth - contentWidth) / 2);
          else if (this._align == AlignType.Right)
            newOffsetX = this.viewWidth - contentWidth;
        }
        if (newOffsetX != this._alignOffset.x || newOffsetY != this._alignOffset.y) {
          this._alignOffset.x = newOffsetX;
          this._alignOffset.y = newOffsetY;
          if (this._scrollPane)
            this._scrollPane.adjustMaskContainer();
          else
            this._container.setPosition(this._pivotCorrectX + this._alignOffset.x, this._pivotCorrectY - this._alignOffset.y);
        }
      }
      updateBounds() {
        if (this._virtual)
          return;
        var i;
        var child;
        var curX = 0;
        var curY = 0;
        var maxWidth = 0;
        var maxHeight = 0;
        var cw = 0, ch = 0;
        var j = 0;
        var page = 0;
        var k = 0;
        var cnt = this._children.length;
        var viewWidth = this.viewWidth;
        var viewHeight = this.viewHeight;
        var lineSize = 0;
        var lineStart = 0;
        var ratio = 0;
        if (this._layout == ListLayoutType.SingleColumn) {
          for (i = 0; i < cnt; i++) {
            child = this.getChildAt(i);
            if (this.foldInvisibleItems && !child.visible)
              continue;
            if (curY != 0)
              curY += this._lineGap;
            child.y = curY;
            if (this._autoResizeItem)
              child.setSize(viewWidth, child.height, true);
            curY += Math.ceil(child.height);
            if (child.width > maxWidth)
              maxWidth = child.width;
          }
          ch = curY;
          if (ch <= viewHeight && this._autoResizeItem && this._scrollPane && this._scrollPane._displayInDemand && this._scrollPane.vtScrollBar) {
            viewWidth += this._scrollPane.vtScrollBar.width;
            for (i = 0; i < cnt; i++) {
              child = this.getChildAt(i);
              if (this.foldInvisibleItems && !child.visible)
                continue;
              child.setSize(viewWidth, child.height, true);
              if (child.width > maxWidth)
                maxWidth = child.width;
            }
          }
          cw = Math.ceil(maxWidth);
        } else if (this._layout == ListLayoutType.SingleRow) {
          for (i = 0; i < cnt; i++) {
            child = this.getChildAt(i);
            if (this.foldInvisibleItems && !child.visible)
              continue;
            if (curX != 0)
              curX += this._columnGap;
            child.x = curX;
            if (this._autoResizeItem)
              child.setSize(child.width, viewHeight, true);
            curX += Math.ceil(child.width);
            if (child.height > maxHeight)
              maxHeight = child.height;
          }
          cw = curX;
          if (cw <= viewWidth && this._autoResizeItem && this._scrollPane && this._scrollPane._displayInDemand && this._scrollPane.hzScrollBar) {
            viewHeight += this._scrollPane.hzScrollBar.height;
            for (i = 0; i < cnt; i++) {
              child = this.getChildAt(i);
              if (this.foldInvisibleItems && !child.visible)
                continue;
              child.setSize(child.width, viewHeight, true);
              if (child.height > maxHeight)
                maxHeight = child.height;
            }
          }
          ch = Math.ceil(maxHeight);
        } else if (this._layout == ListLayoutType.FlowHorizontal) {
          if (this._autoResizeItem && this._columnCount > 0) {
            for (i = 0; i < cnt; i++) {
              child = this.getChildAt(i);
              if (this.foldInvisibleItems && !child.visible)
                continue;
              lineSize += child.sourceWidth;
              j++;
              if (j == this._columnCount || i == cnt - 1) {
                ratio = (viewWidth - lineSize - (j - 1) * this._columnGap) / lineSize;
                curX = 0;
                for (j = lineStart; j <= i; j++) {
                  child = this.getChildAt(j);
                  if (this.foldInvisibleItems && !child.visible)
                    continue;
                  child.setPosition(curX, curY);
                  if (j < i) {
                    child.setSize(child.sourceWidth + Math.round(child.sourceWidth * ratio), child.height, true);
                    curX += Math.ceil(child.width) + this._columnGap;
                  } else {
                    child.setSize(viewWidth - curX, child.height, true);
                  }
                  if (child.height > maxHeight)
                    maxHeight = child.height;
                }
                curY += Math.ceil(maxHeight) + this._lineGap;
                maxHeight = 0;
                j = 0;
                lineStart = i + 1;
                lineSize = 0;
              }
            }
            ch = curY + Math.ceil(maxHeight);
            cw = viewWidth;
          } else {
            for (i = 0; i < cnt; i++) {
              child = this.getChildAt(i);
              if (this.foldInvisibleItems && !child.visible)
                continue;
              if (curX != 0)
                curX += this._columnGap;
              if (this._columnCount != 0 && j >= this._columnCount || this._columnCount == 0 && curX + child.width > viewWidth && maxHeight != 0) {
                curX = 0;
                curY += Math.ceil(maxHeight) + this._lineGap;
                maxHeight = 0;
                j = 0;
              }
              child.setPosition(curX, curY);
              curX += Math.ceil(child.width);
              if (curX > maxWidth)
                maxWidth = curX;
              if (child.height > maxHeight)
                maxHeight = child.height;
              j++;
            }
            ch = curY + Math.ceil(maxHeight);
            cw = Math.ceil(maxWidth);
          }
        } else if (this._layout == ListLayoutType.FlowVertical) {
          if (this._autoResizeItem && this._lineCount > 0) {
            for (i = 0; i < cnt; i++) {
              child = this.getChildAt(i);
              if (this.foldInvisibleItems && !child.visible)
                continue;
              lineSize += child.sourceHeight;
              j++;
              if (j == this._lineCount || i == cnt - 1) {
                ratio = (viewHeight - lineSize - (j - 1) * this._lineGap) / lineSize;
                curY = 0;
                for (j = lineStart; j <= i; j++) {
                  child = this.getChildAt(j);
                  if (this.foldInvisibleItems && !child.visible)
                    continue;
                  child.setPosition(curX, curY);
                  if (j < i) {
                    child.setSize(child.width, child.sourceHeight + Math.round(child.sourceHeight * ratio), true);
                    curY += Math.ceil(child.height) + this._lineGap;
                  } else {
                    child.setSize(child.width, viewHeight - curY, true);
                  }
                  if (child.width > maxWidth)
                    maxWidth = child.width;
                }
                curX += Math.ceil(maxWidth) + this._columnGap;
                maxWidth = 0;
                j = 0;
                lineStart = i + 1;
                lineSize = 0;
              }
            }
            cw = curX + Math.ceil(maxWidth);
            ch = viewHeight;
          } else {
            for (i = 0; i < cnt; i++) {
              child = this.getChildAt(i);
              if (this.foldInvisibleItems && !child.visible)
                continue;
              if (curY != 0)
                curY += this._lineGap;
              if (this._lineCount != 0 && j >= this._lineCount || this._lineCount == 0 && curY + child.height > viewHeight && maxWidth != 0) {
                curY = 0;
                curX += Math.ceil(maxWidth) + this._columnGap;
                maxWidth = 0;
                j = 0;
              }
              child.setPosition(curX, curY);
              curY += Math.ceil(child.height);
              if (curY > maxHeight)
                maxHeight = curY;
              if (child.width > maxWidth)
                maxWidth = child.width;
              j++;
            }
            cw = curX + Math.ceil(maxWidth);
            ch = Math.ceil(maxHeight);
          }
        } else {
          var eachHeight;
          if (this._autoResizeItem && this._lineCount > 0)
            eachHeight = Math.floor((viewHeight - (this._lineCount - 1) * this._lineGap) / this._lineCount);
          if (this._autoResizeItem && this._columnCount > 0) {
            for (i = 0; i < cnt; i++) {
              child = this.getChildAt(i);
              if (this.foldInvisibleItems && !child.visible)
                continue;
              if (j == 0 && (this._lineCount != 0 && k >= this._lineCount || this._lineCount == 0 && curY + (this._lineCount > 0 ? eachHeight : child.height) > viewHeight)) {
                page++;
                curY = 0;
                k = 0;
              }
              lineSize += child.sourceWidth;
              j++;
              if (j == this._columnCount || i == cnt - 1) {
                ratio = (viewWidth - lineSize - (j - 1) * this._columnGap) / lineSize;
                curX = 0;
                for (j = lineStart; j <= i; j++) {
                  child = this.getChildAt(j);
                  if (this.foldInvisibleItems && !child.visible)
                    continue;
                  child.setPosition(page * viewWidth + curX, curY);
                  if (j < i) {
                    child.setSize(child.sourceWidth + Math.round(child.sourceWidth * ratio), this._lineCount > 0 ? eachHeight : child.height, true);
                    curX += Math.ceil(child.width) + this._columnGap;
                  } else {
                    child.setSize(viewWidth - curX, this._lineCount > 0 ? eachHeight : child.height, true);
                  }
                  if (child.height > maxHeight)
                    maxHeight = child.height;
                }
                curY += Math.ceil(maxHeight) + this._lineGap;
                maxHeight = 0;
                j = 0;
                lineStart = i + 1;
                lineSize = 0;
                k++;
              }
            }
          } else {
            for (i = 0; i < cnt; i++) {
              child = this.getChildAt(i);
              if (this.foldInvisibleItems && !child.visible)
                continue;
              if (curX != 0)
                curX += this._columnGap;
              if (this._autoResizeItem && this._lineCount > 0)
                child.setSize(child.width, eachHeight, true);
              if (this._columnCount != 0 && j >= this._columnCount || this._columnCount == 0 && curX + child.width > viewWidth && maxHeight != 0) {
                curX = 0;
                curY += Math.ceil(maxHeight) + this._lineGap;
                maxHeight = 0;
                j = 0;
                k++;
                if (this._lineCount != 0 && k >= this._lineCount || this._lineCount == 0 && curY + child.height > viewHeight && maxWidth != 0) {
                  page++;
                  curY = 0;
                  k = 0;
                }
              }
              child.setPosition(page * viewWidth + curX, curY);
              curX += Math.ceil(child.width);
              if (curX > maxWidth)
                maxWidth = curX;
              if (child.height > maxHeight)
                maxHeight = child.height;
              j++;
            }
          }
          ch = page > 0 ? viewHeight : curY + Math.ceil(maxHeight);
          cw = (page + 1) * viewWidth;
        }
        this.handleAlign(cw, ch);
        this.setBounds(0, 0, cw, ch);
      }
      setup_beforeAdd(buffer, beginPos) {
        super.setup_beforeAdd(buffer, beginPos);
        buffer.seek(beginPos, 5);
        this._layout = buffer.readByte();
        this._selectionMode = buffer.readByte();
        this._align = buffer.readByte();
        this._verticalAlign = buffer.readByte();
        this._lineGap = buffer.readShort();
        this._columnGap = buffer.readShort();
        this._lineCount = buffer.readShort();
        this._columnCount = buffer.readShort();
        this._autoResizeItem = buffer.readBool();
        this._childrenRenderOrder = buffer.readByte();
        this._apexIndex = buffer.readShort();
        if (buffer.readBool()) {
          this._margin.top = buffer.readInt();
          this._margin.bottom = buffer.readInt();
          this._margin.left = buffer.readInt();
          this._margin.right = buffer.readInt();
        }
        var overflow = buffer.readByte();
        if (overflow == OverflowType.Scroll) {
          var savedPos = buffer.position;
          buffer.seek(beginPos, 7);
          this.setupScroll(buffer);
          buffer.position = savedPos;
        } else
          this.setupOverflow(overflow);
        if (buffer.readBool())
          buffer.skip(8);
        if (buffer.version >= 2) {
          this.scrollItemToViewOnClick = buffer.readBool();
          this.foldInvisibleItems = buffer.readBool();
        }
        buffer.seek(beginPos, 8);
        this._defaultItem = buffer.readS();
        this.readItems(buffer);
      }
      readItems(buffer) {
        var cnt;
        var i;
        var nextPos;
        var str;
        cnt = buffer.readShort();
        for (i = 0; i < cnt; i++) {
          nextPos = buffer.readShort();
          nextPos += buffer.position;
          str = buffer.readS();
          if (str == null) {
            str = this._defaultItem;
            if (!str) {
              buffer.position = nextPos;
              continue;
            }
          }
          var obj = this.getFromPool(str);
          if (obj) {
            this.addChild(obj);
            this.setupItem(buffer, obj);
          }
          buffer.position = nextPos;
        }
      }
      setupItem(buffer, obj) {
        var str;
        str = buffer.readS();
        if (str != null)
          obj.text = str;
        str = buffer.readS();
        if (str != null && obj instanceof GButton)
          obj.selectedTitle = str;
        str = buffer.readS();
        if (str != null)
          obj.icon = str;
        str = buffer.readS();
        if (str != null && obj instanceof GButton)
          obj.selectedIcon = str;
        str = buffer.readS();
        if (str != null)
          obj.name = str;
        var cnt;
        var i;
        if (obj instanceof GComponent) {
          cnt = buffer.readShort();
          for (i = 0; i < cnt; i++) {
            var cc = obj.getController(buffer.readS());
            str = buffer.readS();
            if (cc)
              cc.selectedPageId = str;
          }
          if (buffer.version >= 2) {
            cnt = buffer.readShort();
            for (i = 0; i < cnt; i++) {
              var target = buffer.readS();
              var propertyId = buffer.readShort();
              var value = buffer.readS();
              var obj2 = obj.getChildByPath(target);
              if (obj2)
                obj2.setProp(propertyId, value);
            }
          }
        }
      }
      setup_afterAdd(buffer, beginPos) {
        super.setup_afterAdd(buffer, beginPos);
        buffer.seek(beginPos, 6);
        var i = buffer.readShort();
        if (i != -1)
          this._selectionController = this.parent.getControllerAt(i);
      }
    };
    s_n = 0;
    GComboBox = class extends GComponent {
      constructor() {
        super();
        this._visibleItemCount = 0;
        this._selectedIndex = 0;
        this._popupDirection = PopupDirection.Auto;
        this._node.name = "GComboBox";
        this._visibleItemCount = UIConfig.defaultComboBoxVisibleItemCount;
        this._itemsUpdated = true;
        this._selectedIndex = -1;
        this._items = [];
        this._values = [];
      }
      get text() {
        if (this._titleObject)
          return this._titleObject.text;
        else
          return null;
      }
      set text(value) {
        if (this._titleObject)
          this._titleObject.text = value;
        this.updateGear(6);
      }
      get icon() {
        if (this._iconObject)
          return this._iconObject.icon;
        else
          return null;
      }
      set icon(value) {
        if (this._iconObject)
          this._iconObject.icon = value;
        this.updateGear(7);
      }
      get titleColor() {
        var tf = this.getTextField();
        if (tf)
          return tf.color;
        else
          return import_cc5.Color.BLACK;
      }
      set titleColor(value) {
        var tf = this.getTextField();
        if (tf)
          tf.color = value;
      }
      get titleFontSize() {
        var tf = this.getTextField();
        if (tf)
          return tf.fontSize;
        else
          return 0;
      }
      set titleFontSize(value) {
        var tf = this.getTextField();
        if (tf)
          tf.fontSize = value;
      }
      get visibleItemCount() {
        return this._visibleItemCount;
      }
      set visibleItemCount(value) {
        this._visibleItemCount = value;
      }
      get popupDirection() {
        return this._popupDirection;
      }
      set popupDirection(value) {
        this._popupDirection = value;
      }
      get items() {
        return this._items;
      }
      set items(value) {
        if (!value)
          this._items.length = 0;
        else
          this._items = value.concat();
        if (this._items.length > 0) {
          if (this._selectedIndex >= this._items.length)
            this._selectedIndex = this._items.length - 1;
          else if (this._selectedIndex == -1)
            this._selectedIndex = 0;
          this.text = this._items[this._selectedIndex];
          if (this._icons && this._selectedIndex < this._icons.length)
            this.icon = this._icons[this._selectedIndex];
        } else {
          this.text = "";
          if (this._icons)
            this.icon = null;
          this._selectedIndex = -1;
        }
        this._itemsUpdated = true;
      }
      get icons() {
        return this._icons;
      }
      set icons(value) {
        this._icons = value;
        if (this._icons && this._selectedIndex != -1 && this._selectedIndex < this._icons.length)
          this.icon = this._icons[this._selectedIndex];
      }
      get values() {
        return this._values;
      }
      set values(value) {
        if (!value)
          this._values.length = 0;
        else
          this._values = value.concat();
      }
      get selectedIndex() {
        return this._selectedIndex;
      }
      set selectedIndex(val) {
        if (this._selectedIndex == val)
          return;
        this._selectedIndex = val;
        if (this._selectedIndex >= 0 && this._selectedIndex < this._items.length) {
          this.text = this._items[this._selectedIndex];
          if (this._icons && this._selectedIndex < this._icons.length)
            this.icon = this._icons[this._selectedIndex];
        } else {
          this.text = "";
          if (this._icons)
            this.icon = null;
        }
        this.updateSelectionController();
      }
      get value() {
        return this._values[this._selectedIndex];
      }
      set value(val) {
        var index = this._values.indexOf(val);
        if (index == -1 && val == null)
          index = this._values.indexOf("");
        this.selectedIndex = index;
      }
      get selectionController() {
        return this._selectionController;
      }
      set selectionController(value) {
        this._selectionController = value;
      }
      getTextField() {
        if (this._titleObject instanceof GTextField)
          return this._titleObject;
        else if ("getTextField" in this._titleObject)
          return this._titleObject.getTextField();
        else
          return null;
      }
      setState(val) {
        if (this._buttonController)
          this._buttonController.selectedPage = val;
      }
      getProp(index) {
        switch (index) {
          case ObjectPropID.Color:
            return this.titleColor;
          case ObjectPropID.OutlineColor: {
            var tf = this.getTextField();
            if (tf)
              return tf.strokeColor;
            else
              return 0;
          }
          case ObjectPropID.FontSize: {
            tf = this.getTextField();
            if (tf)
              return tf.fontSize;
            else
              return 0;
          }
          default:
            return super.getProp(index);
        }
      }
      setProp(index, value) {
        switch (index) {
          case ObjectPropID.Color:
            this.titleColor = value;
            break;
          case ObjectPropID.OutlineColor:
            {
              var tf = this.getTextField();
              if (tf)
                tf.strokeColor = value;
            }
            break;
          case ObjectPropID.FontSize:
            {
              tf = this.getTextField();
              if (tf)
                tf.fontSize = value;
            }
            break;
          default:
            super.setProp(index, value);
            break;
        }
      }
      constructExtension(buffer) {
        var str;
        this._buttonController = this.getController("button");
        this._titleObject = this.getChild("title");
        this._iconObject = this.getChild("icon");
        str = buffer.readS();
        if (str) {
          let obj = UIPackage.createObjectFromURL(str);
          if (!(obj instanceof GComponent)) {
            console.error("\u4E0B\u62C9\u6846\u5FC5\u987B\u4E3A\u5143\u4EF6");
            return;
          }
          this.dropdown = obj;
          this.dropdown.name = "this.dropdown";
          this._list = this.dropdown.getChild("list", GList);
          if (this._list == null) {
            console.error(this.resourceURL + ": \u4E0B\u62C9\u6846\u7684\u5F39\u51FA\u5143\u4EF6\u91CC\u5FC5\u987B\u5305\u542B\u540D\u4E3Alist\u7684\u5217\u8868");
            return;
          }
          this._list.on(Event.CLICK_ITEM, this.onClickItem, this);
          this._list.addRelation(this.dropdown, RelationType.Width);
          this._list.removeRelation(this.dropdown, RelationType.Height);
          this.dropdown.addRelation(this._list, RelationType.Height);
          this.dropdown.removeRelation(this._list, RelationType.Width);
          this.dropdown.on(Event.UNDISPLAY, this.onPopupClosed, this);
        }
        this._node.on(Event.TOUCH_BEGIN, this.onTouchBegin_1, this);
        this._node.on(Event.TOUCH_END, this.onTouchEnd_1, this);
        this._node.on(Event.ROLL_OVER, this.onRollOver_1, this);
        this._node.on(Event.ROLL_OUT, this.onRollOut_1, this);
      }
      handleControllerChanged(c) {
        super.handleControllerChanged(c);
        if (this._selectionController == c)
          this.selectedIndex = c.selectedIndex;
      }
      updateSelectionController() {
        if (this._selectionController && !this._selectionController.changing && this._selectedIndex < this._selectionController.pageCount) {
          var c = this._selectionController;
          this._selectionController = null;
          c.selectedIndex = this._selectedIndex;
          this._selectionController = c;
        }
      }
      dispose() {
        if (this.dropdown) {
          this.dropdown.dispose();
          this.dropdown = null;
        }
        super.dispose();
      }
      setup_afterAdd(buffer, beginPos) {
        super.setup_afterAdd(buffer, beginPos);
        if (!buffer.seek(beginPos, 6))
          return;
        if (buffer.readByte() != this.packageItem.objectType)
          return;
        var i;
        var iv;
        var nextPos;
        var str;
        var itemCount = buffer.readShort();
        for (i = 0; i < itemCount; i++) {
          nextPos = buffer.readShort();
          nextPos += buffer.position;
          this._items[i] = buffer.readS();
          this._values[i] = buffer.readS();
          str = buffer.readS();
          if (str != null) {
            if (this._icons == null)
              this._icons = new Array();
            this._icons[i] = str;
          }
          buffer.position = nextPos;
        }
        str = buffer.readS();
        if (str != null) {
          this.text = str;
          this._selectedIndex = this._items.indexOf(str);
        } else if (this._items.length > 0) {
          this._selectedIndex = 0;
          this.text = this._items[0];
        } else
          this._selectedIndex = -1;
        str = buffer.readS();
        if (str != null)
          this.icon = str;
        if (buffer.readBool())
          this.titleColor = buffer.readColor();
        iv = buffer.readInt();
        if (iv > 0)
          this._visibleItemCount = iv;
        this._popupDirection = buffer.readByte();
        iv = buffer.readShort();
        if (iv >= 0)
          this._selectionController = this.parent.getControllerAt(iv);
      }
      showDropdown() {
        if (this._itemsUpdated) {
          this._itemsUpdated = false;
          this._list.removeChildrenToPool();
          var cnt = this._items.length;
          for (var i = 0; i < cnt; i++) {
            var item = this._list.addItemFromPool();
            item.name = i < this._values.length ? this._values[i] : "";
            item.text = this._items[i];
            item.icon = this._icons && i < this._icons.length ? this._icons[i] : null;
          }
          this._list.resizeToFit(this._visibleItemCount);
        }
        this._list.selectedIndex = -1;
        this.dropdown.width = this.width;
        this._list.ensureBoundsCorrect();
        GRoot.inst.togglePopup(this.dropdown, this, this._popupDirection);
        if (this.dropdown.parent)
          this.setState(GButton.DOWN);
      }
      onPopupClosed() {
        if (this._over)
          this.setState(GButton.OVER);
        else
          this.setState(GButton.UP);
      }
      onClickItem(itemObject) {
        let _t = this;
        let index = this._list.getChildIndex(itemObject);
        this._partner.callLater((dt) => {
          _t.onClickItem2(index);
        }, 0.1);
      }
      onClickItem2(index) {
        if (this.dropdown.parent instanceof GRoot)
          this.dropdown.parent.hidePopup();
        this._selectedIndex = -1;
        this.selectedIndex = index;
        this._node.emit(Event.STATUS_CHANGED, this);
      }
      onRollOver_1() {
        this._over = true;
        if (this._down || this.dropdown && this.dropdown.parent)
          return;
        this.setState(GButton.OVER);
      }
      onRollOut_1() {
        this._over = false;
        if (this._down || this.dropdown && this.dropdown.parent)
          return;
        this.setState(GButton.UP);
      }
      onTouchBegin_1(evt) {
        if (evt.button != import_cc5.EventMouse.BUTTON_LEFT)
          return;
        if (evt.initiator instanceof GTextInput && evt.initiator.editable)
          return;
        this._down = true;
        evt.captureTouch();
        if (this.dropdown)
          this.showDropdown();
      }
      onTouchEnd_1(evt) {
        if (evt.button != import_cc5.EventMouse.BUTTON_LEFT)
          return;
        if (this._down) {
          this._down = false;
          if (this.dropdown && !this.dropdown.parent) {
            if (this._over)
              this.setState(GButton.OVER);
            else
              this.setState(GButton.UP);
          }
        }
      }
    };
    GSlider = class extends GComponent {
      constructor() {
        super();
        this._min = 0;
        this._max = 0;
        this._value = 0;
        this._barMaxWidth = 0;
        this._barMaxHeight = 0;
        this._barMaxWidthDelta = 0;
        this._barMaxHeightDelta = 0;
        this._clickPercent = 0;
        this._barStartX = 0;
        this._barStartY = 0;
        this.changeOnClick = true;
        this.canDrag = true;
        this._node.name = "GSlider";
        this._titleType = ProgressTitleType.Percent;
        this._value = 50;
        this._max = 100;
        this._clickPos = new import_cc5.Vec2();
      }
      get titleType() {
        return this._titleType;
      }
      set titleType(value) {
        this._titleType = value;
      }
      get wholeNumbers() {
        return this._wholeNumbers;
      }
      set wholeNumbers(value) {
        if (this._wholeNumbers != value) {
          this._wholeNumbers = value;
          this.update();
        }
      }
      get min() {
        return this._min;
      }
      set min(value) {
        if (this._min != value) {
          this._min = value;
          this.update();
        }
      }
      get max() {
        return this._max;
      }
      set max(value) {
        if (this._max != value) {
          this._max = value;
          this.update();
        }
      }
      get value() {
        return this._value;
      }
      set value(value) {
        if (this._value != value) {
          this._value = value;
          this.update();
        }
      }
      update() {
        this.updateWithPercent((this._value - this._min) / (this._max - this._min));
      }
      updateWithPercent(percent, manual) {
        percent = import_cc5.math.clamp01(percent);
        if (manual) {
          var newValue = import_cc5.math.clamp(this._min + (this._max - this._min) * percent, this._min, this._max);
          if (this._wholeNumbers) {
            newValue = Math.round(newValue);
            percent = import_cc5.math.clamp01((newValue - this._min) / (this._max - this._min));
          }
          if (newValue != this._value) {
            this._value = newValue;
            this._node.emit(Event.STATUS_CHANGED, this);
          }
        }
        if (this._titleObject) {
          switch (this._titleType) {
            case ProgressTitleType.Percent:
              this._titleObject.text = Math.floor(percent * 100) + "%";
              break;
            case ProgressTitleType.ValueAndMax:
              this._titleObject.text = this._value + "/" + this._max;
              break;
            case ProgressTitleType.Value:
              this._titleObject.text = "" + this._value;
              break;
            case ProgressTitleType.Max:
              this._titleObject.text = "" + this._max;
              break;
          }
        }
        var fullWidth = this.width - this._barMaxWidthDelta;
        var fullHeight = this.height - this._barMaxHeightDelta;
        if (!this._reverse) {
          if (this._barObjectH)
            this._barObjectH.width = Math.round(fullWidth * percent);
          if (this._barObjectV)
            this._barObjectV.height = Math.round(fullHeight * percent);
        } else {
          if (this._barObjectH) {
            this._barObjectH.width = Math.round(fullWidth * percent);
            this._barObjectH.x = this._barStartX + (fullWidth - this._barObjectH.width);
          }
          if (this._barObjectV) {
            this._barObjectV.height = Math.round(fullHeight * percent);
            this._barObjectV.y = this._barStartY + (fullHeight - this._barObjectV.height);
          }
        }
      }
      constructExtension(buffer) {
        buffer.seek(0, 6);
        this._titleType = buffer.readByte();
        this._reverse = buffer.readBool();
        if (buffer.version >= 2) {
          this._wholeNumbers = buffer.readBool();
          this.changeOnClick = buffer.readBool();
        }
        this._titleObject = this.getChild("title");
        this._barObjectH = this.getChild("bar");
        this._barObjectV = this.getChild("bar_v");
        this._gripObject = this.getChild("grip");
        if (this._barObjectH) {
          this._barMaxWidth = this._barObjectH.width;
          this._barMaxWidthDelta = this.width - this._barMaxWidth;
          this._barStartX = this._barObjectH.x;
        }
        if (this._barObjectV) {
          this._barMaxHeight = this._barObjectV.height;
          this._barMaxHeightDelta = this.height - this._barMaxHeight;
          this._barStartY = this._barObjectV.y;
        }
        if (this._gripObject) {
          this._gripObject.on(Event.TOUCH_BEGIN, this.onGripTouchBegin, this);
          this._gripObject.on(Event.TOUCH_MOVE, this.onGripTouchMove, this);
        }
        this._node.on(Event.TOUCH_BEGIN, this.onBarTouchBegin, this);
      }
      handleSizeChanged() {
        super.handleSizeChanged();
        if (this._barObjectH)
          this._barMaxWidth = this.width - this._barMaxWidthDelta;
        if (this._barObjectV)
          this._barMaxHeight = this.height - this._barMaxHeightDelta;
        if (!this._underConstruct)
          this.update();
      }
      setup_afterAdd(buffer, beginPos) {
        super.setup_afterAdd(buffer, beginPos);
        if (!buffer.seek(beginPos, 6)) {
          this.update();
          return;
        }
        if (buffer.readByte() != this.packageItem.objectType) {
          this.update();
          return;
        }
        this._value = buffer.readInt();
        this._max = buffer.readInt();
        if (buffer.version >= 2)
          this._min = buffer.readInt();
        this.update();
      }
      onGripTouchBegin(evt) {
        this.canDrag = true;
        evt.propagationStopped = true;
        evt.captureTouch();
        this._clickPos = this.globalToLocal(evt.pos.x, evt.pos.y);
        this._clickPercent = import_cc5.math.clamp01((this._value - this._min) / (this._max - this._min));
      }
      onGripTouchMove(evt) {
        if (!this.canDrag) {
          return;
        }
        var pt = this.globalToLocal(evt.pos.x, evt.pos.y, s_vec2$1);
        var deltaX = pt.x - this._clickPos.x;
        var deltaY = pt.y - this._clickPos.y;
        if (this._reverse) {
          deltaX = -deltaX;
          deltaY = -deltaY;
        }
        var percent;
        if (this._barObjectH)
          percent = this._clickPercent + deltaX / this._barMaxWidth;
        else
          percent = this._clickPercent + deltaY / this._barMaxHeight;
        this.updateWithPercent(percent, true);
      }
      onBarTouchBegin(evt) {
        if (!this.changeOnClick)
          return;
        var pt = this._gripObject.globalToLocal(evt.pos.x, evt.pos.y, s_vec2$1);
        var percent = import_cc5.math.clamp01((this._value - this._min) / (this._max - this._min));
        var delta = 0;
        if (this._barObjectH != null)
          delta = (pt.x - this._gripObject.width / 2) / this._barMaxWidth;
        if (this._barObjectV != null)
          delta = (pt.y - this._gripObject.height / 2) / this._barMaxHeight;
        if (this._reverse)
          percent -= delta;
        else
          percent += delta;
        this.updateWithPercent(percent, true);
      }
    };
    s_vec2$1 = new import_cc5.Vec2();
    GProgressBar = class extends GComponent {
      constructor() {
        super();
        this._min = 0;
        this._max = 0;
        this._value = 0;
        this._barMaxWidth = 0;
        this._barMaxHeight = 0;
        this._barMaxWidthDelta = 0;
        this._barMaxHeightDelta = 0;
        this._barStartX = 0;
        this._barStartY = 0;
        this._node.name = "GProgressBar";
        this._titleType = ProgressTitleType.Percent;
        this._value = 50;
        this._max = 100;
      }
      get titleType() {
        return this._titleType;
      }
      set titleType(value) {
        if (this._titleType != value) {
          this._titleType = value;
          this.update(this._value);
        }
      }
      get min() {
        return this._min;
      }
      set min(value) {
        if (this._min != value) {
          this._min = value;
          this.update(this._value);
        }
      }
      get max() {
        return this._max;
      }
      set max(value) {
        if (this._max != value) {
          this._max = value;
          this.update(this._value);
        }
      }
      get value() {
        return this._value;
      }
      set value(value) {
        if (this._value != value) {
          GTween.kill(this, false, this.update);
          this._value = value;
          this.update(value);
        }
      }
      tweenValue(value, duration) {
        var oldValule;
        var tweener = GTween.getTween(this, this.update);
        if (tweener) {
          oldValule = tweener.value.x;
          tweener.kill();
        } else
          oldValule = this._value;
        this._value = value;
        return GTween.to(oldValule, this._value, duration).setTarget(this, this.update).setEase(EaseType.Linear);
      }
      update(newValue) {
        var percent = import_cc5.math.clamp01((newValue - this._min) / (this._max - this._min));
        if (this._titleObject) {
          switch (this._titleType) {
            case ProgressTitleType.Percent:
              this._titleObject.text = Math.floor(percent * 100) + "%";
              break;
            case ProgressTitleType.ValueAndMax:
              this._titleObject.text = Math.floor(newValue) + "/" + Math.floor(this._max);
              break;
            case ProgressTitleType.Value:
              this._titleObject.text = "" + Math.floor(newValue);
              break;
            case ProgressTitleType.Max:
              this._titleObject.text = "" + Math.floor(this._max);
              break;
          }
        }
        var fullWidth = this.width - this._barMaxWidthDelta;
        var fullHeight = this.height - this._barMaxHeightDelta;
        if (!this._reverse) {
          if (this._barObjectH) {
            if (!this.setFillAmount(this._barObjectH, percent))
              this._barObjectH.width = Math.round(fullWidth * percent);
          }
          if (this._barObjectV) {
            if (!this.setFillAmount(this._barObjectV, percent))
              this._barObjectV.height = Math.round(fullHeight * percent);
          }
        } else {
          if (this._barObjectH) {
            if (!this.setFillAmount(this._barObjectH, 1 - percent)) {
              this._barObjectH.width = Math.round(fullWidth * percent);
              this._barObjectH.x = this._barStartX + (fullWidth - this._barObjectH.width);
            }
          }
          if (this._barObjectV) {
            if (!this.setFillAmount(this._barObjectV, 1 - percent)) {
              this._barObjectV.height = Math.round(fullHeight * percent);
              this._barObjectV.y = this._barStartY + (fullHeight - this._barObjectV.height);
            }
          }
        }
        if (this._aniObject)
          this._aniObject.setProp(ObjectPropID.Frame, Math.floor(percent * 100));
      }
      setFillAmount(bar, percent) {
        if ((bar instanceof GImage || bar instanceof GLoader) && bar.fillMethod != FillMethod.None) {
          bar.fillAmount = percent;
          return true;
        } else
          return false;
      }
      constructExtension(buffer) {
        buffer.seek(0, 6);
        this._titleType = buffer.readByte();
        this._reverse = buffer.readBool();
        this._titleObject = this.getChild("title");
        this._barObjectH = this.getChild("bar");
        this._barObjectV = this.getChild("bar_v");
        this._aniObject = this.getChild("ani");
        if (this._barObjectH) {
          this._barMaxWidth = this._barObjectH.width;
          this._barMaxWidthDelta = this.width - this._barMaxWidth;
          this._barStartX = this._barObjectH.x;
        }
        if (this._barObjectV) {
          this._barMaxHeight = this._barObjectV.height;
          this._barMaxHeightDelta = this.height - this._barMaxHeight;
          this._barStartY = this._barObjectV.y;
        }
      }
      handleSizeChanged() {
        super.handleSizeChanged();
        if (this._barObjectH)
          this._barMaxWidth = this.width - this._barMaxWidthDelta;
        if (this._barObjectV)
          this._barMaxHeight = this.height - this._barMaxHeightDelta;
        if (!this._underConstruct)
          this.update(this._value);
      }
      setup_afterAdd(buffer, beginPos) {
        super.setup_afterAdd(buffer, beginPos);
        if (!buffer.seek(beginPos, 6)) {
          this.update(this._value);
          return;
        }
        if (buffer.readByte() != this.packageItem.objectType) {
          this.update(this._value);
          return;
        }
        this._value = buffer.readInt();
        this._max = buffer.readInt();
        if (buffer.version >= 2)
          this._min = buffer.readInt();
        this.update(this._value);
      }
    };
    GScrollBar = class extends GComponent {
      constructor() {
        super();
        this._node.name = "GScrollBar";
        this._dragOffset = new import_cc5.Vec2();
        this._scrollPerc = 0;
      }
      setScrollPane(target, vertical) {
        this._target = target;
        this._vertical = vertical;
      }
      setDisplayPerc(value) {
        if (this._vertical) {
          if (!this._fixedGripSize)
            this._grip.height = Math.floor(value * this._bar.height);
          this._grip.y = this._bar.y + (this._bar.height - this._grip.height) * this._scrollPerc;
        } else {
          if (!this._fixedGripSize)
            this._grip.width = Math.floor(value * this._bar.width);
          this._grip.x = this._bar.x + (this._bar.width - this._grip.width) * this._scrollPerc;
        }
        this._grip.visible = value != 0 && value != 1;
      }
      setScrollPerc(val) {
        this._scrollPerc = val;
        if (this._vertical)
          this._grip.y = this._bar.y + (this._bar.height - this._grip.height) * this._scrollPerc;
        else
          this._grip.x = this._bar.x + (this._bar.width - this._grip.width) * this._scrollPerc;
      }
      get minSize() {
        if (this._vertical)
          return (this._arrowButton1 ? this._arrowButton1.height : 0) + (this._arrowButton2 ? this._arrowButton2.height : 0);
        else
          return (this._arrowButton1 ? this._arrowButton1.width : 0) + (this._arrowButton2 ? this._arrowButton2.width : 0);
      }
      get gripDragging() {
        return this._gripDragging;
      }
      constructExtension(buffer) {
        buffer.seek(0, 6);
        this._fixedGripSize = buffer.readBool();
        this._grip = this.getChild("grip");
        if (!this._grip) {
          console.error("\u9700\u8981\u5B9A\u4E49grip");
          return;
        }
        this._bar = this.getChild("bar");
        if (!this._bar) {
          console.error("\u9700\u8981\u5B9A\u4E49bar");
          return;
        }
        this._arrowButton1 = this.getChild("arrow1");
        this._arrowButton2 = this.getChild("arrow2");
        this._grip.on(Event.TOUCH_BEGIN, this.onGripTouchDown, this);
        this._grip.on(Event.TOUCH_MOVE, this.onGripTouchMove, this);
        this._grip.on(Event.TOUCH_END, this.onGripTouchEnd, this);
        if (this._arrowButton1)
          this._arrowButton1.on(Event.TOUCH_BEGIN, this.onClickArrow1, this);
        if (this._arrowButton2)
          this._arrowButton2.on(Event.TOUCH_BEGIN, this.onClickArrow2, this);
        this.on(Event.TOUCH_BEGIN, this.onBarTouchBegin, this);
      }
      onGripTouchDown(evt) {
        evt.propagationStopped = true;
        evt.captureTouch();
        this._gripDragging = true;
        this._target.updateScrollBarVisible();
        this.globalToLocal(evt.pos.x, evt.pos.y, this._dragOffset);
        this._dragOffset.x -= this._grip.x;
        this._dragOffset.y -= this._grip.y;
      }
      onGripTouchMove(evt) {
        if (!this.onStage)
          return;
        var pt = this.globalToLocal(evt.pos.x, evt.pos.y, s_vec2);
        if (this._vertical) {
          var curY = pt.y - this._dragOffset.y;
          this._target.setPercY((curY - this._bar.y) / (this._bar.height - this._grip.height), false);
        } else {
          var curX = pt.x - this._dragOffset.x;
          this._target.setPercX((curX - this._bar.x) / (this._bar.width - this._grip.width), false);
        }
      }
      onGripTouchEnd(evt) {
        if (!this.onStage)
          return;
        this._gripDragging = false;
        this._target.updateScrollBarVisible();
      }
      onClickArrow1(evt) {
        evt.propagationStopped = true;
        if (this._vertical)
          this._target.scrollUp();
        else
          this._target.scrollLeft();
      }
      onClickArrow2(evt) {
        evt.propagationStopped = true;
        if (this._vertical)
          this._target.scrollDown();
        else
          this._target.scrollRight();
      }
      onBarTouchBegin(evt) {
        var pt = this._grip.globalToLocal(evt.pos.x, evt.pos.y, s_vec2);
        if (this._vertical) {
          if (pt.y < 0)
            this._target.scrollUp(4);
          else
            this._target.scrollDown(4);
        } else {
          if (pt.x < 0)
            this._target.scrollLeft(4);
          else
            this._target.scrollRight(4);
        }
      }
    };
    s_vec2 = new import_cc5.Vec2();
    GTreeNode = class {
      constructor(hasChild, resURL) {
        this._level = 0;
        this._resURL = resURL;
        if (hasChild)
          this._children = new Array();
      }
      set expanded(value) {
        if (this._children == null)
          return;
        if (this._expanded != value) {
          this._expanded = value;
          if (this._tree) {
            if (this._expanded)
              this._tree._afterExpanded(this);
            else
              this._tree._afterCollapsed(this);
          }
        }
      }
      get expanded() {
        return this._expanded;
      }
      get isFolder() {
        return this._children != null;
      }
      get parent() {
        return this._parent;
      }
      get text() {
        if (this._cell)
          return this._cell.text;
        else
          return null;
      }
      set text(value) {
        if (this._cell)
          this._cell.text = value;
      }
      get icon() {
        if (this._cell)
          return this._cell.icon;
        else
          return null;
      }
      set icon(value) {
        if (this._cell)
          this._cell.icon = value;
      }
      get cell() {
        return this._cell;
      }
      get level() {
        return this._level;
      }
      _setLevel(value) {
        this._level = value;
      }
      addChild(child) {
        this.addChildAt(child, this._children.length);
        return child;
      }
      addChildAt(child, index) {
        if (!child)
          throw new Error("child is null");
        var numChildren = this._children.length;
        if (index >= 0 && index <= numChildren) {
          if (child._parent == this) {
            this.setChildIndex(child, index);
          } else {
            if (child._parent)
              child._parent.removeChild(child);
            var cnt = this._children.length;
            if (index == cnt)
              this._children.push(child);
            else
              this._children.splice(index, 0, child);
            child._parent = this;
            child._level = this._level + 1;
            child._setTree(this._tree);
            if (this._tree && this == this._tree.rootNode || this._cell && this._cell.parent && this._expanded)
              this._tree._afterInserted(child);
          }
          return child;
        } else {
          throw new RangeError("Invalid child index");
        }
      }
      removeChild(child) {
        var childIndex = this._children.indexOf(child);
        if (childIndex != -1) {
          this.removeChildAt(childIndex);
        }
        return child;
      }
      removeChildAt(index) {
        if (index >= 0 && index < this.numChildren) {
          var child = this._children[index];
          this._children.splice(index, 1);
          child._parent = null;
          if (this._tree) {
            child._setTree(null);
            this._tree._afterRemoved(child);
          }
          return child;
        } else {
          throw "Invalid child index";
        }
      }
      removeChildren(beginIndex, endIndex) {
        beginIndex = beginIndex || 0;
        if (endIndex == null)
          endIndex = -1;
        if (endIndex < 0 || endIndex >= this.numChildren)
          endIndex = this.numChildren - 1;
        for (var i = beginIndex; i <= endIndex; ++i)
          this.removeChildAt(beginIndex);
      }
      getChildAt(index) {
        if (index >= 0 && index < this.numChildren)
          return this._children[index];
        else
          throw "Invalid child index";
      }
      getChildIndex(child) {
        return this._children.indexOf(child);
      }
      getPrevSibling() {
        if (this._parent == null)
          return null;
        var i = this._parent._children.indexOf(this);
        if (i <= 0)
          return null;
        return this._parent._children[i - 1];
      }
      getNextSibling() {
        if (this._parent == null)
          return null;
        var i = this._parent._children.indexOf(this);
        if (i < 0 || i >= this._parent._children.length - 1)
          return null;
        return this._parent._children[i + 1];
      }
      setChildIndex(child, index) {
        var oldIndex = this._children.indexOf(child);
        if (oldIndex == -1)
          throw "Not a child of this container";
        var cnt = this._children.length;
        if (index < 0)
          index = 0;
        else if (index > cnt)
          index = cnt;
        if (oldIndex == index)
          return;
        this._children.splice(oldIndex, 1);
        this._children.splice(index, 0, child);
        if (this._tree && this == this._tree.rootNode || this._cell && this._cell.parent && this._expanded)
          this._tree._afterMoved(child);
      }
      swapChildren(child1, child2) {
        var index1 = this._children.indexOf(child1);
        var index2 = this._children.indexOf(child2);
        if (index1 == -1 || index2 == -1)
          throw "Not a child of this container";
        this.swapChildrenAt(index1, index2);
      }
      swapChildrenAt(index1, index2) {
        var child1 = this._children[index1];
        var child2 = this._children[index2];
        this.setChildIndex(child1, index2);
        this.setChildIndex(child2, index1);
      }
      get numChildren() {
        return this._children.length;
      }
      expandToRoot() {
        var p = this;
        while (p) {
          p.expanded = true;
          p = p.parent;
        }
      }
      get tree() {
        return this._tree;
      }
      _setTree(value) {
        this._tree = value;
        if (this._tree && this._tree.treeNodeWillExpand && this._expanded)
          this._tree.treeNodeWillExpand(this, true);
        if (this._children) {
          var cnt = this._children.length;
          for (var i = 0; i < cnt; i++) {
            var node = this._children[i];
            node._level = this._level + 1;
            node._setTree(value);
          }
        }
      }
    };
    GTree = class extends GList {
      constructor() {
        super();
        this._indent = 15;
        this._rootNode = new GTreeNode(true);
        this._rootNode._setTree(this);
        this._rootNode.expanded = true;
      }
      get rootNode() {
        return this._rootNode;
      }
      get indent() {
        return this._indent;
      }
      set indent(value) {
        this._indent = value;
      }
      get clickToExpand() {
        return this._clickToExpand;
      }
      set clickToExpand(value) {
        this._clickToExpand = value;
      }
      getSelectedNode() {
        if (this.selectedIndex != -1)
          return this.getChildAt(this.selectedIndex)._treeNode;
        else
          return null;
      }
      getSelectedNodes(result) {
        if (!result)
          result = new Array();
        s_list.length = 0;
        super.getSelection(s_list);
        var cnt = s_list.length;
        var ret = new Array();
        for (var i = 0; i < cnt; i++) {
          var node = this.getChildAt(s_list[i])._treeNode;
          ret.push(node);
        }
        return ret;
      }
      selectNode(node, scrollItToView) {
        var parentNode = node.parent;
        while (parentNode && parentNode != this._rootNode) {
          parentNode.expanded = true;
          parentNode = parentNode.parent;
        }
        if (!node._cell)
          return;
        this.addSelection(this.getChildIndex(node._cell), scrollItToView);
      }
      unselectNode(node) {
        if (!node._cell)
          return;
        this.removeSelection(this.getChildIndex(node._cell));
      }
      expandAll(folderNode) {
        if (!folderNode)
          folderNode = this._rootNode;
        folderNode.expanded = true;
        var cnt = folderNode.numChildren;
        for (var i = 0; i < cnt; i++) {
          var node = folderNode.getChildAt(i);
          if (node.isFolder)
            this.expandAll(node);
        }
      }
      collapseAll(folderNode) {
        if (!folderNode)
          folderNode = this._rootNode;
        if (folderNode != this._rootNode)
          folderNode.expanded = false;
        var cnt = folderNode.numChildren;
        for (var i = 0; i < cnt; i++) {
          var node = folderNode.getChildAt(i);
          if (node.isFolder)
            this.collapseAll(node);
        }
      }
      createCell(node) {
        var child = this.getFromPool(node._resURL);
        if (!(child instanceof GComponent))
          throw new Error("cannot create tree node object.");
        child._treeNode = node;
        node._cell = child;
        var indentObj = child.getChild("indent");
        if (indentObj)
          indentObj.width = (node.level - 1) * this._indent;
        var cc;
        cc = child.getController("expanded");
        if (cc) {
          cc.on(Event.STATUS_CHANGED, this.__expandedStateChanged, this);
          cc.selectedIndex = node.expanded ? 1 : 0;
        }
        cc = child.getController("leaf");
        if (cc)
          cc.selectedIndex = node.isFolder ? 0 : 1;
        if (node.isFolder)
          node._cell.on(Event.TOUCH_BEGIN, this.__cellMouseDown, this);
        if (this.treeNodeRender)
          this.treeNodeRender(node, child);
      }
      _afterInserted(node) {
        if (!node._cell)
          this.createCell(node);
        var index = this.getInsertIndexForNode(node);
        this.addChildAt(node._cell, index);
        if (this.treeNodeRender)
          this.treeNodeRender(node, node._cell);
        if (node.isFolder && node.expanded)
          this.checkChildren(node, index);
      }
      getInsertIndexForNode(node) {
        var prevNode = node.getPrevSibling();
        if (prevNode == null)
          prevNode = node.parent;
        var insertIndex = this.getChildIndex(prevNode._cell) + 1;
        var myLevel = node.level;
        var cnt = this.numChildren;
        for (var i = insertIndex; i < cnt; i++) {
          var testNode = this.getChildAt(i)._treeNode;
          if (testNode.level <= myLevel)
            break;
          insertIndex++;
        }
        return insertIndex;
      }
      _afterRemoved(node) {
        this.removeNode(node);
      }
      _afterExpanded(node) {
        if (node == this._rootNode) {
          this.checkChildren(this._rootNode, 0);
          return;
        }
        if (this.treeNodeWillExpand != null)
          this.treeNodeWillExpand(node, true);
        if (node._cell == null)
          return;
        if (this.treeNodeRender)
          this.treeNodeRender(node, node._cell);
        var cc = node._cell.getController("expanded");
        if (cc)
          cc.selectedIndex = 1;
        if (node._cell.parent)
          this.checkChildren(node, this.getChildIndex(node._cell));
      }
      _afterCollapsed(node) {
        if (node == this._rootNode) {
          this.checkChildren(this._rootNode, 0);
          return;
        }
        if (this.treeNodeWillExpand)
          this.treeNodeWillExpand(node, false);
        if (node._cell == null)
          return;
        if (this.treeNodeRender)
          this.treeNodeRender(node, node._cell);
        var cc = node._cell.getController("expanded");
        if (cc)
          cc.selectedIndex = 0;
        if (node._cell.parent)
          this.hideFolderNode(node);
      }
      _afterMoved(node) {
        var startIndex = this.getChildIndex(node._cell);
        var endIndex;
        if (node.isFolder)
          endIndex = this.getFolderEndIndex(startIndex, node.level);
        else
          endIndex = startIndex + 1;
        var insertIndex = this.getInsertIndexForNode(node);
        var i;
        var cnt = endIndex - startIndex;
        var obj;
        if (insertIndex < startIndex) {
          for (i = 0; i < cnt; i++) {
            obj = this.getChildAt(startIndex + i);
            this.setChildIndex(obj, insertIndex + i);
          }
        } else {
          for (i = 0; i < cnt; i++) {
            obj = this.getChildAt(startIndex);
            this.setChildIndex(obj, insertIndex);
          }
        }
      }
      getFolderEndIndex(startIndex, level) {
        var cnt = this.numChildren;
        for (var i = startIndex + 1; i < cnt; i++) {
          var node = this.getChildAt(i)._treeNode;
          if (node.level <= level)
            return i;
        }
        return cnt;
      }
      checkChildren(folderNode, index) {
        var cnt = folderNode.numChildren;
        for (var i = 0; i < cnt; i++) {
          index++;
          var node = folderNode.getChildAt(i);
          if (node._cell == null)
            this.createCell(node);
          if (!node._cell.parent)
            this.addChildAt(node._cell, index);
          if (node.isFolder && node.expanded)
            index = this.checkChildren(node, index);
        }
        return index;
      }
      hideFolderNode(folderNode) {
        var cnt = folderNode.numChildren;
        for (var i = 0; i < cnt; i++) {
          var node = folderNode.getChildAt(i);
          if (node._cell)
            this.removeChild(node._cell);
          if (node.isFolder && node.expanded)
            this.hideFolderNode(node);
        }
      }
      removeNode(node) {
        if (node._cell) {
          if (node._cell.parent)
            this.removeChild(node._cell);
          this.returnToPool(node._cell);
          node._cell._treeNode = null;
          node._cell = null;
        }
        if (node.isFolder) {
          var cnt = node.numChildren;
          for (var i = 0; i < cnt; i++) {
            var node2 = node.getChildAt(i);
            this.removeNode(node2);
          }
        }
      }
      __cellMouseDown(evt) {
        var node = GObject.cast(evt.currentTarget)._treeNode;
        this._expandedStatusInEvt = node.expanded;
      }
      __expandedStateChanged(cc) {
        var node = cc.parent._treeNode;
        node.expanded = cc.selectedIndex == 1;
      }
      dispatchItemEvent(item, evt) {
        if (this._clickToExpand != 0) {
          var node = item._treeNode;
          if (node && this._expandedStatusInEvt == node.expanded) {
            if (this._clickToExpand == 2) ;
            else
              node.expanded = !node.expanded;
          }
        }
        super.dispatchItemEvent(item, evt);
      }
      setup_beforeAdd(buffer, beginPos) {
        super.setup_beforeAdd(buffer, beginPos);
        buffer.seek(beginPos, 9);
        this._indent = buffer.readInt();
        this._clickToExpand = buffer.readByte();
      }
      readItems(buffer) {
        var cnt;
        var i;
        var nextPos;
        var str;
        var isFolder;
        var lastNode;
        var level;
        var prevLevel = 0;
        cnt = buffer.readShort();
        for (i = 0; i < cnt; i++) {
          nextPos = buffer.readShort();
          nextPos += buffer.position;
          str = buffer.readS();
          if (str == null) {
            str = this.defaultItem;
            if (!str) {
              buffer.position = nextPos;
              continue;
            }
          }
          isFolder = buffer.readBool();
          level = buffer.readByte();
          var node = new GTreeNode(isFolder, str);
          node.expanded = true;
          if (i == 0)
            this._rootNode.addChild(node);
          else {
            if (level > prevLevel)
              lastNode.addChild(node);
            else if (level < prevLevel) {
              for (var j = level; j <= prevLevel; j++)
                lastNode = lastNode.parent;
              lastNode.addChild(node);
            } else
              lastNode.parent.addChild(node);
          }
          lastNode = node;
          prevLevel = level;
          this.setupItem(buffer, node.cell);
          buffer.position = nextPos;
        }
      }
    };
    s_list = new Array();
    UIObjectFactory = class _UIObjectFactory {
      constructor() {
      }
      static setExtension(url, type) {
        if (url == null)
          throw new Error("Invaild url: " + url);
        var pi = UIPackage.getItemByURL(url);
        if (pi)
          pi.extensionType = type;
        _UIObjectFactory.extensions[url] = type;
      }
      static setLoaderExtension(type) {
        _UIObjectFactory.loaderType = type;
      }
      static resolveExtension(pi) {
        var extensionType = _UIObjectFactory.extensions["ui://" + pi.owner.id + pi.id];
        if (!extensionType)
          extensionType = _UIObjectFactory.extensions["ui://" + pi.owner.name + "/" + pi.name];
        if (extensionType)
          pi.extensionType = extensionType;
      }
      static newObject(type, userClass) {
        var obj;
        _UIObjectFactory.counter++;
        if (typeof type === "number") {
          switch (type) {
            case ObjectType.Image:
              return new GImage();
            case ObjectType.MovieClip:
              return new GMovieClip();
            case ObjectType.Component:
              return new GComponent();
            case ObjectType.Text:
              return new GTextField();
            case ObjectType.RichText:
              return new GRichTextField();
            case ObjectType.InputText:
              return new GTextInput();
            case ObjectType.Group:
              return new GGroup();
            case ObjectType.List:
              return new GList();
            case ObjectType.Graph:
              return new GGraph();
            case ObjectType.Loader:
              if (_UIObjectFactory.loaderType)
                return new _UIObjectFactory.loaderType();
              else
                return new GLoader();
            case ObjectType.Button:
              return new GButton();
            case ObjectType.Label:
              return new GLabel();
            case ObjectType.ProgressBar:
              return new GProgressBar();
            case ObjectType.Slider:
              return new GSlider();
            case ObjectType.ScrollBar:
              return new GScrollBar();
            case ObjectType.ComboBox:
              return new GComboBox();
            case ObjectType.Tree:
              return new GTree();
            case ObjectType.Loader3D:
              return new GLoader3D();
            default:
              return null;
          }
        } else {
          if (type.type == PackageItemType.Component) {
            if (userClass)
              obj = new userClass();
            else if (type.extensionType)
              obj = new type.extensionType();
            else
              obj = _UIObjectFactory.newObject(type.objectType);
          } else
            obj = _UIObjectFactory.newObject(type.objectType);
          if (obj)
            obj.packageItem = type;
        }
        return obj;
      }
    };
    UIObjectFactory.counter = 0;
    UIObjectFactory.extensions = {};
    Decls.UIObjectFactory = UIObjectFactory;
  }
});

// assets/scripts/framework/GameSettings.ts
var GameSettings_exports = {};
__export(GameSettings_exports, {
  GameSettings: () => GameSettings
});
var import_env3, import_cc6, _GameSettings, GameSettings;
var init_GameSettings = __esm({
  "assets/scripts/framework/GameSettings.ts"() {
    import_env3 = require("cc/env");
    import_cc6 = require("cc");
    init_ResManager();
    _GameSettings = class _GameSettings {
      static getValue(key) {
        return this.datas[key];
      }
      static setValue(key, value) {
        this.datas[key] = value;
      }
      static async initial() {
        let configAsset = await ResManager.getAsync(null, "config", import_cc6.JsonAsset);
        this._initial(configAsset.json);
      }
      static _initial(config) {
        this.rawData = config;
        let keys = Object.keys(config);
        for (let key of keys) {
          this[key] = config[key];
        }
        if (window["configVersion"]) {
          this.realVersion = window["configVersion"];
        }
        console.log("Build Time: " + this.time);
        console.log("GitInfo: ", this.gitInfo);
      }
      /**
       * 重置远程服务器地址，用于通过版本号或者配置版本号来重置远程服务器地址
       * @param configVersion 配置版本号
       * @returns 
       */
      static resetRemoveServer(configVersion) {
        if (import_env3.HTML5 && import_env3.PREVIEW) {
          console.log("HTML5\u4E0D\u9700\u8981\u91CD\u7F6E\u8FDC\u7A0B\u670D\u52A1\u5668\u5730\u5740");
          return;
        }
        let downloader = import_cc6.assetManager.downloader;
        if (!import_env3.PREVIEW) {
          if (!window["configVersion"] && configVersion) {
            const versionCfg = configVersion;
            if (versionCfg && versionCfg.configVersion) {
              _GameSettings.realVersion = versionCfg.configVersion;
            }
          }
        }
        let newUrl = downloader.remoteServerAddress;
        let version = _GameSettings.realVersion;
        newUrl = `${newUrl.replace(/\/$/g, "")}/${_GameSettings.channel}/${version}/`;
        downloader.init(newUrl, downloader.bundleVers, downloader.remoteBundles);
      }
    };
    _GameSettings.rawData = {};
    _GameSettings.useid = "";
    _GameSettings.channel = "wx";
    _GameSettings.version = "1.0.0";
    _GameSettings.isDebug = false;
    _GameSettings.realVersion = "1.0.0";
    _GameSettings.mergeTimeScale = 1;
    _GameSettings.packages = [];
    _GameSettings.uiPackages = [];
    _GameSettings.datas = {};
    _GameSettings.debug = {};
    _GameSettings.time = "";
    _GameSettings.gitInfo = {
      version: "",
      shortVersion: "",
      author: "",
      time: ""
    };
    GameSettings = _GameSettings;
  }
});

// assets/scripts/framework/activity/proxy/AcitivityProxyManager.ts
var AcitivityProxyManager_exports = {};
__export(AcitivityProxyManager_exports, {
  ActivityProxyManager: () => ActivityProxyManager
});
var import_env4, _ActivityProxyManager, ActivityProxyManager;
var init_AcitivityProxyManager = __esm({
  "assets/scripts/framework/activity/proxy/AcitivityProxyManager.ts"() {
    import_env4 = require("cc/env");
    _ActivityProxyManager = class _ActivityProxyManager {
      constructor() {
        this._proxyList = [];
        this._proxyMap = {};
      }
      static get inst() {
        return this._inst;
      }
      regist(proxy) {
        if (this._proxyMap[proxy.name]) {
          this.unregist(proxy.name);
        }
        this._proxyMap[proxy.name] = proxy;
        this._proxyList.push(proxy);
        proxy.regist();
      }
      unregist(name, destoryEnterView) {
        let proxy = this._proxyMap[name];
        if (!proxy) {
          console.error(`\u5378\u8F7D\u672A\u6CE8\u518Cproxy=${proxy.name}`);
          return;
        }
        proxy.unregist(destoryEnterView);
        delete this._proxyMap[name];
        let idx = this._proxyList.indexOf(proxy);
        if (idx >= 0) {
          this._proxyList.splice(idx, 1);
        }
      }
      update(dt, secondTick) {
        for (let i = this._proxyList.length - 1; i >= 0; i--) {
          let proxy = this._proxyList[i];
          if (proxy.enable) {
            proxy.update(dt, secondTick);
          }
        }
      }
      setEnable(name, enable) {
        let proxy = this._proxyMap[name];
        if (!proxy) {
          if (import_env4.EDITOR) {
            console.error(`\u672A\u6CE8\u518Cproxy=${name}`);
          }
          return;
        }
        proxy.setEnable(enable);
      }
    };
    _ActivityProxyManager._inst = new _ActivityProxyManager();
    ActivityProxyManager = _ActivityProxyManager;
  }
});

// assets/scripts/framework/view/ViewMap.ts
var ViewMap_exports = {};
__export(ViewMap_exports, {
  default: () => ViewMap
});
var _ViewMap, ViewMap;
var init_ViewMap = __esm({
  "assets/scripts/framework/view/ViewMap.ts"() {
    _ViewMap = class _ViewMap {
      constructor() {
        this._views = {};
        this._skins = {};
        this._skinNames = {};
      }
      static get instance() {
        if (!this._instance) {
          this._instance = new _ViewMap();
        }
        return this._instance;
      }
      add(skin, viewClass) {
        let key = skin.getKey();
        this._views[key] = viewClass;
        viewClass[_ViewMap.sTypeName] = key;
        this._skins[key] = skin;
        this._skinNames[skin.componentName] = skin;
      }
      remove(skin) {
        let key = skin.getKey();
        if (this._views[key]) {
          delete this._views[key][_ViewMap.sTypeName];
        }
        delete this._views[key];
        delete this._skins[key];
        delete this._skinNames[skin.componentName];
      }
      get(skin) {
        return this._views[skin.getKey()];
      }
      getByName(name) {
        let skin = this.getSkinByName(name);
        if (skin) {
          return this.get(skin);
        }
        console.error("ViewMap getByName error: " + name);
        return null;
      }
      getSkin(key) {
        return this._skins[key];
      }
      getSkinByName(name) {
        return this._skinNames[name];
      }
      getSkinByType(type) {
        let key = type[_ViewMap.sTypeName];
        return this.getSkin(key);
      }
      get allViews() {
        return this._views;
      }
    };
    _ViewMap.sTypeName = "__type_name__";
    ViewMap = _ViewMap;
  }
});

// assets/scripts/framework/view/Skin.ts
var Skin_exports = {};
__export(Skin_exports, {
  default: () => Skin
});
var Skin;
var init_Skin = __esm({
  "assets/scripts/framework/view/Skin.ts"() {
    init_ViewMap();
    Skin = class {
      constructor(_path, _pkgName, _cmpName, _data, _isWindow, _autoWarpper, _assetbundle) {
        this.suffix = "";
        this.isWindow = false;
        // activity是否自动被loader包含
        this.autoWarpper = false;
        this._key = null;
        this.path = _path;
        this.packageName = _pkgName;
        this.componentName = _cmpName;
        this.data = _data;
        this.isWindow = _isWindow;
        this.autoWarpper = _autoWarpper;
        this.assetbundle = _assetbundle;
      }
      getKey() {
        if (this._key) {
          return this._key;
        }
        let key = this.path + "|" + this.packageName + "|" + this.componentName + this.suffix;
        if (this.data) {
          key += "|" + this.data;
        }
        this._key = key.toLowerCase();
        return this._key;
      }
      static bindSkin(viewType, skin) {
        ViewMap.instance.add(skin, viewType);
      }
      static getSkin(viewType) {
        return ViewMap.instance.getSkinByType(viewType);
      }
    };
  }
});

// assets/scripts/framework/view/utils/FGUIExt.ts
var FGUIExt_exports = {};
__export(FGUIExt_exports, {
  default: () => FGUIExt
});
var import_cc7, FGUIExt;
var init_FGUIExt = __esm({
  "assets/scripts/framework/view/utils/FGUIExt.ts"() {
    init_Skin();
    init_fairygui();
    import_cc7 = require("cc");
    init_fairygui();
    FGUIExt = class _FGUIExt {
      static unloadPackage(name) {
        var _a;
        (_a = UIPackage.getByName(name)) == null ? void 0 : _a.dispose();
      }
      static async preloadPackage(abname, path4, progress, delay) {
        return new Promise((resolve, reject) => {
          if (abname) {
            let defaultDelay = delay ?? UIConfig.enableDelayLoad;
            abname = abname ?? Skin.defaultAssetBundle;
            let assetbundle = import_cc7.assetManager.getBundle(abname);
            UIPackage.loadPackage(assetbundle, path4, (finish, total, item) => {
              progress == null ? void 0 : progress.call(finish / total, total);
            }, (err, pk) => {
              if (err) {
                reject(err);
              } else {
                resolve();
              }
            }, defaultDelay);
          } else {
            UIPackage.loadPackage(path4, (finish, total, item) => {
              progress == null ? void 0 : progress.call(finish / total, total);
            }, (err, pk) => {
              if (err) {
                reject(err);
              } else {
                resolve();
              }
            });
          }
        });
      }
      static checkPackageLoaded(skin) {
        let pkg = UIPackage.getByName(skin.packageName);
        if (pkg == null) {
          let abname = Skin.defaultAssetBundle ?? skin.assetbundle;
          if (abname) {
            let assetbundle = import_cc7.assetManager.getBundle(abname);
            UIPackage.loadPackage(assetbundle, skin.path, (err, pk) => {
              pkg = pk;
            });
            console.log("please preload ui assets in assetbundle mode");
          }
          pkg = UIPackage.addPackage(skin.path);
        }
        return pkg;
      }
      static createObject(skin) {
        let pkg = _FGUIExt.checkPackageLoaded(skin);
        return pkg.createObject(skin.componentName);
      }
      static createObjectByType(skin, type) {
        let pkg = _FGUIExt.checkPackageLoaded(skin);
        return pkg.createObject(skin.componentName, type);
      }
      static cloneObject(obj) {
        return UIPackage.createObjectFromURL(obj.resourceURL);
      }
    };
  }
});

// assets/scripts/framework/view/SkinHelper.ts
var SkinHelper_exports = {};
__export(SkinHelper_exports, {
  default: () => SkinHelper
});
var _SkinHelper, SkinHelper;
var init_SkinHelper = __esm({
  "assets/scripts/framework/view/SkinHelper.ts"() {
    init_fairygui();
    init_Skin();
    init_FGUIExt();
    init_fairygui();
    init_fairygui();
    _SkinHelper = class _SkinHelper {
      static registUIPackage(pkg, abName, path4 = "") {
        this._uiPackagePath[pkg] = { abName, path: path4 };
      }
      static getUIPackage(pkg) {
        return this._uiPackagePath[pkg];
      }
      static initial() {
        for (let info of this._bindingInfos) {
          this.bindingSkin(info.type, info.uiPackage, info.componentName, info.data, info.isWindow, info.autoWarpper);
        }
        this._bindingInfos.length = 0;
      }
      static preBindingSkin(type, uiPackage, componentName, data, isWindow, autoWarpper) {
        let bindingInfo = {
          type,
          uiPackage,
          componentName,
          data,
          isWindow,
          autoWarpper
        };
        this._bindingInfos.push(bindingInfo);
      }
      static bindingSkin(type, uiPackage, componentName, data, isWindow, autoWarpper) {
        let info = this.getUIPackage(uiPackage);
        if (!info) {
          console.error(`UI\u5305 ${uiPackage} \u672A\u7ED1\u5B9A`);
          return;
        }
        let preifx = info.path ? `${info.path}/` : "";
        Skin.bindSkin(type, new Skin(`${preifx}${uiPackage}`, uiPackage, componentName, data, isWindow, autoWarpper, info.abName));
      }
      static preloadUIPackage(uiPackage, progress) {
        let info = this.getUIPackage(uiPackage);
        if (!info) {
          console.error(`UI\u5305 ${uiPackage} \u672A\u7ED1\u5B9A`);
          return;
        }
        let preifx = info.path ? `${info.path}/` : "";
        return FGUIExt.preloadPackage(info.abName, `${preifx}${uiPackage}`, progress);
      }
      static getNames(path4) {
        return path4 ? path4.split(".") : [""];
      }
      static getIndex(name) {
        let match = name.match(_SkinHelper.regex);
        if (match && match.length == 1) {
          let g = match[0].replace("[", "").replace("]", "");
          let newname = name.replace(_SkinHelper.regex, "");
          return { id: Number(g), newName: newname };
        } else {
          return null;
        }
      }
      static InjectSkin(skin, view5) {
        let go = FGUIExt.createObject(skin);
        _SkinHelper.InjectView(go, view5);
      }
      static IsGLoader(type) {
        if (type == GLoader) {
          return true;
        }
        if (type.__proto__ && type.__proto__.name) {
          return _SkinHelper.IsGObject(type.__proto__);
        }
        return false;
      }
      static IsGObject(type) {
        if (type == GObject) {
          return true;
        }
        if (type.__proto__ && type.__proto__.name) {
          return _SkinHelper.IsGObject(type.__proto__);
        }
        return false;
      }
      static OtherFGUIType(type) {
        return _SkinHelper.IsController(type) || _SkinHelper.IsTransition(type);
      }
      static IsController(type) {
        if (type == Controller) {
          return true;
        }
        if (type.__proto__ && type.__proto__.name) {
          return _SkinHelper.IsController(type.__proto__);
        }
        return false;
      }
      static IsTransition(type) {
        if (type == Transition) {
          return true;
        }
        if (type.__proto__ && type.__proto__.name) {
          return _SkinHelper.IsTransition(type.__proto__);
        }
        return false;
      }
      static IsFGUIObject(type) {
        if (_SkinHelper.IsGObject(type)) {
          return true;
        }
        if (_SkinHelper.IsController(type)) {
          return true;
        }
        if (_SkinHelper.IsTransition(type)) {
          return true;
        }
        return false;
      }
      static InjectView(component, view5) {
        view5 = view5 || component;
        if (!view5) {
          return;
        }
        if (view5.registInfos) {
          view5.registInfos();
        }
        if (!view5.injectInfos && !view5.__injectInfos) {
          return;
        }
        component["__docker__"] = view5;
        let injectInfos = {
          ...view5.__injectInfos || {},
          ...view5.injectInfos || {}
        };
        for (let field in injectInfos) {
          let f = view5[field];
          let t = typeof f;
          if (f instanceof Function || t == "boolean" || t == "string" || t == "number") {
            continue;
          }
          let names = [field];
          let type = null;
          let optional = true;
          let data = null;
          let hasCache = !!(this._cache[component.resourceURL] && this._cache[component.resourceURL][field]);
          if (injectInfos[field]) {
            let oldpath = injectInfos[field];
            if (oldpath instanceof Function) {
              continue;
            }
            let path4 = oldpath;
            if (oldpath instanceof Object) {
              type = oldpath.type;
              path4 = oldpath.path;
              data = oldpath.data;
              optional = oldpath.optional;
            }
            if (!type) {
              console.error(`${field}\u7684\u7C7B\u578B\u4E0D\u80FD\u4E3A\u7A7A`);
              return;
            }
            if (hasCache) {
              path4 = this._cache[component.resourceURL][field];
              this._hitCache++;
            }
            names = _SkinHelper.getNames(path4);
            if (!names[0]) {
              names[0] = field;
            } else if (!names[names.length - 1]) {
              names[names.length - 1] = field;
            }
          } else {
            if (hasCache) {
              names = _SkinHelper.getNames(this._cache[component.resourceURL][field]);
              this._hitCache++;
            }
          }
          let go = component;
          let endName = field;
          let endIndex = -1;
          let indices = [];
          for (let id = 0; id < names.length; id++) {
            let name = names[id];
            let ids = _SkinHelper.getIndex(name);
            endName = name;
            if (ids) {
              if (go && go.asCom.getChild) {
                if (id != names.length - 1 || id == names.length - 1 && !_SkinHelper.OtherFGUIType(type)) {
                  if (ids.newName) {
                    let parent = go.asCom;
                    go = parent.getChild(ids.newName);
                    if (!hasCache) {
                      indices.push(parent.getChildIndex(go));
                    }
                  }
                  if (go.asCom.getChild) {
                    if (!_SkinHelper.OtherFGUIType(type)) {
                      go = go.asCom.getChildAt(ids.id);
                      if (!hasCache) {
                        indices.push(ids.id);
                      }
                    }
                  } else {
                    console.error("can not find view with path:" + names.join("-") + " in " + ids.newName);
                  }
                }
              } else if (go && _SkinHelper.IsGLoader(go.constructor)) {
                if (id != names.length - 1 || id == names.length - 1 && !_SkinHelper.OtherFGUIType(type)) {
                  var loader = go;
                  if (ids.newName) {
                    go = loader.component.getChild(ids.newName);
                    if (!hasCache) {
                      indices.push(loader.component.getChildIndex(go));
                    }
                  }
                  if (loader.component.getChild) {
                    if (!_SkinHelper.OtherFGUIType(type)) {
                      go = loader.component.getChildAt(ids.id);
                      if (!hasCache) {
                        indices.push(ids.id);
                      }
                    }
                  } else {
                    console.error("can not find view with path:" + names.join("-") + " in " + ids.newName);
                  }
                }
              } else {
                console.error("can not find view with path:" + names.join("-") + " in " + name);
              }
              endIndex = ids.id;
            } else if (go && go.asCom.getChild) {
              if (id != names.length - 1 || id == names.length - 1 && !_SkinHelper.OtherFGUIType(type)) {
                let parent = go.asCom;
                go = parent.getChild(name);
                if (!hasCache) {
                  indices.push(parent.getChildIndex(go));
                }
              }
            } else if (go && _SkinHelper.IsGLoader(go.constructor)) {
              if (id != names.length - 1 || id == names.length - 1 && !_SkinHelper.OtherFGUIType(type)) {
                var loader = go;
                go = loader.component.getChild(name);
                if (!hasCache) {
                  indices.push(loader.component.getChildIndex(go));
                }
              }
            } else {
              go = null;
              console.error("can not find view with path:" + names.join("-") + " in " + name);
            }
          }
          if (go) {
            if (type && !view5[field] && !_SkinHelper.IsFGUIObject(type)) {
              var obj = new type();
              view5[field] = obj;
            }
            if (view5[field] == null) {
              view5[field] = go;
              _SkinHelper.checkButtionAnimation(go, false);
              if (_SkinHelper.IsController(type)) {
                var loader = go;
                let comp = _SkinHelper.IsGLoader(go.constructor) && loader.component ? loader.component : go.asCom;
                if (endIndex >= 0) {
                  view5[field] = comp.getControllerAt(endIndex);
                  if (!hasCache) {
                    indices.push(endIndex);
                  }
                } else {
                  view5[field] = comp.getController(endName);
                  if (!hasCache) {
                    for (let i = 0; i < comp.controllers.length; i++) {
                      if (comp.controllers[i].name == endName) {
                        indices.push(i);
                      }
                    }
                  }
                }
              } else if (_SkinHelper.IsTransition(type)) {
                var loader = go;
                let comp = _SkinHelper.IsGLoader(go.constructor) && loader.component ? loader.component : go.asCom;
                if (endIndex >= 0) {
                  view5[field] = comp.getTransitionAt(endIndex);
                  if (!hasCache) {
                    indices.push(endIndex);
                  }
                } else {
                  view5[field] = comp.getTransition(endName);
                  if (!hasCache) {
                    for (let i = 0; i < comp._transitions.length; i++) {
                      if (comp._transitions[i].name == endName) {
                        indices.push(i);
                      }
                    }
                  }
                }
              }
            } else if (view5[field].inject instanceof Function) {
              _SkinHelper.checkButtionAnimation(go, false);
              view5[field].injectSource = view5;
              view5[field].inject(go, data);
              if (!hasCache) {
                this.cacheView(field, indices, component.resourceURL);
              }
              if (view5.addView) {
                view5.addView(view5[field]);
              }
            }
          } else if (!go && !view5[field]) {
            let info = "can not find view in " + typeof view5 + " with path:" + names.join("-");
            if (!optional) {
              console.error(info);
            } else {
              console.warn(info);
            }
          }
        }
      }
      static cacheView(field, indices, resUrl) {
        if (!this.enableCache) {
          return;
        }
        if (!this._cache[resUrl]) {
          this._cache[resUrl] = {};
        }
        let cache = this._cache[resUrl];
        cache[field] = indices.map((id) => `[${id}]`).join(".");
      }
      static checkButtionAnimation(item, force = false) {
        if (!(item instanceof GButton)) {
          return;
        }
        let button = item;
        if (button.downEffect > 0 || force) {
          button.downEffect = 0;
          let controller = button.getController("button");
          if (!controller) {
            controller = new Controller();
            controller.name = "button";
            controller.addPage("up");
            controller.addPage("down");
            controller.addPage("over");
            controller.addPage("selectedOver");
            button.addController(controller);
            controller.selectedIndex = 0;
            button._buttonController = controller;
          }
          if (_SkinHelper.buttonUpTranslation) {
            button.addControllerAction("button", _SkinHelper.buttonUpTranslation, ["down", "selectedOver"], ["up", "over"]);
          }
          if (_SkinHelper.buttonDownTranslation) {
            button.addControllerAction("button", _SkinHelper.buttonDownTranslation, ["up", "over"], ["down", "selectedOver"]);
          }
        }
      }
      static addButtonCommonAnimation(button) {
        _SkinHelper.checkButtionAnimation(button);
      }
      static createAndInjectByUrl(type, url, parent, data) {
        const comp = UIPackage.createObjectFromURL(url);
        return _SkinHelper.createAndInject(type, comp, parent, data);
      }
      static createAndInject(type, comp, parent, data) {
        const view5 = new type();
        view5.inject(comp);
        view5.injectSource = parent;
        parent == null ? void 0 : parent.addView(view5);
        view5.show(data, false);
        return view5;
      }
    };
    _SkinHelper.regex = /\[\d+\]$/g;
    _SkinHelper._bindingInfos = [];
    _SkinHelper._uiPackagePath = {};
    // 缓存路径与索引的关系
    _SkinHelper._cache = {};
    _SkinHelper._hitCache = 0;
    _SkinHelper.enableCache = true;
    SkinHelper = _SkinHelper;
  }
});

// assets/scripts/framework/view/View.ts
var View_exports = {};
__export(View_exports, {
  default: () => View2
});
var View2;
var init_View = __esm({
  "assets/scripts/framework/view/View.ts"() {
    init_SkinHelper();
    init_Container();
    View2 = class extends Container {
      ///////////////////////////////////////////////////////
      constructor() {
        super();
        this.injectInfos = {};
        this.data = null;
        this.injectSource = null;
        this.injectData = null;
        this.enableWating = false;
      }
      registInfos() {
      }
      get visible() {
        return this.gObject.visible;
      }
      set visible(val) {
        this.gObject.visible = val;
      }
      get component() {
        return this.gObject;
      }
      inject(go, data) {
        this._isCreated = false;
        this.gObject = go;
        this.injectData = data;
        this.data = data;
        this.onInitial();
        SkinHelper.InjectView(go, this);
        let ret = this.onCreate(data);
        if (ret instanceof Promise) {
          (async () => {
            await ret;
            this.endCreate();
          })();
        } else {
          this.endCreate();
        }
      }
      async show(data, changeVisiable = true) {
        this._isShown = false;
        this.data = data;
        if (changeVisiable) {
          this.gObject.visible = true;
        }
        this.children.forEach((v) => {
          v.show(data, false);
        });
        let ret = this.onShown(data, changeVisiable);
        if (ret instanceof Promise) {
          await ret;
        }
        this.endShown();
      }
      hide(changeVisiable = true) {
        if (changeVisiable) {
          this.gObject.visible = false;
        }
        this.children.forEach((v) => {
          v.hide(false);
        });
        this.clearEventCenter();
        this.onHide(changeVisiable);
      }
      dispose() {
        if (this._destoried) {
          return;
        }
        this._destoried = true;
        this.children.forEach((v) => {
          v.dispose();
        });
        this.clearEventCenter();
        if (this.gObject != null) {
          this.gObject.dispose();
        }
        this.gObject = null;
        this.onDispose();
      }
      //////////////////////////////////////////////////////////////////////////
      onInitial() {
      }
      onCreate(data) {
      }
      onShown(data, changeVisiable) {
      }
      onHide(changeVisiable) {
      }
      onDispose() {
      }
    };
  }
});

// assets/scripts/framework/activity/proxy/BaseActivityProxy.ts
var BaseActivityProxy_exports = {};
__export(BaseActivityProxy_exports, {
  BaseActivityProxy: () => BaseActivityProxy,
  EnterButton: () => EnterButton
});
var BaseActivityProxy, EnterButton;
var init_BaseActivityProxy = __esm({
  "assets/scripts/framework/activity/proxy/BaseActivityProxy.ts"() {
    init_fairygui();
    init_fairygui();
    init_fairygui();
    init_BaseActivityController();
    init_View();
    init_EventCenter();
    BaseActivityProxy = class {
      constructor(name, ctrl, parent, holder, ctx) {
        this._opened = false;
        this.enterViewComponent = "BtnEnter";
        this.enterViewType = EnterButton;
        this._enable = false;
        this.needOpenOnPreview = true;
        this._name = name;
        this._holder = holder;
        this._parent = parent;
        this.context = ctx || {};
        this.context.indexInList = this.context.indexInList ?? -1;
        this.ctrl = ctrl;
        if (this.context.enterView) {
          this.context.enterView.visible = false;
        }
        if (this.context.disposeOnClose == void 0) {
          this.context.disposeOnClose = true;
        }
        EventCenter.I.on(BaseActivityController.ACTIVITY_STATUS_CHANGE, this.onActivityStatusChanged, this);
        EventCenter.I.on(BaseActivityController.ACTIVITY_CONTROLLER_REGISTED, this.onControllerRegisted, this);
      }
      get name() {
        return this._name;
      }
      get enable() {
        return this._enable;
      }
      get opened() {
        return this._opened;
      }
      onControllerRegisted(controller) {
        if (controller == this.ctrl) {
          this.checkOpen();
        }
      }
      onActivityStatusChanged(proxy, status, oldStatus) {
        if (proxy == this.ctrl) {
          this.onStatusChanged(status, oldStatus);
          if (!this.checkOpen()) {
            this.close();
          }
        }
      }
      onStatusChanged(status, oldStatus) {
      }
      create() {
        this.checkOpen();
      }
      checkOpen() {
        if (!this.isOpening()) {
          return false;
        }
        this.ctrl.loadRes(() => {
          this.open();
        }, this);
        return true;
      }
      regist() {
        this.onRegist();
        return this;
      }
      unregist(destoryEnterView) {
        if (destoryEnterView) {
          this.close(true);
        }
        this.onUnregist();
      }
      isOpening() {
        if (this.needOpenOnPreview) {
          return this.ctrl.status != 0 /* NotOpen */ && this.ctrl.status != 5 /* End */;
        }
        return this.ctrl.status == 3 /* Opening */ || this.ctrl.status == 4 /* PreEnd */;
      }
      onCreateView() {
        if (!this.enterView && (this.enterViewComponent || this.context.enterView) && this.enterViewType) {
          let view5 = this.context.enterView;
          if (!view5) {
            let pkgName = this.ctrl.config.pkgName;
            if (this._holder instanceof GLoader) {
              let url = UIPackage.getItemURL(pkgName, this.enterViewComponent);
              this._holder.url = url;
              view5 = this._holder.component;
            } else {
              view5 = UIPackage.createObject(pkgName, this.enterViewComponent);
              if (this.context.indexInList >= 0) {
                this._holder.addChildAt(view5, this.context.indexInList);
              } else {
                this._holder.addChild(view5);
              }
            }
          } else {
            view5.visible = true;
          }
          this.enterView = new this.enterViewType();
          this.enterView.inject(view5);
          this.enterView.injectSource = this._parent;
          this._parent.addView(this.enterView);
          this.enterView.show(null, false);
          this.layoutParent();
          if (this.context.viewCreateCallback) {
            this.context.viewCreateCallback(this.enterView);
          }
        }
      }
      layoutParent() {
        if ((this.context.adaptHeight || this.context.adaptWidth) && this._holder) {
          if (this._holder instanceof GComponent) {
            if (this._holder.scrollPane) {
              this._holder.ensureBoundsCorrect();
              if (this.context.adaptHeight) {
                this._holder.height = this._holder.scrollPane.contentHeight;
              }
              if (this.context.adaptWidth) {
                this._holder.width = this._holder.scrollPane.contentWidth;
              }
            } else if (this.enterView) {
              if (this.context.adaptHeight) {
                this._holder.height = this.enterView.component.height;
              }
              if (this.context.adaptWidth) {
                this._holder.width = this.enterView.component.width;
              }
            } else {
              if (this.context.adaptHeight) {
                this._holder.height = 0;
              }
              if (this.context.adaptWidth) {
                this._holder.width = 0;
              }
            }
          } else if (this._holder instanceof GLoader) {
            if (this.context.adaptHeight) {
              this._holder.component.height = this._holder.height;
            }
            if (this.context.adaptWidth) {
              this._holder.component.width = this._holder.width;
            }
          }
        }
      }
      /**
       * 打开活动, 资源加载完成后调用
       * @returns 
       */
      open() {
        if (this._opened) {
          return;
        }
        this._opened = true;
        this.onCreateView();
        this.onOpen();
      }
      /**
       * 关闭活动, 会卸载资源
       * @returns 
       */
      close(forceDispose) {
        if (!this._opened) {
          return;
        }
        this._opened = false;
        this.onClose();
        if (this.context.disposeOnClose || forceDispose) {
          this.enterView.dispose();
          this.enterView = null;
          if (this.context.viewDisposeCallback) {
            this.context.viewDisposeCallback();
          }
        }
        this.layoutParent();
      }
      dispose() {
        if (this.enterView) {
          this.enterView.dispose();
          this.enterView = null;
        }
        this.setEnable(false);
        if (this.context.viewDisposeCallback) {
          this.context.viewDisposeCallback();
        }
      }
      update(dt, secondTick) {
        if (!this._opened) {
          return;
        }
        if (this.enterView && this.context.needUpdateView && this.enterView.onUpdate) {
          this.enterView.onUpdate(dt, secondTick);
        }
        this.onUpdate(dt, secondTick);
      }
      setEnable(enable) {
        if (this._enable == enable) {
          if (this.enterView && this.enterView.visible != enable) {
            if (this.enterView) {
              this.enterView.visible = enable;
            }
            this.layoutParent();
          }
          return;
        }
        if (enable) {
          this.onEnable();
        } else {
          this.onDisable();
        }
        this._enable = enable;
        if (this.enterView) {
          this.enterView.visible = enable;
        }
        this.layoutParent();
      }
      onRegist() {
      }
      onUnregist(destoryEnterView) {
      }
      onOpen() {
        if (this.enterView) {
          this.enterView.visible = this.context.canShowView ? this.context.canShowView() : true;
        }
      }
      onClose() {
        if (this.enterView) {
          this.enterView.visible = false;
        }
      }
      onUpdate(dt, secondTick) {
      }
      onEnable() {
      }
      onDisable() {
      }
    };
    EnterButton = class extends View2 {
      onCreate(data) {
        super.onCreate(data);
        this.btn = this.component;
        this.btn.onClick(this.onClick, this);
      }
      onClick() {
      }
    };
  }
});

// assets/scripts/framework/activity/proxy/IActivityProxy.ts
var IActivityProxy_exports = {};
var init_IActivityProxy = __esm({
  "assets/scripts/framework/activity/proxy/IActivityProxy.ts"() {
  }
});

// assets/scripts/framework/common/CombineTexMaterialMgr.ts
var require_CombineTexMaterialMgr = __commonJS({
  "assets/scripts/framework/common/CombineTexMaterialMgr.ts"() {
  }
});

// assets/scripts/framework/common/EncryptHelper.ts
var EncryptHelper_exports = {};
__export(EncryptHelper_exports, {
  EncryptHelper: () => EncryptHelper
});
var EncryptHelper;
var init_EncryptHelper = __esm({
  "assets/scripts/framework/common/EncryptHelper.ts"() {
    EncryptHelper = class {
      //public method for encoding
      /**
       * base64加密
       * @param {string}input 
       * @returns 
       */
      static base64Encode(input) {
        let keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        let output = "", chr1, chr2, chr3, enc1, enc2, enc3, enc4, i = 0;
        input = this._utf8Encode(input);
        while (i < input.length) {
          chr1 = input.charCodeAt(i++);
          chr2 = input.charCodeAt(i++);
          chr3 = input.charCodeAt(i++);
          enc1 = chr1 >> 2;
          enc2 = (chr1 & 3) << 4 | chr2 >> 4;
          enc3 = (chr2 & 15) << 2 | chr3 >> 6;
          enc4 = chr3 & 63;
          if (isNaN(chr2)) {
            enc3 = enc4 = 64;
          } else if (isNaN(chr3)) {
            enc4 = 64;
          }
          output = output + keyStr.charAt(enc1) + keyStr.charAt(enc2) + keyStr.charAt(enc3) + keyStr.charAt(enc4);
        }
        return output;
      }
      /**
       * utf-8 加密
       * @param string 
       * @returns 
       */
      static _utf8Encode(string) {
        string = string.replace(/\r\n/g, "\n");
        let utftext = "";
        for (let n = 0; n < string.length; n++) {
          let c = string.charCodeAt(n);
          if (c < 128) {
            utftext += String.fromCharCode(c);
          } else if (c > 127 && c < 2048) {
            utftext += String.fromCharCode(c >> 6 | 192);
            utftext += String.fromCharCode(c & 63 | 128);
          } else {
            utftext += String.fromCharCode(c >> 12 | 224);
            utftext += String.fromCharCode(c >> 6 & 63 | 128);
            utftext += String.fromCharCode(c & 63 | 128);
          }
        }
        return utftext;
      }
      /**
       * utf-8解密
       * @param utftext 
       * @returns 
       */
      static _utf8Decode(utftext) {
        let string = "";
        let i = 0;
        let c = 0;
        let c1 = 0;
        let c2 = 0;
        let c3 = 0;
        while (i < utftext.length) {
          c = utftext.charCodeAt(i);
          if (c < 128) {
            string += String.fromCharCode(c);
            i++;
          } else if (c > 191 && c < 224) {
            c2 = utftext.charCodeAt(i + 1);
            string += String.fromCharCode((c & 31) << 6 | c2 & 63);
            i += 2;
          } else {
            c2 = utftext.charCodeAt(i + 1);
            c3 = utftext.charCodeAt(i + 2);
            string += String.fromCharCode((c & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
            i += 3;
          }
        }
        return string;
      }
      /**
       * base64解密
       * @param {string}input 解密字符串
       * @returns 
       */
      static base64Decode(input) {
        let keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        let output = "";
        let chr1;
        let chr2;
        let chr3;
        let enc1;
        let enc2;
        let enc3;
        let enc4;
        let i = 0;
        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
        while (i < input.length) {
          enc1 = keyStr.indexOf(input.charAt(i++));
          enc2 = keyStr.indexOf(input.charAt(i++));
          enc3 = keyStr.indexOf(input.charAt(i++));
          enc4 = keyStr.indexOf(input.charAt(i++));
          chr1 = enc1 << 2 | enc2 >> 4;
          chr2 = (enc2 & 15) << 4 | enc3 >> 2;
          chr3 = (enc3 & 3) << 6 | enc4;
          output = output + String.fromCharCode(chr1);
          if (enc3 != 64) {
            output = output + String.fromCharCode(chr2);
          }
          if (enc4 != 64) {
            output = output + String.fromCharCode(chr3);
          }
        }
        output = this._utf8Decode(output);
        return output;
      }
      /**
       * 数据解密[请根据实际情况修改解密方式]
       * @param {String} str 
       */
      static decrypt(b64Data) {
        return this.base64Decode(b64Data);
      }
      /**
       * 数据加密[请根据实际情况修改加密方式]
       * @param {String} str 
       */
      static encrypt(str) {
        return this.base64Encode(str);
      }
    };
  }
});

// assets/scripts/framework/common/Logger.ts
var Logger_exports = {};
__export(Logger_exports, {
  LogLevel: () => LogLevel,
  LogSettings: () => LogSettings
});
var import_env5, LogLevel, LogSettings;
var init_Logger = __esm({
  "assets/scripts/framework/common/Logger.ts"() {
    import_env5 = require("cc/env");
    LogLevel = /* @__PURE__ */ ((LogLevel2) => {
      LogLevel2[LogLevel2["DEBUG"] = 0] = "DEBUG";
      LogLevel2[LogLevel2["INFO"] = 1] = "INFO";
      LogLevel2[LogLevel2["WARN"] = 2] = "WARN";
      LogLevel2[LogLevel2["ERROR"] = 3] = "ERROR";
      LogLevel2[LogLevel2["OFF"] = 4] = "OFF";
      return LogLevel2;
    })(LogLevel || {});
    LogSettings = {
      logLevel: 1 /* INFO */
    };
    if (!import_env5.DEBUG) {
      const sysLog = console.log;
      const sysWarn = console.warn;
      const sysError = console.error;
      const sysDebug = console.debug;
      console.log = function(...data) {
        if (LogSettings.logLevel <= 1 /* INFO */) {
          sysLog.call(console, ...data);
        }
      };
      console.warn = function(...data) {
        if (LogSettings.logLevel <= 2 /* WARN */) {
          sysWarn.call(console, ...data);
        }
      };
      console.error = function(...data) {
        if (LogSettings.logLevel <= 3 /* ERROR */) {
          sysError.call(console, ...data);
        }
      };
      console.debug = function(...data) {
        if (LogSettings.logLevel <= 0 /* DEBUG */) {
          sysDebug.call(console, ...data);
        }
      };
    }
  }
});

// assets/scripts/framework/common/Pool.ts
var Pool_exports = {};
__export(Pool_exports, {
  Mat4Pool: () => Mat4Pool,
  QuatPool: () => QuatPool,
  V2_DOWN: () => V2_DOWN,
  V2_LEFT: () => V2_LEFT,
  V2_RIGHT: () => V2_RIGHT,
  V2_UP: () => V2_UP,
  V3_BACKWARD: () => V3_BACKWARD,
  V3_DOWN: () => V3_DOWN,
  V3_LEFT: () => V3_LEFT,
  Vec2Pool: () => Vec2Pool,
  Vec3Pool: () => Vec3Pool,
  Vec4Pool: () => Vec4Pool
});
var import_cc8, V3_DOWN, V3_BACKWARD, V3_LEFT, V2_UP, V2_DOWN, V2_RIGHT, V2_LEFT, Pool2, Vec2Pool, Vec3Pool, Vec4Pool, QuatPool, Mat4Pool;
var init_Pool = __esm({
  "assets/scripts/framework/common/Pool.ts"() {
    import_cc8 = require("cc");
    V3_DOWN = Object.freeze(new import_cc8.Vec3(0, -1, 0));
    V3_BACKWARD = Object.freeze(new import_cc8.Vec3(0, 0, 1));
    V3_LEFT = Object.freeze(new import_cc8.Vec3(-1, 0, 0));
    V2_UP = Object.freeze(new import_cc8.Vec2(0, 1));
    V2_DOWN = Object.freeze(new import_cc8.Vec2(0, -1));
    V2_RIGHT = Object.freeze(new import_cc8.Vec2(1, 0));
    V2_LEFT = Object.freeze(new import_cc8.Vec2(-1, 0));
    Pool2 = class {
      constructor(type) {
        this._pool = [];
        this._poolSize = 0;
        this._type = type;
      }
      get(...args) {
        if (this._poolSize > 0) {
          this._poolSize--;
          let val = this._pool.pop();
          val.set(...args);
          return val;
        }
        return new this._type(...args);
      }
      put(v) {
        this._pool.push(v);
        this._poolSize++;
      }
      puts(...vs) {
        for (let i = 0; i < vs.length; i++) {
          this.put(vs[i]);
        }
      }
      clear() {
        this._pool.length = 0;
        this._poolSize = 0;
      }
    };
    Vec2Pool = new Pool2(import_cc8.Vec2);
    Vec3Pool = new Pool2(import_cc8.Vec3);
    Vec4Pool = new Pool2(import_cc8.Vec4);
    QuatPool = new Pool2(import_cc8.Quat);
    Mat4Pool = new Pool2(import_cc8.Mat4);
  }
});

// assets/scripts/framework/common/Pools.ts
var Pools_exports = {};
__export(Pools_exports, {
  CGPathPoint: () => CGPathPoint,
  GComponentPool: () => GComponentPool,
  GPathPointPool: () => GPathPointPool,
  PoolableGComponent: () => PoolableGComponent,
  PoolableNode: () => PoolableNode,
  UINodePool: () => UINodePool
});
var import_cc9, CGPathPoint, GPathPointPool, PoolableGComponent, GComponentPool, PoolableNode, UINodePool;
var init_Pools = __esm({
  "assets/scripts/framework/common/Pools.ts"() {
    import_cc9 = require("cc");
    init_fairygui();
    init_PoolManager();
    init_ResManager();
    CGPathPoint = class extends GPathPoint {
      createFromPool(data) {
      }
      fromPool() {
        this.x = 0;
        this.y = 0;
        this.control1_x = 0;
        this.control1_y = 0;
        this.control2_x = 0;
        this.control2_y = 0;
        this.curveType = 1;
      }
    };
    GPathPointPool = new PoolManager(CGPathPoint);
    PoolableGComponent = class {
      get component() {
        return this._component;
      }
      createFromPool(url) {
        if (!this._component) {
          this._component = UIPackage.createObjectFromURL(url);
        }
        return this._component;
      }
      fromPool() {
        if (this._component) {
          this._component.visible = true;
        }
      }
      toPool() {
        if (this._component) {
          this._component.removeFromParent();
          this._component.visible = false;
        }
      }
    };
    GComponentPool = new PoolManager(PoolableGComponent);
    PoolableNode = class {
      get node() {
        return this._node;
      }
      createFromPool(url) {
        if (!this._node) {
          let prefab = ResManager.getById(url, import_cc9.Prefab);
          this._node = (0, import_cc9.instantiate)(prefab);
        }
        return this._node;
      }
      fromPool() {
        if (this._node) {
          this._node.active = true;
        }
      }
      toPool() {
        if (this._node) {
          this._node.removeFromParent();
          this._node.active = false;
        }
      }
    };
    UINodePool = new PoolManager(PoolableNode);
  }
});

// assets/scripts/framework/common/SoundManager.ts
var SoundManager_exports = {};
__export(SoundManager_exports, {
  SoundManager: () => SoundManager
});
var import_cc10, import_env6, _SoundManager, SoundManager;
var init_SoundManager = __esm({
  "assets/scripts/framework/common/SoundManager.ts"() {
    import_cc10 = require("cc");
    import_env6 = require("cc/env");
    init_fairygui();
    _SoundManager = class _SoundManager {
      constructor() {
        this.audioFinder = null;
        this.musicVolume = 1;
        this.soundVolume = 1;
        this._persistRootNode = new import_cc10.Node("SoundManager");
        import_cc10.game.addPersistRootNode(this._persistRootNode);
        let isPlayAudio = true;
        if (import_env6.JSB) {
          isPlayAudio = import_cc10.native.reflection.callStaticMethod("com/cocos/game/AppActivity", "isPlayAudio", "()Z");
        }
        this.isPlayAudio = isPlayAudio;
      }
      static get instance() {
        if (!this._instance) {
          this._instance = new _SoundManager();
        }
        return this._instance;
      }
      async playAudio(name, loop, source) {
        let clip = await this.audioFinder(name);
        if (!clip) {
          console.error(`\u97F3\u9891\u6587\u4EF6${name}\u4E0D\u5B58\u5728`);
          return;
        }
        source.stop();
        source.volume = loop ? this.musicVolume : this.soundVolume;
        source.clip = clip;
        source.loop = loop;
        if (source.volume > 0) {
          source.play();
        }
      }
      /**
       * 播放音乐
       * @param name 
       * @param loop 
       */
      async playMusic(name, loop = true) {
        this.music = this.music || this._persistRootNode.addComponent(import_cc10.AudioSource);
        await this.playAudio(name, loop, this.music);
      }
      /**
       * 播放音效
       * @param name 
       * @returns 
       */
      async playSound(name) {
        if (!this.soundVolume) {
          return;
        }
        this.sound = this.sound || this._persistRootNode.addComponent(import_cc10.AudioSource);
        await this.playAudio(name, false, this.sound);
      }
      /**
       * 播放音效
       * @param clip 
       * @returns 
       */
      playSoundByClip(clip) {
        if (!this.soundVolume) {
          return;
        }
        this.sound = this.sound || this._persistRootNode.addComponent(import_cc10.AudioSource);
        this.sound.volume = this.soundVolume;
        this.sound.loop = false;
        this.sound.playOneShot(clip);
      }
      setVolume(flag, source) {
        source.volume = flag;
        if (flag > 0) {
          if (source && !source.playing) {
            source.play();
          }
        } else {
          if (source && source.playing) {
            source.stop();
          }
        }
      }
      setMusicVolume(volume) {
        this.musicVolume = volume;
        this.music && this.setVolume(volume, this.music);
      }
      setSoundVolume(volume) {
        this.soundVolume = volume;
      }
    };
    _SoundManager._instance = null;
    SoundManager = _SoundManager;
    GRoot.prototype.playOneShotSound = function(clip, volumeScale) {
      if (SoundManager.instance.soundVolume) {
        SoundManager.instance.playSoundByClip(clip);
      }
    };
  }
});

// assets/scripts/framework/common/StorageManager.ts
var StorageManager_exports = {};
__export(StorageManager_exports, {
  StorageManager: () => StorageManager
});
var import_cc11, Storage, _StorageManager, StorageManager;
var init_StorageManager = __esm({
  "assets/scripts/framework/common/StorageManager.ts"() {
    import_cc11 = require("cc");
    init_EncryptHelper();
    init_EventHandler();
    Storage = class {
      constructor(file) {
        this._file = file;
        this._path = this._getConfigPath();
        this._loadData();
      }
      get file() {
        return this._file;
      }
      /**
       * 获取配置文件路径
       * @returns 获取配置文件路径
       */
      _getConfigPath() {
        let platform = import_cc11.sys.platform;
        let path4 = "";
        if (platform === import_cc11.sys.OS.WINDOWS) {
          path4 = "src/conf";
        } else if (platform === import_cc11.sys.OS.LINUX) {
          path4 = "./conf";
        } else {
          if (import_cc11.sys.isNative) {
            path4 = import_cc11.native.fileUtils.getWritablePath();
            path4 = path4 + "conf";
          } else {
            path4 = "src/conf";
          }
        }
        return `${path4}/${this._file}`;
      }
      _loadData() {
        var content;
        if (import_cc11.sys.isNative) {
          if (import_cc11.native.fileUtils.isFileExist(this._path)) {
            content = import_cc11.native.fileUtils.getStringFromFile(this._path);
          }
        } else {
          content = import_cc11.sys.localStorage.getItem(this._file);
        }
        if (content && content.length) {
          if (content.startsWith("@")) {
            content = content.substring(1);
            content = EncryptHelper.decrypt(content);
          }
          try {
            if (!content || content == "\u0500\0") {
              content = "{}";
            }
            var jsonData = JSON.parse(content);
            this._jsonData = jsonData;
          } catch (excepaiton) {
            console.error(`${this._file}\u89E3\u6790\u5931\u8D25`);
          }
        }
      }
      getData() {
        return this._jsonData;
      }
      getValue(key) {
        return this._jsonData[key];
      }
      setData(data) {
        this._jsonData = data;
      }
      setKV(key, value) {
        this._jsonData[key] = value;
      }
      /**
       * 保存配置文件
       * @returns 
       */
      save(fireEvent = true) {
        if (!StorageManager.enableSave) {
          return false;
        }
        var str = JSON.stringify(this._jsonData) || "";
        let zipStr = "@" + EncryptHelper.encrypt(str);
        if (fireEvent) {
          StorageManager.anyItemSaved.fire(this._file);
        }
        if (!import_cc11.sys.isNative) {
          var ls = import_cc11.sys.localStorage;
          ls.setItem(this._file, zipStr);
          return;
        }
        import_cc11.native.fileUtils.writeStringToFile(this._file, zipStr);
        return true;
      }
    };
    _StorageManager = class _StorageManager {
      constructor() {
        this._saveInterval = 5;
        //s
        this._timer = 0;
        this._dirty = false;
        this._fireEvent = true;
      }
      initial(file, saveInterval = 5) {
        this._saveInterval = saveInterval;
        this._storage = new Storage(file);
      }
      update(dt) {
        this._timer += dt;
        if (this._timer >= this._saveInterval) {
          this._timer = 0;
          if (this._dirty) {
            let saved = this._storage.save();
            if (this._fireEvent) {
              _StorageManager.anyItemSaved.fire(this._storage.file);
            }
            if (saved) {
              this._dirty = false;
              this._fireEvent = true;
            }
          }
        }
      }
      saveNow(fireEvent = true) {
        this._timer = this._saveInterval;
        this._fireEvent = fireEvent;
      }
      getData() {
        return this._storage.getData();
      }
      getValue(key) {
        return this._storage.getValue(key);
      }
      easySave() {
        this._dirty = true;
      }
      setData(data) {
        this._storage.setData(data);
        this._dirty = true;
      }
      setKV(key, value) {
        this._storage.setKV(key, value);
        this._dirty = true;
      }
    };
    _StorageManager.anyItemSaved = new EventHandler();
    _StorageManager.enableSave = true;
    StorageManager = _StorageManager;
  }
});

// assets/scripts/framework/common/TaskManager.ts
var TaskManager_exports = {};
__export(TaskManager_exports, {
  Task: () => Task,
  TaskManager: () => TaskManager
});
var Task, _TaskManager, TaskManager;
var init_TaskManager = __esm({
  "assets/scripts/framework/common/TaskManager.ts"() {
    Task = class {
      constructor(name, weight, runner) {
        this.name = name;
        this.weight = weight;
        this.runner = runner;
      }
    };
    _TaskManager = class _TaskManager {
      constructor(name) {
        this._tasks = [];
        this._totalWeight = 0;
        this.name = "";
        this.name = name || `${++_TaskManager.sID}`;
      }
      add(name, weight, runnder) {
        this._tasks.push(new Task(name, weight, runnder));
        this._totalWeight += weight;
      }
      async runSerial(progress, thisObj) {
        let weight = 0;
        let totalTime = Date.now();
        progress == null ? void 0 : progress.call(thisObj, 0);
        for (let task of this._tasks) {
          const taskResult = await this.runTask(task, weight, progress, thisObj);
          if (!taskResult) {
            return false;
          }
          weight += task.weight;
        }
        console.log(`TM:${this.name} total cost ${Date.now() - totalTime}ms`);
        return true;
      }
      async runParallel(progress, thisObj) {
        let weight = 0;
        let tasks = this._tasks.map((task) => this.runTask(task, weight, progress, thisObj));
        let totalTime = Date.now();
        let results = await Promise.all(tasks);
        console.log(`TM:${this.name} total cost ${Date.now() - totalTime}ms`);
        return results.every((result) => result);
      }
      async runTask(task, weight, progress, thisObj) {
        console.log(`TM:${this.name} begin task ${task.name}`);
        let startTime = Date.now();
        let result = await task.runner(task, (p) => {
          let w = weight + task.weight * p;
          let pp2 = w / this._totalWeight;
          progress == null ? void 0 : progress.call(thisObj, pp2);
        });
        console.log(`TM:${this.name} task ${task.name} done, cost ${Date.now() - startTime}ms`);
        let pp = weight / this._totalWeight;
        progress == null ? void 0 : progress.call(thisObj, pp);
        return result;
      }
    };
    _TaskManager.sID = 0;
    TaskManager = _TaskManager;
  }
});

// assets/scripts/framework/common/TimeWatcher.ts
var TimeWatcher_exports = {};
__export(TimeWatcher_exports, {
  TimeWatcher: () => TimeWatcher
});
var TimeWatcher;
var init_TimeWatcher = __esm({
  "assets/scripts/framework/common/TimeWatcher.ts"() {
    TimeWatcher = class {
      constructor() {
        this._startTime = 0;
        this._endTime = 0;
        this._isRunning = false;
      }
      start() {
        this._startTime = Date.now();
        this._isRunning = true;
      }
      stop() {
        this._endTime = Date.now();
        this._isRunning = false;
      }
      getElapsedTime() {
        return this._endTime - this._startTime;
      }
      getElapsedTimeNow() {
        return Date.now() - this._startTime;
      }
      isRunning() {
        return this._isRunning;
      }
      printElapsedTime(pattern) {
        console.log(pattern.replace("%s", this.getElapsedTimeNow().toString()));
      }
    };
  }
});

// assets/scripts/framework/libs/md5.ts
var md5_exports = {};
__export(md5_exports, {
  Md5: () => Md5
});
var _Md5, Md5;
var init_md5 = __esm({
  "assets/scripts/framework/libs/md5.ts"() {
    _Md5 = class _Md5 {
      constructor() {
        this._state = new Int32Array(4);
        this._buffer = new ArrayBuffer(68);
        this._buffer8 = new Uint8Array(this._buffer, 0, 68);
        this._buffer32 = new Uint32Array(this._buffer, 0, 17);
        this.start();
      }
      static hashStr(str, raw = false) {
        return this.onePassHasher.start().appendStr(str).end(raw);
      }
      static hashAsciiStr(str, raw = false) {
        return this.onePassHasher.start().appendAsciiStr(str).end(raw);
      }
      static _hex(x) {
        const hc = _Md5.hexChars;
        const ho = _Md5.hexOut;
        let n;
        let offset;
        let j;
        let i;
        for (i = 0; i < 4; i += 1) {
          offset = i * 8;
          n = x[i];
          for (j = 0; j < 8; j += 2) {
            ho[offset + 1 + j] = hc.charAt(n & 15);
            n >>>= 4;
            ho[offset + 0 + j] = hc.charAt(n & 15);
            n >>>= 4;
          }
        }
        return ho.join("");
      }
      static _md5cycle(x, k) {
        let a = x[0];
        let b = x[1];
        let c = x[2];
        let d = x[3];
        a += (b & c | ~b & d) + k[0] - 680876936 | 0;
        a = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[1] - 389564586 | 0;
        d = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[2] + 606105819 | 0;
        c = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;
        b = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[4] - 176418897 | 0;
        a = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;
        d = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;
        c = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[7] - 45705983 | 0;
        b = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;
        a = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;
        d = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[10] - 42063 | 0;
        c = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;
        b = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;
        a = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[13] - 40341101 | 0;
        d = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;
        c = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;
        b = (b << 22 | b >>> 10) + c | 0;
        a += (b & d | c & ~d) + k[1] - 165796510 | 0;
        a = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;
        d = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[11] + 643717713 | 0;
        c = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[0] - 373897302 | 0;
        b = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[5] - 701558691 | 0;
        a = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[10] + 38016083 | 0;
        d = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[15] - 660478335 | 0;
        c = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[4] - 405537848 | 0;
        b = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[9] + 568446438 | 0;
        a = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;
        d = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[3] - 187363961 | 0;
        c = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;
        b = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;
        a = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[2] - 51403784 | 0;
        d = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;
        c = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;
        b = (b << 20 | b >>> 12) + c | 0;
        a += (b ^ c ^ d) + k[5] - 378558 | 0;
        a = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;
        d = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;
        c = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[14] - 35309556 | 0;
        b = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;
        a = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;
        d = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[7] - 155497632 | 0;
        c = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;
        b = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[13] + 681279174 | 0;
        a = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[0] - 358537222 | 0;
        d = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[3] - 722521979 | 0;
        c = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[6] + 76029189 | 0;
        b = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[9] - 640364487 | 0;
        a = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[12] - 421815835 | 0;
        d = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[15] + 530742520 | 0;
        c = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[2] - 995338651 | 0;
        b = (b << 23 | b >>> 9) + c | 0;
        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;
        a = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;
        d = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;
        c = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;
        b = (b << 21 | b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;
        a = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;
        d = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;
        c = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;
        b = (b << 21 | b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;
        a = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;
        d = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;
        c = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;
        b = (b << 21 | b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;
        a = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;
        d = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;
        c = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;
        b = (b << 21 | b >>> 11) + c | 0;
        x[0] = a + x[0] | 0;
        x[1] = b + x[1] | 0;
        x[2] = c + x[2] | 0;
        x[3] = d + x[3] | 0;
      }
      start() {
        this._dataLength = 0;
        this._bufferLength = 0;
        this._state.set(_Md5.stateIdentity);
        return this;
      }
      // Char to code point to to array conversion:
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt
      // #Example.3A_Fixing_charCodeAt_to_handle_non-Basic-Multilingual-Plane_characters_if_their_presence_earlier_in_the_string_is_unknown
      appendStr(str) {
        const buf8 = this._buffer8;
        const buf32 = this._buffer32;
        let bufLen = this._bufferLength;
        let code;
        let i;
        for (i = 0; i < str.length; i += 1) {
          code = str.charCodeAt(i);
          if (code < 128) {
            buf8[bufLen++] = code;
          } else if (code < 2048) {
            buf8[bufLen++] = (code >>> 6) + 192;
            buf8[bufLen++] = code & 63 | 128;
          } else if (code < 55296 || code > 56319) {
            buf8[bufLen++] = (code >>> 12) + 224;
            buf8[bufLen++] = code >>> 6 & 63 | 128;
            buf8[bufLen++] = code & 63 | 128;
          } else {
            code = (code - 55296) * 1024 + (str.charCodeAt(++i) - 56320) + 65536;
            if (code > 1114111) {
              throw new Error("Unicode standard supports code points up to U+10FFFF");
            }
            buf8[bufLen++] = (code >>> 18) + 240;
            buf8[bufLen++] = code >>> 12 & 63 | 128;
            buf8[bufLen++] = code >>> 6 & 63 | 128;
            buf8[bufLen++] = code & 63 | 128;
          }
          if (bufLen >= 64) {
            this._dataLength += 64;
            _Md5._md5cycle(this._state, buf32);
            bufLen -= 64;
            buf32[0] = buf32[16];
          }
        }
        this._bufferLength = bufLen;
        return this;
      }
      appendAsciiStr(str) {
        const buf8 = this._buffer8;
        const buf32 = this._buffer32;
        let bufLen = this._bufferLength;
        let i;
        let j = 0;
        for (; ; ) {
          i = Math.min(str.length - j, 64 - bufLen);
          while (i--) {
            buf8[bufLen++] = str.charCodeAt(j++);
          }
          if (bufLen < 64) {
            break;
          }
          this._dataLength += 64;
          _Md5._md5cycle(this._state, buf32);
          bufLen = 0;
        }
        this._bufferLength = bufLen;
        return this;
      }
      appendByteArray(input) {
        const buf8 = this._buffer8;
        const buf32 = this._buffer32;
        let bufLen = this._bufferLength;
        let i;
        let j = 0;
        for (; ; ) {
          i = Math.min(input.length - j, 64 - bufLen);
          while (i--) {
            buf8[bufLen++] = input[j++];
          }
          if (bufLen < 64) {
            break;
          }
          this._dataLength += 64;
          _Md5._md5cycle(this._state, buf32);
          bufLen = 0;
        }
        this._bufferLength = bufLen;
        return this;
      }
      getState() {
        const self2 = this;
        const s = self2._state;
        return {
          buffer: String.fromCharCode.apply(null, self2._buffer8),
          buflen: self2._bufferLength,
          length: self2._dataLength,
          state: [s[0], s[1], s[2], s[3]]
        };
      }
      setState(state) {
        const buf = state.buffer;
        const x = state.state;
        const s = this._state;
        let i;
        this._dataLength = state.length;
        this._bufferLength = state.buflen;
        s[0] = x[0];
        s[1] = x[1];
        s[2] = x[2];
        s[3] = x[3];
        for (i = 0; i < buf.length; i += 1) {
          this._buffer8[i] = buf.charCodeAt(i);
        }
      }
      end(raw = false) {
        const bufLen = this._bufferLength;
        const buf8 = this._buffer8;
        const buf32 = this._buffer32;
        const i = (bufLen >> 2) + 1;
        let dataBitsLen;
        this._dataLength += bufLen;
        buf8[bufLen] = 128;
        buf8[bufLen + 1] = buf8[bufLen + 2] = buf8[bufLen + 3] = 0;
        buf32.set(_Md5.buffer32Identity.subarray(i), i);
        if (bufLen > 55) {
          _Md5._md5cycle(this._state, buf32);
          buf32.set(_Md5.buffer32Identity);
        }
        dataBitsLen = this._dataLength * 8;
        if (dataBitsLen <= 4294967295) {
          buf32[14] = dataBitsLen;
        } else {
          const matches = dataBitsLen.toString(16).match(/(.*?)(.{0,8})$/);
          if (matches === null) {
            return;
          }
          const lo = parseInt(matches[2], 16);
          const hi = parseInt(matches[1], 16) || 0;
          buf32[14] = lo;
          buf32[15] = hi;
        }
        _Md5._md5cycle(this._state, buf32);
        return raw ? this._state : _Md5._hex(this._state);
      }
    };
    // Private Static Variables
    _Md5.stateIdentity = new Int32Array([1732584193, -271733879, -1732584194, 271733878]);
    _Md5.buffer32Identity = new Int32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    _Md5.hexChars = "0123456789abcdef";
    _Md5.hexOut = [];
    // Permanent instance is to use for one-call hashing
    _Md5.onePassHasher = new _Md5();
    Md5 = _Md5;
    if (Md5.hashStr("hello") !== "5d41402abc4b2a76b9719d911017c592") {
      console.error("Md5 self test failed.");
    }
  }
});

// assets/scripts/framework/macro.ts
var macro_exports = {};
__export(macro_exports, {
  ALIPAY: () => ALIPAY,
  MEITUAN: () => MEITUAN,
  PIAP: () => PIAP,
  WECHAT: () => WECHAT
});
var WECHAT, MEITUAN, PIAP, ALIPAY;
var init_macro = __esm({
  "assets/scripts/framework/macro.ts"() {
    WECHAT = false;
    MEITUAN = false;
    PIAP = false;
    ALIPAY = false;
  }
});

// assets/scripts/framework/modules/Bridge.ts
var Bridge_exports = {};
__export(Bridge_exports, {
  Bridge: () => Bridge
});
var Bridge;
var init_Bridge = __esm({
  "assets/scripts/framework/modules/Bridge.ts"() {
    Bridge = class {
    };
  }
});

// assets/scripts/framework/modules/base/BaseController.ts
var BaseController_exports = {};
__export(BaseController_exports, {
  BaseController: () => BaseController
});
var BaseController;
var init_BaseController = __esm({
  "assets/scripts/framework/modules/base/BaseController.ts"() {
    init_EventCenter();
    BaseController = class {
      constructor() {
        this._eventCenter = new EventCenter();
      }
      get eventCenter() {
        return this._eventCenter;
      }
      get dataKey() {
        return "";
      }
      processDaos(processor) {
        if (this.daos) {
          this.daos.forEach(processor);
        } else if (this.dao) {
          processor(this.dao);
        }
      }
      processDaosAndReturn(processor) {
        if (this.daos) {
          return this.daos.some(processor);
        } else if (this.dao) {
          return processor(this.dao);
        }
        return false;
      }
      /**
       * 存档至服务器后，清除数据变化标记
       */
      clearServerDirty() {
        this.processDaos((dao) => dao.serverDirty = false);
      }
      /**
       * 获取数据是否有变化
       */
      get serverDirty() {
        return this.processDaosAndReturn((dao) => dao.serverDirty);
      }
      /**
       * 本地数据验证是否成功
       */
      get isValidate() {
        return !this.processDaosAndReturn((dao) => !dao.isValidate);
      }
      set isValidate(val) {
        this.processDaos((dao) => dao.isValidate = val);
      }
      /**
       * 主要数据接口,不为空时将会初始化加载数据，update存储数据
       */
      get dao() {
        return null;
      }
      get daos() {
        return null;
      }
      on(eventName, handler, target) {
        this._eventCenter.on(eventName, handler, target);
      }
      once(eventName, handler, target) {
        this._eventCenter.once(eventName, handler, target);
      }
      off(eventName, handler, target) {
        this._eventCenter.off(eventName, handler, target);
      }
      emit(eventName, ...args) {
        this._eventCenter.emit(eventName, ...args);
      }
      globalEmit(eventName, ...args) {
        EventCenter.I.emit(eventName, ...args);
      }
      update(dt) {
        if (this.dao) {
          this.dao.save();
          this.dao.update(dt);
        }
        this.onUpdate(dt);
      }
      /**
       * 每帧刷新
       * @param dt 时间间隔(s) 
       */
      onUpdate(dt) {
      }
      load() {
        if (this.daos) {
          for (let i = 0; i < this.daos.length; i++) {
            let dao = this.daos[i];
            dao.load();
          }
        } else if (this.dao) {
          this.dao.load();
        }
      }
      initial() {
        if (this.daos) {
          for (let i = 0; i < this.daos.length; i++) {
            let dao = this.daos[i];
            dao.initial();
          }
        } else if (this.dao) {
          this.dao.initial();
        }
        this.onInitial();
      }
      onInitial() {
      }
      save(focus, now) {
        var _a;
        if (this.daos) {
          for (let i = 0; i < this.daos.length; i++) {
            let dao = this.daos[i];
            dao.save(focus, now);
          }
        } else if (this.dao) {
          (_a = this.dao) == null ? void 0 : _a.save(focus, now);
        }
      }
      reset() {
        if (this.daos) {
          for (let i = 0; i < this.daos.length; i++) {
            let dao = this.daos[i];
            dao.reset();
          }
        } else if (this.dao) {
          this.dao.reset();
        }
      }
      getModelData(holder, serialize) {
        if (!this.dataKey) {
          return;
        }
        if (this.daos) {
          let arr = holder[this.dataKey] = [];
          for (let i = 0; i < this.daos.length; i++) {
            if (serialize) {
              arr.push(this.daos[i].serialize());
            } else {
              arr.push(this.daos[i].model);
            }
          }
        } else if (this.dao) {
          if (serialize) {
            holder[this.dataKey] = this.dao.serialize();
          } else {
            holder[this.dataKey] = this.dao.model;
          }
        }
      }
      setModelData(holder, replace, deserialize) {
        if (!this.dataKey) {
          return;
        }
        if (this.daos) {
          let arr = holder[this.dataKey];
          for (let i = 0; i < this.daos.length; i++) {
            if (deserialize) {
              this.daos[i].deserialize(arr[i], replace);
            } else {
              this.daos[i].setData(arr[i], replace);
            }
          }
        } else {
          if (deserialize) {
            this.dao.deserialize(holder[this.dataKey], replace);
          } else {
            this.dao.setData(holder[this.dataKey], replace);
          }
        }
      }
    };
  }
});

// assets/scripts/framework/modules/base/BaseModel.ts
var BaseModel_exports = {};
__export(BaseModel_exports, {
  BaseModel: () => BaseModel
});
var BaseModel;
var init_BaseModel = __esm({
  "assets/scripts/framework/modules/base/BaseModel.ts"() {
    BaseModel = class {
    };
  }
});

// assets/scripts/framework/modules/base/SecretModel.ts
var SecretModel_exports = {};
__export(SecretModel_exports, {
  SecretModel: () => SecretModel
});
var SecretModel;
var init_SecretModel = __esm({
  "assets/scripts/framework/modules/base/SecretModel.ts"() {
    init_BaseModel();
    SecretModel = class extends BaseModel {
    };
  }
});

// assets/scripts/framework/modules/ModelMapper.ts
var ModelMapper_exports = {};
__export(ModelMapper_exports, {
  ModelMapper: () => ModelMapper
});
var ModelMapperInfo, ModelMapper;
var init_ModelMapper = __esm({
  "assets/scripts/framework/modules/ModelMapper.ts"() {
    ModelMapperInfo = null;
    ModelMapper = class {
      static toData(data, type) {
        if (!this.modelMapperInfo) {
          return data;
        }
        if (Array.isArray(data)) {
          let array = [];
          for (let i = 0; i < data.length; i++) {
            let item = this.toData(data[i], type);
            array.push(item);
          }
          return array;
        } else if (typeof data != "object") {
          return data;
        }
        let info = this.modelMapperInfo[type];
        if (info) {
          if (info.arrArrayFields) {
            if (data) {
              let keys2 = info.arrArrayFields;
              let array = [];
              for (let key of keys2) {
                let item = this.toData(data[key], type);
                array.push(item);
              }
              return array;
            } else {
              return null;
            }
          }
          let model = new info.type();
          let keys = Object.keys(model);
          for (let key of keys) {
            if (info.fields) {
              let field = info.fields[key];
              if (field) {
                if (field.mapper) {
                  model[field.alias || key] = this.toData(data[key], field.mapper);
                } else {
                  if (field.type == Boolean) {
                    model[field.alias || key] = data[key] ? 1 : 0;
                  } else {
                    model[field.alias || key] = data[key];
                  }
                }
              } else {
                model[key] = data[key];
              }
            } else {
              model[key] = data[key];
            }
          }
          return model;
        } else {
          return data;
        }
      }
      static fromData(data, type, toObject = false) {
        if (!this.modelMapperInfo) {
          return data;
        }
        let info = this.modelMapperInfo[type];
        if (Array.isArray(data) && !toObject) {
          let array = [];
          for (let i = 0; i < data.length; i++) {
            let item = this.fromData(data[i], type, true);
            array.push(item);
          }
          return array;
        } else if (typeof data != "object") {
          return data;
        }
        if (info) {
          if (info.arrArrayFields) {
            if (data) {
              let keys2 = Object.keys(data);
              let obj = new info.type();
              for (let key of keys2) {
                let field = info.arrArrayFields[key];
                obj[field] = this.fromData(data[key], type);
              }
              return obj;
            } else {
              return null;
            }
          }
          let model = {};
          let keys = Object.keys(data);
          for (let key of keys) {
            if (info.fields) {
              let field = info.fields[key];
              if (field) {
                if (field.mapper) {
                  model[key] = this.fromData(data[field.alias || key], field.mapper);
                } else {
                  if (field.type == Boolean) {
                    model[key] = data[field.alias || key] ? 1 : 0;
                  } else {
                    model[key] = data[field.alias || key];
                  }
                }
              } else {
                model[key] = data[key];
              }
            } else {
              model[key] = data[key];
            }
          }
          return model;
        } else {
          return data;
        }
      }
    };
    ModelMapper.modelMapperInfo = ModelMapperInfo;
  }
});

// assets/scripts/framework/utils/StringUtils.ts
var StringUtils_exports = {};
__export(StringUtils_exports, {
  StringUtils: () => StringUtils
});
var StringUtils;
var init_StringUtils = __esm({
  "assets/scripts/framework/utils/StringUtils.ts"() {
    StringUtils = class {
      /**
       * 获取字符长度
       * @param str 
       * @returns 
       */
      static strlen(str) {
        var len = 0;
        for (var i = 0; i < str.length; i++) {
          var c = str.charCodeAt(i);
          if (c >= 1 && c <= 126 || 65376 <= c && c <= 65439) {
            len++;
          } else {
            len += 2;
          }
        }
        return len;
      }
      /**
       * 字符串超过n个字符转换成...
       * @param str 
       * @param cropping 
       */
      static strConvert(str, cropping) {
        var len = 0;
        let index = -1;
        if (str.length < cropping) {
          return str;
        }
        for (var i = 0; i < str.length; i++) {
          var c = str.charCodeAt(i);
          if (c >= 1 && c <= 126 || 65376 <= c && c <= 65439) {
            len++;
          } else {
            len += 2;
          }
          if (len > cropping * 2) {
            index = i;
            break;
          }
        }
        if (index > -1) {
          return str.substring(0, index) + "...";
        }
        return str;
      }
      static compareVersion(ver1, ver2) {
        const v1 = ver1.split(".");
        const v24 = ver2.split(".");
        const len = Math.max(v1.length, v24.length);
        while (v1.length < len) {
          v1.push("0");
        }
        while (v24.length < len) {
          v24.push("0");
        }
        for (let i = 0; i < len; i++) {
          const n1 = parseInt(v1[i]);
          const n2 = parseInt(v24[i]);
          if (n1 != n2) {
            return n1 > n2 ? 1 : -1;
          }
        }
        return 0;
      }
      static format(source, ...params) {
        if (!source) {
          return source;
        }
        params.forEach((val, idx) => {
          source = source.replace(new RegExp("\\{" + idx + "\\}", "g"), val == null ? void 0 : val.toString());
        });
        return source;
      }
      static splitResPath(path4, defaultPkg) {
        let res = path4;
        let pkg = defaultPkg;
        if (path4.startsWith("db://")) {
          path4 = path4.substring(5);
          let idx = path4.indexOf("/");
          pkg = path4.substring(0, idx);
          res = path4.substring(idx + 1);
        }
        return { pkg, res };
      }
      static randomFuncName(len) {
        var str = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
        var s = "";
        var random = function() {
          var rand = Math.floor(Math.random() * str.length);
          return str.charAt(rand);
        };
        s += random();
        str += "0123456789";
        for (var i = 0; i < len - 1; i++) {
          s += random();
        }
        return s;
      }
      static randomString(len) {
        len = len || 32;
        var $chars = "ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678";
        var maxPos = $chars.length;
        var pwd = "";
        for (let i = 0; i < len; i++) {
          pwd += $chars.charAt(Math.floor(Math.random() * maxPos));
        }
        return pwd;
      }
      static stringToColor(color) {
        let r = parseInt(color.substr(1, 2), 16);
        let g = parseInt(color.substr(3, 2), 16);
        let b = parseInt(color.substr(5, 2), 16);
        return [r, g, b];
      }
    };
  }
});

// assets/scripts/framework/modules/base/BaseDAO.ts
var BaseDAO_exports = {};
__export(BaseDAO_exports, {
  BaseDAO: () => BaseDAO
});
var BaseDAO;
var init_BaseDAO = __esm({
  "assets/scripts/framework/modules/base/BaseDAO.ts"() {
    init_UtilsHelper();
    init_StorageManager();
    init_Bridge();
    init_ModelMapper();
    init_GameSettings();
    init_StringUtils();
    BaseDAO = class {
      constructor(model) {
        this.serverDirty = false;
        this._isNewer = false;
        this._realStorageKey = "";
        this.isValidate = true;
        this._needValidKeys = {};
        this._dirty = false;
        this._type = model;
      }
      get readStorageKey() {
        return this._realStorageKey;
      }
      get storage() {
        return this._storage;
      }
      /**
       * 模块名称，用于通过ModelMapper获取配置数据
       */
      get modelName() {
        return "";
      }
      /**
       * 本地存储的key，为空表示不存储
       */
      get storageKey() {
        return null;
      }
      /**
       * md5验证存储的key，为空表示不校验
       */
      get storageValidKey() {
        return null;
      }
      get dirty() {
        return this._dirty;
      }
      set dirty(value) {
        this._dirty = value;
      }
      get model() {
        return this._model;
      }
      update(dt) {
        if (this.storage) {
          this.storage.update(dt);
        }
      }
      load() {
        if (this.storageKey) {
          this._storage = new StorageManager();
          this._realStorageKey = `${GameSettings.useid || 0}:${this.storageKey}`;
          this._storage.initial(this._realStorageKey);
        }
        this.beforeLoad();
        this.loadData();
        this.afterLoad();
      }
      initial() {
        this.beforeInitial();
        this.refreshValidKeys();
      }
      beforeLoad() {
      }
      afterLoad() {
      }
      beforeInitial() {
      }
      setValidKey(...keys) {
        for (let i = 0; i < keys.length; i++) {
          let key = keys[i];
          if (!key) {
            continue;
          }
          let token = StringUtils.randomString(6);
          this._needValidKeys[key] = {
            token,
            md5: Bridge.secertCtrl.getMd5(this.model[key], token)
          };
        }
      }
      refreshValidKeys() {
        let keys = Object.keys(this._needValidKeys);
        this.setValidKey(...keys);
      }
      checkAndUpdateValue(field, value) {
        let item = this._needValidKeys[field];
        if (item) {
          let ret = item.md5 == Bridge.secertCtrl.getMd5(this.model[field], item.token);
          if (ret) {
            this.model[field] = value;
            item.md5 = Bridge.secertCtrl.getMd5(value, item.token);
            this.easySave();
          } else {
            console.error(`key=${field}\uFF0C \u6570\u636E\u9A8C\u8BC1\u5931\u8D25`);
          }
          return ret;
        } else {
          console.error(`\u672A\u6CE8\u518C\u76F8\u5173key\uFF1A${field}`);
        }
        return false;
      }
      loadData() {
        if (this.storageKey) {
          this._model = this._storage.getData();
          this.validateAndCreateModel();
        }
      }
      /**
       * 直接覆盖数据，此数据无需验证
       * @param data 
       */
      setData(data, replace = false) {
        UtilsHelper.copyTo(data, this._model);
        if (this.storageValidKey) {
          Bridge.secertCtrl.setValidKey(this._model, this.storageValidKey);
        }
        if (replace) {
          this._isNewer = false;
        }
        if (this.storage) {
          this.storage.setData(this._model);
        }
        this.easySave();
      }
      copyData(source, target, keys) {
        for (let i = 0; i < keys.length; i++) {
          let key = keys[i];
          if (source[key]) {
            target[key] = source[key];
          }
        }
      }
      validateAndCreateModel() {
        if (this._model && this.storageValidKey) {
          if (!Bridge.secertCtrl.checkValue(this._model, this.storageValidKey)) {
            this._model = null;
            Bridge.secertCtrl.removeKey(this.storageValidKey);
            console.error("merge_storage_error", { from: this.storageKey });
            this.isValidate = false;
          } else {
            this.isValidate = true;
          }
        } else {
          this.isValidate = true;
        }
        let isNewer = false;
        if (!this._model) {
          this._model = new this._type();
          isNewer = true;
        } else {
          let model = this._model;
          this._model = new this._type();
          UtilsHelper.copyTo(model, this._model);
        }
        this.setData(this._model, true);
        this._isNewer = isNewer;
      }
      saveData(focus, now = false, fireEvent = true) {
        if (this.dirty || focus) {
          if (this.storageValidKey) {
            Bridge.secertCtrl.setValidKey(this._model, this.storageValidKey);
          }
          this._storage.setData(this._model);
          if (now) {
            this._storage.saveNow(fireEvent);
          }
        }
      }
      copyFrom(data, keys) {
        this._owner = data;
        this._keys = keys;
        keys = keys || Object.keys(this._model);
        this.copyData(data, this._model, keys);
      }
      saveTo(data, keys) {
        keys = keys || Object.keys(this._model);
        this.copyData(this._model, data, keys);
      }
      reset() {
        this._model = new this._type();
        this.saveNow(false);
      }
      easySave() {
        this.dirty = true;
        this.serverDirty = true;
      }
      saveNow(fireEvent = true) {
        this.save(true, true, fireEvent);
      }
      save(focus, now = false, fireEvent = true) {
        if (this.storageKey) {
          this.saveData(focus, now, fireEvent);
        } else if (this._owner) {
          this.saveTo(this._owner, this._keys);
        }
        this.dirty = false;
      }
      serialize() {
        if (this.modelName) {
          let data = ModelMapper.toData(this.model, this.modelName);
          delete data["_md5_"];
          delete data["_token_"];
          return data;
        }
        return this.model;
      }
      deserialize(data, replace) {
        if (this.modelName) {
          let model = ModelMapper.fromData(data, this.modelName);
          this.setData(model, replace);
        } else {
          this.setData(data, replace);
        }
      }
    };
  }
});

// assets/scripts/framework/modules/base/SecretDAO.ts
var SecretDAO_exports = {};
__export(SecretDAO_exports, {
  secretDAO: () => secretDAO
});
var SecretDAO, secretDAO;
var init_SecretDAO = __esm({
  "assets/scripts/framework/modules/base/SecretDAO.ts"() {
    init_SecretModel();
    init_BaseDAO();
    init_StorageManager();
    init_Bridge();
    SecretDAO = class extends BaseDAO {
      constructor(model) {
        super(model);
        this._innerSave = false;
        StorageManager.anyItemSaved.add(this._onAnyItemSaved, this);
      }
      get storageKey() {
        return "secret";
      }
      _onAnyItemSaved(storageKey) {
        if (!this._innerSave) {
          this._innerSave = true;
          Bridge.secertCtrl.fireOnItemSaved(storageKey);
          this.saveNow();
          this._innerSave = false;
        }
      }
      removeSecret(key) {
        delete this.model[key];
        this.easySave();
      }
      getSecret(key) {
        return this.model[key];
      }
      setSecret(key, token, md5) {
        this.model[key] = {
          token,
          md5
        };
        this.easySave();
      }
      beforeInitial() {
      }
    };
    secretDAO = new SecretDAO(SecretModel);
  }
});

// assets/scripts/framework/modules/base/SecretController.ts
var SecretController_exports = {};
__export(SecretController_exports, {
  SecretController: () => SecretController,
  secretController: () => secretController
});
var _SecretController, SecretController, secretController;
var init_SecretController = __esm({
  "assets/scripts/framework/modules/base/SecretController.ts"() {
    init_UtilsHelper();
    init_md5();
    init_Bridge();
    init_BaseController();
    init_SecretDAO();
    init_StringUtils();
    _SecretController = class _SecretController extends BaseController {
      get dao() {
        return secretDAO;
      }
      getMd5(data, token) {
        if (typeof data == "object") {
          return Md5.hashStr(JSON.stringify(data) + "|" + token);
        }
        return `${data.toString()}|${token}`;
      }
      getTarget(target, field) {
        if (field) {
          return target[field];
        }
        let obj = {};
        UtilsHelper.copyTo(target, obj);
        delete obj["_token_"];
        delete obj["_md5_"];
        return obj;
      }
      removeKey(key) {
        secretDAO.removeSecret(key);
      }
      setValidKey(target, key, ...fields) {
        fields = !fields || fields.length == 0 ? [null] : fields;
        for (let i = 0; i < fields.length; i++) {
          let field = fields[i];
          let token = StringUtils.randomString(6);
          let obj = this.getTarget(target, field);
          let md5 = this.getMd5(obj, token);
          if (field == null) {
            target["_token_"] = token;
            target["_md5_"] = md5;
          }
          secretDAO.setSecret(key, token, md5);
        }
      }
      checkValue(target, key, field) {
        let item = secretDAO.getSecret(key);
        if (item) {
          let obj = this.getTarget(target, field);
          if (field == null) {
            if (target["_md5_"] == this.getMd5(obj, target["_token_"])) {
              return true;
            }
          }
          let ret = item.md5 == this.getMd5(obj, item.token);
          if (!ret) {
            console.error(`key=${key}\uFF0C \u6570\u636E\u9A8C\u8BC1\u5931\u8D25`);
          }
          return ret;
        } else {
          console.error(`\u672A\u6CE8\u518C\u76F8\u5173key\uFF1A${key}`);
        }
        return false;
      }
      checkAndUpdateValue(target, key, field, value) {
        let ret = this.checkValue(target, key, field);
        if (ret) {
          target[field] = value;
          this.setValidKey(target, key, field);
        }
        return ret;
      }
      fireOnItemSaved(storageKey) {
        Bridge.secertCtrl.emit(_SecretController.SECRET_DAO_ON_SAVED, storageKey);
      }
    };
    _SecretController.SECRET_DAO_ON_SAVED = "SECRET_DAO_ON_SAVED";
    SecretController = _SecretController;
    secretController = new SecretController();
    Bridge.secertCtrl = secretController;
  }
});

// assets/scripts/framework/modules/system/SystemController.ts
var SystemController_exports = {};
__export(SystemController_exports, {
  systemController: () => systemController
});
var _SystemController, SystemController, systemController;
var init_SystemController = __esm({
  "assets/scripts/framework/modules/system/SystemController.ts"() {
    init_EventCenter();
    init_BaseController();
    _SystemController = class _SystemController extends BaseController {
      constructor() {
        super(...arguments);
        this._nextDayZeroTime = 0;
        // 服务器毫秒时间
        this._serverTime = Date.now();
        // 上一次设置服务器时间后的运行时间
        this._timeTicker = 0;
        this._checkH = 0;
      }
      /**
       * 设置服务器时间(秒/毫秒)
       * @param servertime 
       */
      setTime(servertime) {
        if (servertime < 1e10) {
          servertime *= 1e3;
        }
        this._serverTime = servertime;
        this._timeTicker = 0;
      }
      onInitial() {
        this._checkH = this.getH();
        setInterval(() => {
          this._timeTicker += 1e3;
        }, 1e3);
      }
      /**
       * 获取当前时间戳(毫秒)，与服务器时间同步
       * @returns {number} 毫秒
       */
      getTimeMS() {
        return Math.floor(this._serverTime + this._timeTicker);
      }
      /**
       * 获取当前时间戳(秒)，与服务器时间同步
       * @returns {number} 秒
       */
      getTime() {
        return Math.floor((this._serverTime + this._timeTicker) * 1e-3);
      }
      /**
       * 获取当前是本年第几周
       * @returns 
       */
      getWeek() {
        let date = this.getTime();
        let query_date = new Date(date * 1e3 + 1);
        const fist_day_of_year = new Date(query_date.getFullYear(), 0, 1);
        let week = fist_day_of_year.getDay();
        const ms_count = query_date.getTime() - fist_day_of_year.getTime();
        let days_count = Math.ceil(ms_count / 864e5);
        days_count += week - 1;
        return Math.ceil(days_count / 7);
      }
      // 当前周几 1-7
      getWeekDay() {
        const day = this.getServerDate().getDay();
        return day == 0 ? 7 : day;
      }
      getServerDate() {
        return new Date(this.getTimeMS());
      }
      getH() {
        let t = this.getTimeMS();
        let h = new Date(t).getHours();
        return h;
      }
      /**
       * 获取任意一天,任意时间点
       * @param day 天
       * @param hour 小时
       * @returns ms
       */
      getDayTime(day = 0, hour = 0) {
        return new Date(new Date(this.getServerDate()).setDate(new Date(this.getServerDate()).getDate() + day)).setHours(hour, 0, 0, 0);
      }
      // 判断是否跨天
      _checkCrossDay() {
        if (this._nextDayZeroTime == 0) {
          this._nextDayZeroTime = this.getDayTime(1);
        }
        if (this.getTimeMS() >= this._nextDayZeroTime) {
          console.log("\u8DE8\u5929\u4E86", this.getTimeMS(), this._nextDayZeroTime, this.getTimeMS() - this._nextDayZeroTime, this.getDayTime(1), this.getTimeMS() - this.getDayTime(1));
          EventCenter.I.emit(_SystemController.SYSTEM_CROSS_DAY);
          this._nextDayZeroTime = this.getDayTime(1);
        }
      }
      // 整点报时
      _checkHouse() {
        let h = this.getH();
        if (this._checkH != h) {
          this._checkH = h;
          EventCenter.I.emit(_SystemController.SYSTEM_CROSS_HOUR);
        }
      }
      onUpdate(dt) {
        this._checkCrossDay();
        this._checkHouse();
      }
    };
    _SystemController.SYSTEM_CROSS_DAY = "SYSTEM_CROSS_DAY";
    _SystemController.SYSTEM_CROSS_HOUR = "SYSTEM_CROSS_HOUR";
    SystemController = _SystemController;
    systemController = new SystemController();
  }
});

// assets/scripts/framework/modules/ControllerManager.ts
var ControllerManager_exports = {};
__export(ControllerManager_exports, {
  ControllerManager: () => ControllerManager
});
var import_cc12, import_env7, ControllerManager;
var init_ControllerManager = __esm({
  "assets/scripts/framework/modules/ControllerManager.ts"() {
    import_cc12 = require("cc");
    import_env7 = require("cc/env");
    init_StorageManager();
    init_SecretController();
    init_SystemController();
    init_PlatformSDK();
    init_GameSettings();
    ControllerManager = class {
      static get controls() {
        return this._ctrls;
      }
      static getController(key) {
        return this._controllerMap[key];
      }
      static get controllerMap() {
        return this._controllerMap;
      }
      static regist() {
        this._ctrls.push(secretController);
        this._ctrls.push(systemController);
        this.onRegistControllers();
        for (let i = 0; i < this._ctrls.length; i++) {
          let ctrl = this._ctrls[i];
          ctrl.load();
          if (ctrl.dataKey) {
            this._controllerMap[ctrl.dataKey] = this._ctrls[i];
          } else {
            console.info("controller dataKey is null", ctrl);
          }
        }
      }
      static registController(ctrl) {
        this._ctrls.push(ctrl);
      }
      static onRegistControllers() {
      }
      static initial() {
        for (let i = 0; i < this._ctrls.length; i++) {
          this._ctrls[i].initial();
        }
        this.onInitial();
      }
      static onInitial() {
      }
      static update(dt) {
        for (let i = 0; i < this._ctrls.length; i++) {
          if (this._ctrls[i] == secretController) {
            continue;
          }
          this._ctrls[i].update(dt);
        }
        secretController.update(dt);
      }
      /**
       * 加载数据后是否验证成功
       */
      static get isValidate() {
        for (let i = 0; i < this._ctrls.length; i++) {
          if (!this._ctrls[i].isValidate) {
            console.info("controller validate fail", this._ctrls[i].dataKey);
            return false;
          }
        }
        return true;
      }
      static clearData() {
        StorageManager.enableSave = false;
        for (let i = 0; i < this._ctrls.length; i++) {
          this._ctrls[i].reset();
        }
        import_cc12.director.pause();
        localStorage.clear();
        if (import_env7.DEBUG) {
          location.reload();
        } else {
          import_cc12.game.end();
          if (PlatformSDK.inMiniGame) {
            PlatformSDK.restartMiniProgram({});
          }
        }
      }
      /**
       * 获取用户存档数据
       * @param serialize 
       * @param checkServerDirty 
       * @returns 
       */
      static getUserStorage(serialize = false, checkServerDirty = false) {
        let ret = {
          version: GameSettings.version,
          serialized: serialize ? 1 : 0,
          time: systemController.getTimeMS(),
          modules: {}
        };
        let dirty = false;
        for (let i = 0; i < this._ctrls.length; i++) {
          let ctrl = this._ctrls[i];
          if (!checkServerDirty || checkServerDirty && ctrl.serverDirty) {
            ctrl.getModelData(ret.modules, serialize);
            dirty = true;
          }
        }
        return dirty ? ret : null;
      }
      /**
       * 设置用户存档数据
       * @param data 
       * @param replace 
       * @param deserialize 
       */
      static setUserStorage(data, replace = false) {
        if (data.modules) {
          let keys = Object.keys(data.modules);
          for (let i = 0; i < keys.length; i++) {
            let key = keys[i];
            let ctrl = this._controllerMap[key];
            if (!ctrl) continue;
            ctrl.setModelData(data.modules, replace, data.serialized == 1);
            ctrl.isValidate = true;
          }
        }
        this.onUserStorageChanged();
      }
      static onUserStorageChanged() {
      }
      /**
       * 强制本地保存数据
       */
      static forceSave() {
        for (let i = 0; i < this._ctrls.length; i++) {
          let ctrl = this._ctrls[i];
          ctrl.save(true, true);
        }
      }
      /**
       * 清除存档脏数据标记
       */
      static clearServerDirty() {
        for (let i = 0; i < this._ctrls.length; i++) {
          let ctrl = this._ctrls[i];
          ctrl.clearServerDirty();
        }
      }
    };
    ControllerManager._ctrls = [];
    ControllerManager._controllerMap = {};
    ControllerManager.lastSaveTime = 0;
  }
});

// assets/scripts/framework/modules/base/types.ts
var types_exports = {};
var init_types = __esm({
  "assets/scripts/framework/modules/base/types.ts"() {
  }
});

// assets/scripts/framework/patch/ccc_pref_renderer.ts
var ccc_pref_renderer_exports = {};
__export(ccc_pref_renderer_exports, {
  Stage: () => Stage,
  clearIgnorePreformance: () => clearIgnorePreformance,
  ignorePreformance: () => ignorePreformance,
  isVisibility: () => isVisibility,
  overlayInPreformance: () => overlayInPreformance,
  preformanceNodeRenderer: () => preformanceNodeRenderer,
  preformanceSorting: () => preformanceSorting,
  setSorting: () => setSorting,
  setVisibility: () => setVisibility,
  updateOpacity: () => updateOpacity
});
function setVisibility(node, visible) {
  node["_visible_"] = visible;
}
function isVisibility(node) {
  return node["_visible_"] === void 0 ? true : node["_visible_"];
}
function preformanceNodeRenderer(node, childLevel = 2) {
  node["_children_pref_"] = {
    level: childLevel
  };
}
function setSorting(node, orderLayer, order) {
  let render = node.getComponent(import_cc13.Renderer);
  if (render && (render instanceof Image || render instanceof import_cc13.Sprite)) {
    let sorting = node.getComponent(import_cc13.Sorting);
    if (!sorting) {
      sorting = node.addComponent(import_cc13.Sorting);
    }
    sorting.sortingLayer = orderLayer;
    sorting.sortingOrder = order;
  }
  let children = node.children;
  for (let i = 0; i < children.length; ++i) {
    let child = children[i];
    setSorting(child, orderLayer, order);
  }
}
function preformanceSorting(node, orderLayer, order, childLevel = 2) {
  let children = node.children;
  let caches = [];
  for (let i = 0; i < children.length; ++i) {
    let child = children[i];
    let level = childLevel;
    while (level > 1) {
      child = child.children[0];
      level--;
    }
    if (child.children.length > 0) {
      for (let k = 0; k < child.children.length; k++) {
        if (!caches[k]) {
          caches.push([]);
        }
        caches[k].push(child.children[k]);
      }
    }
  }
  for (let i = 0; i < caches.length; i++) {
    let arr = caches[i];
    let sortingOrder = order + i;
    for (let j = 0; j < arr.length; j++) {
      setSorting(arr[j], orderLayer, sortingOrder);
    }
  }
}
function ignorePreformance(node) {
  node["_ignore_pref_"] = true;
}
function clearIgnorePreformance(node) {
  delete node["_ignore_pref_"];
  delete node["_overlay_pref_"];
  delete node["_sorting_order_"];
  let active = node.active;
  node.active = false;
  node.active = active;
}
function overlayInPreformance(node, sortingOrder, parent) {
  node["_overlay_pref_"] = true;
  node["_sorting_order_"] = {
    order: sortingOrder || 0,
    parent: parent || GRoot.inst.node
  };
}
function updateOpacity(renderData, opacity) {
  const vfmt = renderData.vertexFormat;
  const vb = renderData.chunk.vb;
  let attr;
  let format;
  let stride;
  let offset = 0;
  for (let i = 0; i < vfmt.length; ++i) {
    attr = vfmt[i];
    format = import_cc13.gfx.FormatInfos[attr.format];
    if (format.hasAlpha) {
      stride = renderData.floatStride;
      if (format.size / format.count === 1) {
        const alpha = ~~(0, import_cc13.clamp)(Math.round(opacity * 255), 0, 255);
        for (let color = offset; color < vb.length; color += stride) {
          vb[color] = (vb[color] & 4294967040 | alpha) >>> 0;
        }
      } else if (format.size / format.count === 4) {
        for (let alpha = offset + 3; alpha < vb.length; alpha += stride) {
          vb[alpha] = opacity;
        }
      }
    }
    offset += format.size >> 2;
  }
}
var import_cc13, Stage, overlay;
var init_ccc_pref_renderer = __esm({
  "assets/scripts/framework/patch/ccc_pref_renderer.ts"() {
    import_cc13 = require("cc");
    init_fairygui();
    init_fairygui();
    Stage = /* @__PURE__ */ ((Stage2) => {
      Stage2[Stage2["DISABLED"] = 0] = "DISABLED";
      Stage2[Stage2["CLEAR"] = 1] = "CLEAR";
      Stage2[Stage2["ENTER_LEVEL"] = 2] = "ENTER_LEVEL";
      Stage2[Stage2["ENABLED"] = 3] = "ENABLED";
      Stage2[Stage2["EXIT_LEVEL"] = 4] = "EXIT_LEVEL";
      Stage2[Stage2["CLEAR_INVERTED"] = 5] = "CLEAR_INVERTED";
      Stage2[Stage2["ENTER_LEVEL_INVERTED"] = 6] = "ENTER_LEVEL_INVERTED";
      return Stage2;
    })(Stage || {});
    overlay = [];
    import_cc13.UI.prototype.walk = function(node, level = 0) {
      if (!node.activeInHierarchy || !isVisibility(node)) {
        return;
      }
      const children = node.children;
      const uiProps = node._uiProps;
      const render = uiProps.uiComp;
      const parentOpacity = this._pOpacity;
      let opacity = parentOpacity;
      const selfOpacity = render && render.color ? render.color.a / 255 : 1;
      this._pOpacity = opacity *= selfOpacity * uiProps.localOpacity;
      uiProps.setOpacity(opacity);
      if (!import_cc13.math.approx(opacity, 0, import_cc13.EPSILON)) {
        if (uiProps.colorDirty) {
          this._opacityDirty++;
        }
        if (render && render.enabledInHierarchy) {
          render.fillBuffers(this);
        }
        if (this._opacityDirty && render && !render.useVertexOpacity && render.renderData && render.renderData.vertexCount > 0) {
          updateOpacity(render.renderData, opacity);
          const buffer = render.renderData.getMeshBuffer();
          if (buffer) {
            buffer.setDirty();
          }
        }
        let data = node["_children_pref_"];
        if (data) {
          if (children.length > 0 && !node._static) {
            let caches = [];
            for (let i = 0; i < children.length; ++i) {
              let child = children[i];
              if (child["_ignore_pref_"]) {
                this.walk(child, level);
              } else if (child["_overlay_pref_"]) {
                overlay.push(child);
              } else {
                if (!child._static) {
                  if (data.level == 2) {
                    child = child.children[0];
                  }
                  for (let k = 0; k < child.children.length; k++) {
                    if (!caches[k]) {
                      caches[k] = [];
                    }
                    caches[k].push(child.children[k]);
                  }
                }
              }
            }
            for (let i = 0; i < caches.length; i++) {
              let arr = caches[i];
              for (let j = 0; j < arr.length; j++) {
                let oldLv = level;
                this.walk(arr[j], level);
                level = oldLv;
              }
            }
          }
        } else {
          if (children.length > 0 && !node._static) {
            for (let i = 0; i < children.length; ++i) {
              const child = children[i];
              this.walk(child, level);
            }
          }
        }
        if (overlay.length > 0) {
          let parent = overlay[0]["_sorting_order_"].parent;
          if (node == parent) {
            overlay.sort((a, b) => {
              return a["_sorting_order_"].order - b["_sorting_order_"].order;
            });
            for (let i = 0; i < overlay.length; i++) {
              this.walk(overlay[i], -1);
            }
            overlay.length = 0;
          }
        }
        if (uiProps.colorDirty) {
          this._opacityDirty--;
          uiProps.colorDirty = false;
        }
      }
      this._pOpacity = parentOpacity;
      if (render && render.enabledInHierarchy) {
        render.postUpdateAssembler(this);
        if ((render.stencilStage === 2 /* ENTER_LEVEL */ || render.stencilStage === 6 /* ENTER_LEVEL_INVERTED */) && import_cc13.StencilManager.sharedManager.getMaskStackSize() > 0) {
          this.autoMergeBatches(this._currComponent);
          this.resetRenderStates();
          import_cc13.StencilManager.sharedManager.exitMask();
        }
      }
      level += 1;
    };
  }
});

// assets/scripts/framework/platform/Platform.ts
var Platform_exports = {};
__export(Platform_exports, {
  EPlatform: () => EPlatform2,
  PlatformHelper: () => PlatformHelper
});
var import_env8, EPlatform2, _PlatformHelper, PlatformHelper;
var init_Platform = __esm({
  "assets/scripts/framework/platform/Platform.ts"() {
    import_env8 = require("cc/env");
    init_macro();
    init_PlatformSDK();
    EPlatform2 = /* @__PURE__ */ ((EPlatform3) => {
      EPlatform3["WECHAT"] = "WECHAT";
      EPlatform3["MEITUAN"] = "MEITUAN";
      EPlatform3["ALIPAY"] = "ALIPAY";
      return EPlatform3;
    })(EPlatform2 || {});
    _PlatformHelper = class _PlatformHelper {
      static get isEnable() {
        return this._isEnable;
      }
      static get isWechat() {
        return this.platform === "WECHAT" /* WECHAT */;
      }
      static get isMeituan() {
        return this.platform === "MEITUAN" /* MEITUAN */;
      }
      static get isAlipay() {
        return this.platform === "ALIPAY" /* ALIPAY */;
      }
      static isMiniGame() {
        return this.platform === "WECHAT" /* WECHAT */ || this.platform === "MEITUAN" /* MEITUAN */ || this.platform === "ALIPAY" /* ALIPAY */;
      }
      static initial(config) {
        this._isEnable = typeof wx !== "undefined";
        if (!this._isEnable) {
          return;
        }
        this._rewardVideoAd = PlatformSDK.createRewardedVideoAd({
          adUnitId: config.rewardVideoAdUnitId
        });
        this._rewardVideoAd.load();
      }
      static login(options) {
        var _a;
        if (this._isEnable) {
          PlatformSDK.login({
            success: options.success,
            fail: options.fail
          });
        } else {
          (_a = options.success) == null ? void 0 : _a.call(options, null);
        }
      }
      static shareAppMessage(options) {
        if (!this.isEnable) {
          if (options.success) {
            options.success();
          }
          return;
        }
        PlatformSDK.shareAppMessage({
          title: options.title,
          imageUrl: options.imageUrl,
          query: options.query
        });
        const moniterTime = options.enableMonitor === false ? 0 : _PlatformHelper.shareMonitorTime;
        if (moniterTime > 0) {
          setTimeout(() => {
            if (options.success) {
              options.success();
            }
          }, moniterTime * 1e3);
        } else {
          if (options.success) {
            options.success();
          }
        }
      }
      static showRewardedVideoAd(options) {
        if (!this.isEnable) {
          if (options.success) {
            options.success();
          }
          return;
        }
        this._rewardVideoAd.load().then(() => {
          this._rewardVideoAd.show().then(() => {
            console.log("\u6FC0\u52B1\u89C6\u9891 \u5E7F\u544A\u663E\u793A");
            if (options.success) {
              options.success();
            }
          }).catch(() => {
            console.log("\u6FC0\u52B1\u89C6\u9891 \u5E7F\u544A\u663E\u793A\u5931\u8D25");
            if (options.fail) {
              options.fail();
            }
          });
        }).catch(() => {
          console.log("\u6FC0\u52B1\u89C6\u9891 \u5E7F\u544A\u52A0\u8F7D\u5931\u8D25");
          if (options.fail) {
            options.fail();
          }
        });
      }
    };
    _PlatformHelper.platform = "WECHAT" /* WECHAT */;
    _PlatformHelper.shareMonitorTime = 2;
    _PlatformHelper._isEnable = false;
    PlatformHelper = _PlatformHelper;
    if (MEITUAN) {
      PlatformHelper.platform = "MEITUAN" /* MEITUAN */;
    } else if (import_env8.WECHAT) {
      PlatformHelper.platform = "WECHAT" /* WECHAT */;
    } else if (import_env8.ALIPAY) {
      PlatformHelper.platform = "ALIPAY" /* ALIPAY */;
    }
  }
});

// assets/scripts/framework/plugins/capture/CanvasPool.ts
var CanvasPool_exports = {};
__export(CanvasPool_exports, {
  CanvasPool: () => CanvasPool
});
var import_cc14, _canvasPool, CanvasPool;
var init_CanvasPool = __esm({
  "assets/scripts/framework/plugins/capture/CanvasPool.ts"() {
    import_cc14 = require("cc");
    CanvasPool = class _CanvasPool {
      constructor() {
        this.pool = [];
      }
      static getInstance() {
        if (!_canvasPool) {
          _canvasPool = new _CanvasPool();
        }
        return _canvasPool;
      }
      get() {
        let data = this.pool.pop();
        if (!data) {
          const canvas = import_cc14.cclegacy._global.window.document.createElement("canvas");
          const context = canvas.getContext("2d");
          data = {
            canvas,
            context
          };
        }
        return data;
      }
      put(canvas) {
        if (this.pool.length >= import_cc14.macro.MAX_LABEL_CANVAS_POOL_SIZE) {
          return;
        }
        this.pool.push(canvas);
      }
    };
  }
});

// assets/scripts/framework/plugins/capture/CaptureHelper.ts
var CaptureHelper_exports = {};
__export(CaptureHelper_exports, {
  CaptureHelper: () => CaptureHelper
});
var import_cc15, canvasPool, versions, mVersion, FLIP_Y_VERSION, CaptureHelper;
var init_CaptureHelper = __esm({
  "assets/scripts/framework/plugins/capture/CaptureHelper.ts"() {
    import_cc15 = require("cc");
    init_CanvasPool();
    canvasPool = CanvasPool;
    versions = import_cc15.VERSION.split(".");
    mVersion = parseInt(versions[0]);
    FLIP_Y_VERSION = mVersion != 3 || mVersion == 3 && parseInt(versions[1]) != 6;
    CaptureHelper = class {
      static setChildLayer(node, layer, depth = 0) {
        if (!node) {
          return;
        }
        let key = "__old_layer__";
        if (depth == 0) {
          if (layer) {
            node[key] = node.layer;
            node.layer = layer;
          } else {
            node.layer = node[key];
            delete node[key];
          }
        }
        let children = node.children;
        for (let i = 0; i < children.length; i++) {
          let child = children[i];
          if (!child.active) {
            continue;
          }
          if (layer) {
            child[key] = child.layer;
            child.layer = layer;
          } else {
            child.layer = child[key];
            delete child[key];
          }
          this.setChildLayer(child, layer, depth + 1);
        }
      }
      static canvasEncodeTexture(canvas, type = "jpeg", quality) {
        return new Promise((resolve) => {
          if (canvas.toDataURL) {
            resolve(canvas.toDataURL("image/" + type, quality));
          } else {
            canvas.toBlob((blob) => {
              var reader = new FileReader();
              reader.readAsDataURL(blob);
              reader.onload = (e) => {
                resolve(e.target.result);
              };
            }, "image/" + type, quality);
          }
        });
      }
      /**
       * 将RGBA纹理编码为图片数据[不支持原生平台]
       * @param arrayBuffer 像素数组
       * @param size 纹理大小
       * @param type 编码类型
       * @param trimHeader 是否移除base64文件头
       * @param quality 编码质量
       * @param flipY 是否进行y轴翻转，相对比较耗性能
       * @returns 
       */
      static async toBase64Image(arrayBuffer, size, type = "png", trimHeader, quality = 1, flipY = null) {
        if (flipY == null) {
          flipY = !FLIP_Y_VERSION;
        }
        let canvas = canvasPool.getInstance().get();
        let width = canvas.canvas.width = Math.floor(size.width);
        let height = canvas.canvas.height = Math.floor(size.height);
        let ctx = canvas.context;
        let imageU8Data = new Uint8Array(arrayBuffer);
        let imageData = ctx.createImageData(width, height);
        if (flipY) {
          let bytesWidth = width * 4;
          for (let hi = 0; hi < height; hi++) {
            let sindex = hi * bytesWidth;
            let eindex = sindex + bytesWidth;
            let tsindex = (height - 1 - hi) * bytesWidth;
            for (let start = sindex; start < eindex; start++) {
              imageData.data[tsindex] = imageU8Data[start];
              tsindex++;
            }
          }
        } else {
          imageData.data.set(imageU8Data);
        }
        ctx.putImageData(imageData, 0, 0);
        if (type == "png") {
          canvas.canvas.style.backgroundColor = null;
        }
        var base64 = await this.canvasEncodeTexture(canvas.canvas, type, quality);
        canvasPool.getInstance().put(canvas);
        if (trimHeader) {
          let index = base64.indexOf(",");
          if (index != -1) {
            base64 = base64.substring(index + 1);
          }
        }
        return base64;
      }
      /**
       * 通过纹理读取制定区域的像素值
       * @param src 纹理
       * @param rect 区域，为空表示全部区域
       * @param buffer 返回数组
       * @returns 返回数组
       */
      static readTexturePixels(src, rect, buffer) {
        rect = rect || new import_cc15.Rect(0, 0, src.width, src.height);
        rect.x = Math.floor(rect.x);
        rect.y = Math.floor(rect.y);
        rect.width = Math.floor(rect.width);
        rect.height = Math.floor(rect.height);
        const gfxTexture = src.getGFXTexture();
        if (!gfxTexture) {
          (0, import_cc15.errorID)(7606);
          return null;
        }
        const needSize = 4 * rect.width * rect.height;
        if (buffer === void 0) {
          buffer = new Uint8Array(needSize);
        } else if (buffer.length < needSize) {
          (0, import_cc15.errorID)(7607, needSize);
          return null;
        }
        const bufferViews = [];
        const regions = [];
        const region0 = new import_cc15.gfx.BufferTextureCopy();
        region0.texOffset.x = rect.x;
        region0.texOffset.y = rect.y;
        region0.texExtent.width = rect.width;
        region0.texExtent.height = rect.height;
        regions.push(region0);
        bufferViews.push(buffer);
        const gfxDevice = src["_getGFXDevice"]();
        gfxDevice == null ? void 0 : gfxDevice.copyTextureToBuffers(gfxTexture, bufferViews, regions);
        return buffer;
      }
      static getComponentInParent(node, type) {
        if (node.parent) {
          let comp = node.parent.getComponent(type);
          if (comp) {
            return comp;
          }
          if (node.parent.parent) {
            return this.getComponentInParent(node.parent, type);
          }
        }
        return null;
      }
      /**
       * 通过相机截图,返回纹理需要自己管理
       * 当使用新建相机时，如果屏幕适配是SHOW_ALL策略，将可能会有ui缩放错误的问题(应该是引擎bug)
       * @param target 目标节点
       * @param cam 节点渲染相机
       * @param rect 裁剪区域
       * @param scale 图片缩放大小
       * @param pos 是否需要将相机对齐到给定点
       * @param useRawCamera 是否使用节点渲染的相机来截图，开启后不剔除物体
       * @param flipY 是否在y轴方向进行翻转
       * @returns 纹理
       */
      static async capture(target, cam, rect, scale, pos, useRawCamera, flipY = true) {
        let node = new import_cc15.Node("CaptureCamera");
        cam.node.parent.addChild(node);
        let wpos = cam.node.worldPosition;
        let camera;
        if (useRawCamera) {
          camera = cam;
        } else {
          let layer = 1 << import_cc15.Layers.nameToLayer("CAPTURE");
          if (pos) {
            node.setWorldPosition(pos.x, pos.y, wpos.z);
          } else {
            node.setWorldPosition(wpos.x, wpos.y, wpos.z);
          }
          camera = node.addComponent(import_cc15.Camera);
          camera.node.setWorldScale(cam.node.getWorldScale());
          camera.clearFlags = import_cc15.gfx.ClearFlagBit.ALL;
          camera.clearColor = new import_cc15.Color(0, 0, 0, 0);
          camera.clearDepth = cam.clearDepth;
          camera.clearStencil = cam.clearStencil;
          camera.projection = cam.projection;
          camera.priority = cam.priority;
          camera.orthoHeight = cam.orthoHeight;
          camera.far = cam.far;
          camera.near = cam.near;
          camera.fov = cam.fov;
          camera.fovAxis = cam.fovAxis;
          camera.iso = cam.iso;
          camera.aperture = cam.aperture;
          camera.shutter = cam.shutter;
          camera.screenScale = cam.screenScale;
          camera.node.up.set(cam.node.up);
          camera.rect.set(cam.rect);
          camera.visibility = layer;
          this.setChildLayer(target, layer);
          await new Promise((resolve) => {
            import_cc15.director.once(import_cc15.Director.EVENT_BEGIN_FRAME, () => {
              resolve(0);
            });
          });
        }
        let camScale;
        if (flipY) {
          camScale = (0, import_cc15.v3)(camera.node.scale);
          camera.node.setScale(camScale.x, -camScale.y, camScale.z);
        }
        scale = scale || 1;
        let rt = new import_cc15.RenderTexture();
        let size = import_cc15.view.getVisibleSize();
        rt.reset({ width: size.width * scale, height: size.height * scale });
        camera.targetTexture = rt;
        import_cc15.director.root.frameMove(0);
        let clear = () => {
          node.destroy();
          camera.targetTexture = null;
          if (flipY) {
            camera.node.setScale(camScale);
          }
          if (!useRawCamera) {
            this.setChildLayer(target);
          }
        };
        if (rect) {
          if (flipY && FLIP_Y_VERSION) {
            rect.y = size.height - rect.y - rect.height;
          }
          rect.set(rect.x * scale, rect.y * scale, rect.width * scale, rect.height * scale);
          let tex2d = new import_cc15.Texture2D();
          tex2d.reset({
            width: rect.width,
            height: rect.height,
            format: import_cc15.Texture2D.PixelFormat.RGBA8888,
            mipmapLevel: 0
          });
          tex2d.uploadData(rt.readPixels(rect.x, rect.y, rect.width, rect.height));
          rt.destroy();
          clear();
          return tex2d;
        }
        clear();
        return rt;
      }
      /**
       * 抓取指定ui区域为纹理（支持透明）,返回纹理需要自己管理
       * @param target 指定ui节点, 不支持缩放
       * @param cam 渲染此ui的相机
       * @param opts 截图参数
       * @returns 纹理
       */
      static async captureUI2Texture(target, cam, opts) {
        opts = opts || {};
        opts.useRawCamera = opts.useRawCamera ?? true;
        let utr = target.getComponent(import_cc15.UITransform);
        let rect = (opts == null ? void 0 : opts.rect) ?? utr.getBoundingBox();
        let width = rect.width;
        let height = rect.height;
        let scale = 1;
        if (opts.firstSize) {
          if (opts.heightFrist) {
            scale = opts.firstSize / height;
          } else {
            scale = opts.firstSize / width;
          }
        }
        if (opts.aspect) {
          if (!opts.heightFrist) {
            width = rect.width;
            height = width / opts.aspect;
          } else {
            height = rect.height;
            width = height * opts.aspect;
          }
        }
        let pos = utr.convertToWorldSpaceAR((0, import_cc15.v3)(-width * utr.anchorX, -height * utr.anchorY, 0));
        let snapPos = null;
        if (!opts.useRawCamera) {
          rect.x = 0;
          rect.y = 0;
          let size = import_cc15.view.getVisibleSize();
          pos.x += size.width * 0.5;
          pos.y += size.height * 0.5;
          let ap = size.width / size.height;
          let policy = import_cc15.view.getResolutionPolicy();
          let strategy = policy["_contentStrategy"];
          if (strategy && strategy.name == "ShowAll" && ap < 1) {
            if (import_cc15.sys.platform == import_cc15.sys.Platform.DESKTOP_BROWSER) {
              pos.y += size.height * (1 - import_cc15.screen.devicePixelRatio) * 0.5;
            } else {
              pos.y += (import_cc15.view.getViewportRect().height - size.height) * 0.5;
            }
          }
          snapPos = (0, import_cc15.v2)(pos.x, pos.y);
        } else {
          rect.x = pos.x;
          rect.y = pos.y;
        }
        return await this.capture(target, cam, rect, scale, snapPos, opts.useRawCamera, opts.useRawCamera || FLIP_Y_VERSION);
      }
      /**
       * 纹理编码为jpg/png图片
       * @param texture 目标纹理
       * @param type 编码格式
       * @param trimHeader 是否移除图片头(微信存储base64时不需要文件头)
       * @param quality 图片编码质量
       * @param flipY 是否进行y轴翻转，比较耗性能
       * @returns 返回指定格式的base64编码图片
       */
      static async textureToImage(texture, type = "png", trimHeader, quality = 1, flipY = null) {
        let arrayBuffer = await this.readTexturePixels(texture);
        return await this.toBase64Image(arrayBuffer, new import_cc15.Size(texture.width, texture.height), type, trimHeader, quality, flipY);
      }
      /**
       * 按实际屏幕分辨率，全屏截图，此方法直接截取游戏canvas画面[不支持原生平台]
       * @returns 纹理
       */
      static async captureFullScreen() {
        let tex2d = new import_cc15.Texture2D();
        tex2d.reset({
          width: import_cc15.game.canvas.width,
          height: import_cc15.game.canvas.height,
          format: import_cc15.Texture2D.PixelFormat.RGBA8888,
          mipmapLevel: 0
        });
        import_cc15.director.root.frameMove(0);
        tex2d.uploadData(import_cc15.game.canvas);
        return tex2d;
      }
      /**
       * 按实际屏幕分辨率，全屏截图，此方法直接截取游戏canvas画面[不支持原生平台]
       * @param trimHeader 是否移除文件头
       * @returns 返回指定格式的base64编码图片
       */
      static async captureFullScreenToImage(trimHeader, quality = 1) {
        import_cc15.director.root.frameMove(0);
        var base64 = await this.canvasEncodeTexture(import_cc15.game.canvas, "jpeg", quality);
        if (trimHeader) {
          let index = base64.indexOf(",");
          if (index != -1) {
            base64 = base64.substring(index + 1);
          }
        }
        return base64;
      }
      /** 
       * 按实际屏幕分辨率，全屏截图（支持透明）,返回纹理需要自己管理
       * @param cam 用来截屏的相机
       * @returns 纹理
       */
      static async captureCameraToTexture(cam) {
        return this.capture(null, cam, null, 1, null, true, true);
      }
      /**
       * 按设计分辨率，生成微信分享图片（支持透明）
       * @param target 目标ui
       * @param cam ui相机
       * @param type 生成图片类型
       * @param heightFrist 是否高度优先
       * @param firstSize 优先边的长度
       * @returns 返回指定格式的base64编码图片
       */
      static async captureWechatShareImage(target, cam, type = "png", heightFrist = true, firstSize = 400, quality = 1) {
        let opts = {
          heightFrist,
          aspect: 5 / 4,
          //微信要求5/4的图片
          firstSize
        };
        let texture = await this.captureUI2Texture(target, cam, opts);
        let img = this.textureToImage(texture, type, true, quality);
        texture.destroy();
        return img;
      }
      /**
       * 测试用接口
       * @param base64 
       * @param name 
       * @returns 
       */
      static downloadImage(base64, type = "png", name) {
        if (!import_cc15.sys.isBrowser) {
          return;
        }
        var byteCharacters = atob(
          base64.replace(/^data:image\/(png|jpeg|jpg);base64,/, "")
        );
        var byteNumbers = new Array(byteCharacters.length);
        for (var i = 0; i < byteCharacters.length; i++) {
          byteNumbers[i] = byteCharacters.charCodeAt(i);
        }
        var byteArray = new Uint8Array(byteNumbers);
        var blob = new Blob([byteArray], {
          type: `image/${type}`
        });
        var aLink = document.createElement("a");
        document.body.appendChild(aLink);
        aLink.style.display = "none";
        aLink.href = URL.createObjectURL(blob);
        aLink.setAttribute("download", (name || "image") + (type == "jpeg" ? ".jpg" : ".png"));
        aLink.click();
        document.body.removeChild(aLink);
      }
    };
  }
});

// assets/scripts/framework/plugins/config/DataAccess.ts
var DataAccess_exports = {};
__export(DataAccess_exports, {
  DataAccess: () => DataAccess,
  DataItem: () => DataItem,
  DataTable: () => DataTable
});
var import_cc16, DataAccess, DataItem, DataTable;
var init_DataAccess = __esm({
  "assets/scripts/framework/plugins/config/DataAccess.ts"() {
    import_cc16 = require("cc");
    DataAccess = class {
      static initial(dataDir, loadHandle, fileNameGenerateHandle) {
        this.dataDir = dataDir;
        this.generator = fileNameGenerateHandle;
        this.loader = loadHandle;
      }
      /**
       * 获取配置表
       * @param dataType 配置的数据类型
       * @returns 
       */
      static getDataItem(dataType) {
        let typename = dataType["__type_name__"];
        if (this._items[typename]) {
          return this._items[typename];
        }
        return this._items[typename] = new DataItem(dataType);
      }
      /**
       * 获取配置表, 可自定义主键名称
       * @param dataType 配置的数据类型
       * @param keyName 主键名称
       * @returns 
       */
      static getDataTable(dataType, keyName = "ID") {
        let typename = dataType["__type_name__"];
        if (this._tables[typename]) {
          return this._tables[typename];
        }
        return this._tables[typename] = new DataTable(dataType, keyName);
      }
    };
    /// <summary>
    /// 是否使用ProtoMember的tag作为hashtable的key
    /// </summary>
    DataAccess.useProtoMemberTagAsHashtableKey = false;
    DataAccess.cacheHashValue = true;
    DataAccess.dataExt = ".bin";
    DataAccess._items = {};
    DataAccess._tables = {};
    DataItem = class _DataItem {
      constructor(dataType) {
        this.dataType = dataType;
      }
      onGenerateFilename(typeName) {
        if (this.localGenerator != null) {
          return this.localGenerator(typeName);
        }
        if (DataAccess.generator != null) {
          return DataAccess.generator(typeName);
        }
        typeName = typeName.replace("_ARRAY", "");
        return DataAccess.dataDir + typeName.toLocaleLowerCase();
      }
      onLoadData(typeName) {
        if (this.source != null) {
          return new Uint8Array(this.source.buffer());
        }
        var datafile = this.onGenerateFilename(typeName);
        if (this.localLoader != null) {
          return this.localLoader(datafile);
        }
        if (DataAccess.loader != null) {
          return DataAccess.loader(datafile);
        }
        this.source = import_cc16.resources.get(datafile, import_cc16.BufferAsset);
        if (this.source) {
          return new Uint8Array(this.source.buffer());
        }
        return null;
      }
      setSource(source) {
        this.source = source;
      }
      initial(dataType, loadHandle, fileNameGenerateHandle) {
        this.dataType = dataType;
        this.localLoader = loadHandle;
        this.localGenerator = fileNameGenerateHandle;
      }
      static create(dataType, source) {
        var instance = new _DataItem(dataType);
        instance.setSource(source);
        return instance;
      }
      clear() {
        if (this.source != null) {
          this.source.destroy();
          this.source = null;
        }
      }
      load() {
        var buffer = this.onLoadData(this.dataType["__array_type_name__"]);
        var msgType = this.dataType["__array_type__"];
        return msgType.decode(buffer);
      }
      get data() {
        if (this._item == null) {
          this._item = this.load();
        }
        return this._item;
      }
    };
    DataTable = class _DataTable extends DataItem {
      constructor(dataType, keyName = "ID") {
        super(dataType);
        this._keyName = "ID";
        this._keyName = keyName;
      }
      get keyName() {
        return this._keyName;
      }
      load() {
        var arrTypeName = this.dataType["__array_type_name__"];
        var buffer = this.onLoadData(arrTypeName);
        var msgType = this.dataType["getArrayType"]();
        var message = msgType.decode(buffer);
        return message.Items;
      }
      static create(dataType, source, keyName = "ID") {
        var instance = new _DataTable(dataType, keyName);
        instance.setSource(source);
        return instance;
      }
      get itemMap() {
        if (this._itemMap == null) {
          this._itemMap = this.initDataAsDict();
        }
        return this._itemMap;
      }
      get items() {
        try {
          if (this._items == null) {
            this._items = this.initDataAsList();
          }
        } catch (e) {
          console.log(`config data load error: ${e}`);
        }
        return this._items;
      }
      get IDs() {
        if (this._ids == null) {
          this._ids = this.items.map((val, idx, arr) => {
            arr.push(val[this.keyName]);
          }, []);
        }
        return this._ids;
      }
      getItem(key) {
        return this.itemMap[key];
      }
      initDataAsDict() {
        let itemMap = {};
        try {
          this.items.forEach((val) => {
            itemMap[val[this.keyName]] = val;
          });
          return itemMap;
        } catch (e) {
          console.error(`can not get data map by key ${this.keyName}`);
          return itemMap;
        }
      }
      initDataAsList() {
        return this.load();
      }
      contains(id) {
        return this.itemMap[id] != null;
      }
      clear() {
        super.clear();
        this._itemMap = null;
        this._items = null;
      }
    };
  }
});

// node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
      while (index < arguments.length)
        params[offset++] = arguments[index++];
      return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve.apply(null, params2);
            }
          }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      });
    }
  }
});

// node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    var base64 = exports2;
    base64.length = function length(string) {
      var p = string.length;
      if (!p)
        return 0;
      var n = 0;
      while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
      return Math.ceil(string.length * 3) / 4 - n;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    var i;
    base64.encode = function encode(buffer, start, end) {
      var parts = null, chunk = [];
      var i2 = 0, j = 0, t;
      while (start < end) {
        var b = buffer[start++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b >> 2];
            t = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t | b >> 4];
            t = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t | b >> 6];
            chunk[i2++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t];
        chunk[i2++] = 61;
        if (j === 1)
          chunk[i2++] = 61;
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    var invalidEncoding = "invalid encoding";
    base64.decode = function decode(string, buffer, offset) {
      var start = offset;
      var j = 0, t;
      for (var i2 = 0; i2 < string.length; ) {
        var c = string.charCodeAt(i2++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c;
            j = 1;
            break;
          case 1:
            buffer[offset++] = t << 2 | (c & 48) >> 4;
            t = c;
            j = 2;
            break;
          case 2:
            buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
            t = c;
            j = 3;
            break;
          case 3:
            buffer[offset++] = (t & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base64.test = function test(string) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
    };
  }
});

// node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    module2.exports = EventEmitter;
    function EventEmitter() {
      this._listeners = {};
    }
    EventEmitter.prototype.on = function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter.prototype.off = function off(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i = 0; i < listeners.length; )
            if (listeners[i].fn === fn)
              listeners.splice(i, 1);
            else
              ++i;
        }
      }
      return this;
    };
    EventEmitter.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i = 1;
        for (; i < arguments.length; )
          args.push(arguments[i++]);
        for (i = 0; i < listeners.length; )
          listeners[i].fn.apply(listeners[i++].ctx, args);
      }
      return this;
    };
  }
});

// node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined") (function() {
        var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
        function writeFloat_f32_cpy(val, buf, pos) {
          f32[0] = val;
          buf[pos] = f8b[0];
          buf[pos + 1] = f8b[1];
          buf[pos + 2] = f8b[2];
          buf[pos + 3] = f8b[3];
        }
        function writeFloat_f32_rev(val, buf, pos) {
          f32[0] = val;
          buf[pos] = f8b[3];
          buf[pos + 1] = f8b[2];
          buf[pos + 2] = f8b[1];
          buf[pos + 3] = f8b[0];
        }
        exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
        function readFloat_f32_cpy(buf, pos) {
          f8b[0] = buf[pos];
          f8b[1] = buf[pos + 1];
          f8b[2] = buf[pos + 2];
          f8b[3] = buf[pos + 3];
          return f32[0];
        }
        function readFloat_f32_rev(buf, pos) {
          f8b[3] = buf[pos];
          f8b[2] = buf[pos + 1];
          f8b[1] = buf[pos + 2];
          f8b[0] = buf[pos + 3];
          return f32[0];
        }
        exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
      })();
      else (function() {
        function writeFloat_ieee754(writeUint, val, buf, pos) {
          var sign = val < 0 ? 1 : 0;
          if (sign)
            val = -val;
          if (val === 0)
            writeUint(1 / val > 0 ? (
              /* positive */
              0
            ) : (
              /* negative 0 */
              2147483648
            ), buf, pos);
          else if (isNaN(val))
            writeUint(2143289344, buf, pos);
          else if (val > 34028234663852886e22)
            writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
          else if (val < 11754943508222875e-54)
            writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
          else {
            var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
            writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
          }
        }
        exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
        function readFloat_ieee754(readUint, buf, pos) {
          var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
          return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }
        exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
      })();
      if (typeof Float64Array !== "undefined") (function() {
        var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
        function writeDouble_f64_cpy(val, buf, pos) {
          f64[0] = val;
          buf[pos] = f8b[0];
          buf[pos + 1] = f8b[1];
          buf[pos + 2] = f8b[2];
          buf[pos + 3] = f8b[3];
          buf[pos + 4] = f8b[4];
          buf[pos + 5] = f8b[5];
          buf[pos + 6] = f8b[6];
          buf[pos + 7] = f8b[7];
        }
        function writeDouble_f64_rev(val, buf, pos) {
          f64[0] = val;
          buf[pos] = f8b[7];
          buf[pos + 1] = f8b[6];
          buf[pos + 2] = f8b[5];
          buf[pos + 3] = f8b[4];
          buf[pos + 4] = f8b[3];
          buf[pos + 5] = f8b[2];
          buf[pos + 6] = f8b[1];
          buf[pos + 7] = f8b[0];
        }
        exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
        function readDouble_f64_cpy(buf, pos) {
          f8b[0] = buf[pos];
          f8b[1] = buf[pos + 1];
          f8b[2] = buf[pos + 2];
          f8b[3] = buf[pos + 3];
          f8b[4] = buf[pos + 4];
          f8b[5] = buf[pos + 5];
          f8b[6] = buf[pos + 6];
          f8b[7] = buf[pos + 7];
          return f64[0];
        }
        function readDouble_f64_rev(buf, pos) {
          f8b[7] = buf[pos];
          f8b[6] = buf[pos + 1];
          f8b[5] = buf[pos + 2];
          f8b[4] = buf[pos + 3];
          f8b[3] = buf[pos + 4];
          f8b[2] = buf[pos + 5];
          f8b[1] = buf[pos + 6];
          f8b[0] = buf[pos + 7];
          return f64[0];
        }
        exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
      })();
      else (function() {
        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
          var sign = val < 0 ? 1 : 0;
          if (sign)
            val = -val;
          if (val === 0) {
            writeUint(0, buf, pos + off0);
            writeUint(1 / val > 0 ? (
              /* positive */
              0
            ) : (
              /* negative 0 */
              2147483648
            ), buf, pos + off1);
          } else if (isNaN(val)) {
            writeUint(0, buf, pos + off0);
            writeUint(2146959360, buf, pos + off1);
          } else if (val > 17976931348623157e292) {
            writeUint(0, buf, pos + off0);
            writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
          } else {
            var mantissa;
            if (val < 22250738585072014e-324) {
              mantissa = val / 5e-324;
              writeUint(mantissa >>> 0, buf, pos + off0);
              writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
            } else {
              var exponent = Math.floor(Math.log(val) / Math.LN2);
              if (exponent === 1024)
                exponent = 1023;
              mantissa = val * Math.pow(2, -exponent);
              writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
              writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
            }
          }
        }
        exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
          var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
          var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
          return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }
        exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
      })();
      return exports3;
    }
    function writeUintLE(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf, pos) {
      buf[pos] = val >>> 24;
      buf[pos + 1] = val >>> 16 & 255;
      buf[pos + 2] = val >>> 8 & 255;
      buf[pos + 3] = val & 255;
    }
    function readUintLE(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf, pos) {
      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
    }
  }
});

// node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e) {
      }
      return null;
    }
  }
});

// node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    var utf8 = exports2;
    utf8.length = function utf8_length(string) {
      var len = 0, c = 0;
      for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf8.read = function utf8_read(buffer, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i = 0, t;
      while (start < end) {
        t = buffer[start++];
        if (t < 128)
          chunk[i++] = t;
        else if (t > 191 && t < 224)
          chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t >> 10);
          chunk[i++] = 56320 + (t & 1023);
        } else
          chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    };
    utf8.write = function utf8_write(string, buffer, offset) {
      var start = offset, c1, c2;
      for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
          buffer[offset++] = c1;
        } else if (c1 < 2048) {
          buffer[offset++] = c1 >> 6 | 192;
          buffer[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer[offset++] = c1 >> 18 | 240;
          buffer[offset++] = c1 >> 12 & 63 | 128;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        } else {
          buffer[offset++] = c1 >> 12 | 224;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    };
  }
});

// node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    module2.exports = pool;
    function pool(alloc, slice, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc(size2);
        if (offset + size2 > SIZE) {
          slab = alloc(SIZE);
          offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf;
      };
    }
  }
});

// node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    module2.exports = LongBits;
    var util = require_minimal();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign = value < 0;
      if (sign)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    };
    LongBits.from = function from(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash) {
      if (hash === zeroHash)
        return zero;
      return new LongBits(
        (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,
        (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0
      );
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits();
    util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util.isString = function isString(value) {
      return typeof value === "string" || value instanceof String;
    };
    util.isObject = function isObject(value) {
      return value && typeof value === "object";
    };
    util.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util.Buffer = function() {
      try {
        var Buffer2 = util.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : (
          /* istanbul ignore next */
          null
        );
      } catch (e) {
        return null;
      }
    }();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = /* istanbul ignore next */
    util.global.dcodeIO && /* istanbul ignore next */
    util.global.dcodeIO.Long || /* istanbul ignore next */
    util.global.Long || util.inquire("long");
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    };
    util.longFromHash = function longFromHash(hash, unsigned) {
      var bits = util.LongBits.fromHash(hash);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge(dst, src, ifNotSet) {
      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === void 0 || !ifNotSet)
          dst[keys[i]] = src[keys[i]];
      return dst;
    }
    util.merge = merge;
    util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge(this, properties);
      }
      CustomError.prototype = Object.create(Error.prototype, {
        constructor: {
          value: CustomError,
          writable: true,
          enumerable: false,
          configurable: true
        },
        name: {
          get: function get() {
            return name;
          },
          set: void 0,
          enumerable: false,
          // configurable: false would accurately preserve the behavior of
          // the original, but I'm guessing that was not intentional.
          // For an actual error subclass, this property would
          // be configurable.
          configurable: true
        },
        toString: {
          value: function value() {
            return this.name + ": " + this.message;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      return CustomError;
    }
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    };
    util.oneOfSetter = function setOneOf(fieldNames) {
      return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name)
            delete this[fieldNames[i]];
      };
    };
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer2 = util.Buffer;
      if (!Buffer2) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
      function Buffer_from(value, encoding) {
        return new Buffer2(value, encoding);
      };
      util._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      };
    };
  }
});

// node_modules/protobufjs/src/writer.js
var require_writer = __commonJS({
  "node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    module2.exports = Writer;
    var util = require_minimal();
    var BufferWriter;
    var LongBits = util.LongBits;
    var base64 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop() {
    }
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer() {
      this.len = 0;
      this.head = new Op(noop, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer();
      };
    };
    Writer.create = create();
    Writer.alloc = function alloc(size) {
      return new util.Array(size);
    };
    if (util.Array !== Array)
      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
    Writer.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    function writeVarint32(val, buf, pos) {
      while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    };
    Writer.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf, pos) {
      while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
    }
    Writer.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    Writer.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    };
    Writer.prototype.double = function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    };
    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytes_for(val, buf, pos) {
      for (var i = 0; i < val.length; ++i)
        buf[pos + i] = val[i];
    };
    Writer.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    };
    Writer.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
      return this;
    };
    Writer.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer.prototype.finish = function finish() {
      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
      }
      return buf;
    };
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer.create = create();
      BufferWriter._configure();
    };
  }
});

// node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferWriter;
    var Writer = require_writer();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util = require_minimal();
    function BufferWriter() {
      Writer.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy)
          val.copy(buf, pos, 0, val.length);
        else for (var i = 0; i < val.length; )
          buf[pos++] = val[i++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf, pos);
      else if (buf.utf8Write)
        buf.utf8Write(val, pos);
      else
        buf.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = util.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
    BufferWriter._configure();
  }
});

// node_modules/protobufjs/src/reader.js
var require_reader = __commonJS({
  "node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    module2.exports = Reader;
    var util = require_minimal();
    var BufferReader;
    var LongBits = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    function Reader(buffer) {
      this.buf = buffer;
      this.pos = 0;
      this.len = buffer.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
      if (buffer instanceof Uint8Array || Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    } : function create_array2(buffer) {
      if (Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    };
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup(buffer) {
        return (Reader.create = function create_buffer(buffer2) {
          return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
        })(buffer);
      } : create_array;
    };
    Reader.create = create();
    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
    util.Array.prototype.slice;
    Reader.prototype.uint32 = /* @__PURE__ */ function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    }();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf, end) {
      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length = this.uint32(), start = this.pos, end = this.pos + length;
      if (end > this.len)
        throw indexOutOfRange(this, length);
      this.pos += length;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      if (start === end) {
        var nativeBuffer = util.Buffer;
        return nativeBuffer ? nativeBuffer.alloc(0) : new this.buf.constructor(0);
      }
      return this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
    };
    Reader.prototype.skip = function skip(length) {
      if (typeof length === "number") {
        if (this.pos + length > this.len)
          throw indexOutOfRange(this, length);
        this.pos += length;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader.create = create();
      BufferReader._configure();
      var fn = util.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferReader;
    var Reader = require_reader();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util = require_minimal();
    function BufferReader(buffer) {
      Reader.call(this, buffer);
    }
    BufferReader._configure = function() {
      if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});

// node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service;
    var util = require_minimal();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
          function rpcCallback(err, response) {
            if (err) {
              self2.emit("error", err, method);
              return callback(err);
            }
            if (response === null) {
              self2.end(
                /* endedByRPC */
                true
              );
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err2) {
                self2.emit("error", err2, method);
                return callback(err2);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }
        );
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    };
    Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "node_modules/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// node_modules/protobufjs/src/roots.js
var require_roots = __commonJS({
  "node_modules/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    module2.exports = {};
  }
});

// node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "node_modules/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure;
    function configure() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure();
  }
});

// node_modules/@protobufjs/codegen/index.js
var require_codegen = __commonJS({
  "node_modules/@protobufjs/codegen/index.js"(exports2, module2) {
    "use strict";
    module2.exports = codegen;
    function codegen(functionParams, functionName) {
      if (typeof functionParams === "string") {
        functionName = functionParams;
        functionParams = void 0;
      }
      var body = [];
      function Codegen(formatStringOrScope) {
        if (typeof formatStringOrScope !== "string") {
          var source = toString();
          if (codegen.verbose)
            console.log("codegen: " + source);
          source = "return " + source;
          if (formatStringOrScope) {
            var scopeKeys = Object.keys(formatStringOrScope), scopeParams = new Array(scopeKeys.length + 1), scopeValues = new Array(scopeKeys.length), scopeOffset = 0;
            while (scopeOffset < scopeKeys.length) {
              scopeParams[scopeOffset] = scopeKeys[scopeOffset];
              scopeValues[scopeOffset] = formatStringOrScope[scopeKeys[scopeOffset++]];
            }
            scopeParams[scopeOffset] = source;
            return Function.apply(null, scopeParams).apply(null, scopeValues);
          }
          return Function(source)();
        }
        var formatParams = new Array(arguments.length - 1), formatOffset = 0;
        while (formatOffset < formatParams.length)
          formatParams[formatOffset] = arguments[++formatOffset];
        formatOffset = 0;
        formatStringOrScope = formatStringOrScope.replace(/%([%dfijs])/g, function replace($0, $1) {
          var value = formatParams[formatOffset++];
          switch ($1) {
            case "d":
            case "f":
              return String(Number(value));
            case "i":
              return String(Math.floor(value));
            case "j":
              return JSON.stringify(value);
            case "s":
              return String(value);
          }
          return "%";
        });
        if (formatOffset !== formatParams.length)
          throw Error("parameter count mismatch");
        body.push(formatStringOrScope);
        return Codegen;
      }
      function toString(functionNameOverride) {
        return "function " + (functionNameOverride || functionName || "") + "(" + (functionParams && functionParams.join(",") || "") + "){\n  " + body.join("\n  ") + "\n}";
      }
      Codegen.toString = toString;
      return Codegen;
    }
    codegen.verbose = false;
  }
});

// node_modules/@protobufjs/fetch/index.js
var require_fetch = __commonJS({
  "node_modules/@protobufjs/fetch/index.js"(exports2, module2) {
    "use strict";
    module2.exports = fetch;
    var asPromise = require_aspromise();
    var inquire2 = require_inquire();
    var fs = inquire2("fs");
    function fetch(filename, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      } else if (!options)
        options = {};
      if (!callback)
        return asPromise(fetch, this, filename, options);
      if (!options.xhr && fs && fs.readFile)
        return fs.readFile(filename, function fetchReadFileCallback(err, contents) {
          return err && typeof XMLHttpRequest !== "undefined" ? fetch.xhr(filename, options, callback) : err ? callback(err) : callback(null, options.binary ? contents : contents.toString("utf8"));
        });
      return fetch.xhr(filename, options, callback);
    }
    fetch.xhr = function fetch_xhr(filename, options, callback) {
      var xhr = new XMLHttpRequest();
      xhr.onreadystatechange = function fetchOnReadyStateChange() {
        if (xhr.readyState !== 4)
          return void 0;
        if (xhr.status !== 0 && xhr.status !== 200)
          return callback(Error("status " + xhr.status));
        if (options.binary) {
          var buffer = xhr.response;
          if (!buffer) {
            buffer = [];
            for (var i = 0; i < xhr.responseText.length; ++i)
              buffer.push(xhr.responseText.charCodeAt(i) & 255);
          }
          return callback(null, typeof Uint8Array !== "undefined" ? new Uint8Array(buffer) : buffer);
        }
        return callback(null, xhr.responseText);
      };
      if (options.binary) {
        if ("overrideMimeType" in xhr)
          xhr.overrideMimeType("text/plain; charset=x-user-defined");
        xhr.responseType = "arraybuffer";
      }
      xhr.open("GET", filename);
      xhr.send();
    };
  }
});

// node_modules/@protobufjs/path/index.js
var require_path = __commonJS({
  "node_modules/@protobufjs/path/index.js"(exports2) {
    "use strict";
    var path4 = exports2;
    var isAbsolute = (
      /**
       * Tests if the specified path is absolute.
       * @param {string} path Path to test
       * @returns {boolean} `true` if path is absolute
       */
      path4.isAbsolute = function isAbsolute2(path5) {
        return /^(?:\/|\w+:)/.test(path5);
      }
    );
    var normalize = (
      /**
       * Normalizes the specified path.
       * @param {string} path Path to normalize
       * @returns {string} Normalized path
       */
      path4.normalize = function normalize2(path5) {
        path5 = path5.replace(/\\/g, "/").replace(/\/{2,}/g, "/");
        var parts = path5.split("/"), absolute = isAbsolute(path5), prefix = "";
        if (absolute)
          prefix = parts.shift() + "/";
        for (var i = 0; i < parts.length; ) {
          if (parts[i] === "..") {
            if (i > 0 && parts[i - 1] !== "..")
              parts.splice(--i, 2);
            else if (absolute)
              parts.splice(i, 1);
            else
              ++i;
          } else if (parts[i] === ".")
            parts.splice(i, 1);
          else
            ++i;
        }
        return prefix + parts.join("/");
      }
    );
    path4.resolve = function resolve(originPath, includePath, alreadyNormalized) {
      if (!alreadyNormalized)
        includePath = normalize(includePath);
      if (isAbsolute(includePath))
        return includePath;
      if (!alreadyNormalized)
        originPath = normalize(originPath);
      return (originPath = originPath.replace(/(?:\/|^)[^/]+$/, "")).length ? normalize(originPath + "/" + includePath) : includePath;
    };
  }
});

// node_modules/protobufjs/src/types.js
var require_types = __commonJS({
  "node_modules/protobufjs/src/types.js"(exports2) {
    "use strict";
    var types = exports2;
    var util = require_util();
    var s = [
      "double",
      // 0
      "float",
      // 1
      "int32",
      // 2
      "uint32",
      // 3
      "sint32",
      // 4
      "fixed32",
      // 5
      "sfixed32",
      // 6
      "int64",
      // 7
      "uint64",
      // 8
      "sint64",
      // 9
      "fixed64",
      // 10
      "sfixed64",
      // 11
      "bool",
      // 12
      "string",
      // 13
      "bytes"
      // 14
    ];
    function bake(values, offset) {
      var i = 0, o = {};
      offset |= 0;
      while (i < values.length) o[s[i + offset]] = values[i++];
      return o;
    }
    types.basic = bake([
      /* double   */
      1,
      /* float    */
      5,
      /* int32    */
      0,
      /* uint32   */
      0,
      /* sint32   */
      0,
      /* fixed32  */
      5,
      /* sfixed32 */
      5,
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      1,
      /* sfixed64 */
      1,
      /* bool     */
      0,
      /* string   */
      2,
      /* bytes    */
      2
    ]);
    types.defaults = bake([
      /* double   */
      0,
      /* float    */
      0,
      /* int32    */
      0,
      /* uint32   */
      0,
      /* sint32   */
      0,
      /* fixed32  */
      0,
      /* sfixed32 */
      0,
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      0,
      /* sfixed64 */
      0,
      /* bool     */
      false,
      /* string   */
      "",
      /* bytes    */
      util.emptyArray,
      /* message  */
      null
    ]);
    types.long = bake([
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      1,
      /* sfixed64 */
      1
    ], 7);
    types.mapKey = bake([
      /* int32    */
      0,
      /* uint32   */
      0,
      /* sint32   */
      0,
      /* fixed32  */
      5,
      /* sfixed32 */
      5,
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      1,
      /* sfixed64 */
      1,
      /* bool     */
      0,
      /* string   */
      2
    ], 2);
    types.packed = bake([
      /* double   */
      1,
      /* float    */
      5,
      /* int32    */
      0,
      /* uint32   */
      0,
      /* sint32   */
      0,
      /* fixed32  */
      5,
      /* sfixed32 */
      5,
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      1,
      /* sfixed64 */
      1,
      /* bool     */
      0
    ]);
  }
});

// node_modules/protobufjs/src/field.js
var require_field = __commonJS({
  "node_modules/protobufjs/src/field.js"(exports2, module2) {
    "use strict";
    module2.exports = Field;
    var ReflectionObject = require_object();
    ((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = "Field";
    var Enum = require_enum();
    var types = require_types();
    var util = require_util();
    var Type;
    var ruleRe = /^required|optional|repeated$/;
    Field.fromJSON = function fromJSON(name, json) {
      return new Field(name, json.id, json.type, json.rule, json.extend, json.options, json.comment);
    };
    function Field(name, id, type, rule, extend, options, comment) {
      if (util.isObject(rule)) {
        comment = extend;
        options = rule;
        rule = extend = void 0;
      } else if (util.isObject(extend)) {
        comment = options;
        options = extend;
        extend = void 0;
      }
      ReflectionObject.call(this, name, options);
      if (!util.isInteger(id) || id < 0)
        throw TypeError("id must be a non-negative integer");
      if (!util.isString(type))
        throw TypeError("type must be a string");
      if (rule !== void 0 && !ruleRe.test(rule = rule.toString().toLowerCase()))
        throw TypeError("rule must be a string rule");
      if (extend !== void 0 && !util.isString(extend))
        throw TypeError("extend must be a string");
      if (rule === "proto3_optional") {
        rule = "optional";
      }
      this.rule = rule && rule !== "optional" ? rule : void 0;
      this.type = type;
      this.id = id;
      this.extend = extend || void 0;
      this.required = rule === "required";
      this.optional = !this.required;
      this.repeated = rule === "repeated";
      this.map = false;
      this.message = null;
      this.partOf = null;
      this.typeDefault = null;
      this.defaultValue = null;
      this.long = util.Long ? types.long[type] !== void 0 : (
        /* istanbul ignore next */
        false
      );
      this.bytes = type === "bytes";
      this.resolvedType = null;
      this.extensionField = null;
      this.declaringField = null;
      this._packed = null;
      this.comment = comment;
    }
    Object.defineProperty(Field.prototype, "packed", {
      get: function() {
        if (this._packed === null)
          this._packed = this.getOption("packed") !== false;
        return this._packed;
      }
    });
    Field.prototype.setOption = function setOption(name, value, ifNotSet) {
      if (name === "packed")
        this._packed = null;
      return ReflectionObject.prototype.setOption.call(this, name, value, ifNotSet);
    };
    Field.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "rule",
        this.rule !== "optional" && this.rule || void 0,
        "type",
        this.type,
        "id",
        this.id,
        "extend",
        this.extend,
        "options",
        this.options,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    Field.prototype.resolve = function resolve() {
      if (this.resolved)
        return this;
      if ((this.typeDefault = types.defaults[this.type]) === void 0) {
        this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);
        if (this.resolvedType instanceof Type)
          this.typeDefault = null;
        else
          this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]];
      } else if (this.options && this.options.proto3_optional) {
        this.typeDefault = null;
      }
      if (this.options && this.options["default"] != null) {
        this.typeDefault = this.options["default"];
        if (this.resolvedType instanceof Enum && typeof this.typeDefault === "string")
          this.typeDefault = this.resolvedType.values[this.typeDefault];
      }
      if (this.options) {
        if (this.options.packed === true || this.options.packed !== void 0 && this.resolvedType && !(this.resolvedType instanceof Enum))
          delete this.options.packed;
        if (!Object.keys(this.options).length)
          this.options = void 0;
      }
      if (this.long) {
        this.typeDefault = util.Long.fromNumber(this.typeDefault, this.type.charAt(0) === "u");
        if (Object.freeze)
          Object.freeze(this.typeDefault);
      } else if (this.bytes && typeof this.typeDefault === "string") {
        var buf;
        if (util.base64.test(this.typeDefault))
          util.base64.decode(this.typeDefault, buf = util.newBuffer(util.base64.length(this.typeDefault)), 0);
        else
          util.utf8.write(this.typeDefault, buf = util.newBuffer(util.utf8.length(this.typeDefault)), 0);
        this.typeDefault = buf;
      }
      if (this.map)
        this.defaultValue = util.emptyObject;
      else if (this.repeated)
        this.defaultValue = util.emptyArray;
      else
        this.defaultValue = this.typeDefault;
      if (this.parent instanceof Type)
        this.parent.ctor.prototype[this.name] = this.defaultValue;
      return ReflectionObject.prototype.resolve.call(this);
    };
    Field.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {
      if (typeof fieldType === "function")
        fieldType = util.decorateType(fieldType).name;
      else if (fieldType && typeof fieldType === "object")
        fieldType = util.decorateEnum(fieldType).name;
      return function fieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor).add(new Field(fieldName, fieldId, fieldType, fieldRule, { "default": defaultValue }));
      };
    };
    Field._configure = function configure(Type_) {
      Type = Type_;
    };
  }
});

// node_modules/protobufjs/src/oneof.js
var require_oneof = __commonJS({
  "node_modules/protobufjs/src/oneof.js"(exports2, module2) {
    "use strict";
    module2.exports = OneOf;
    var ReflectionObject = require_object();
    ((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = "OneOf";
    var Field = require_field();
    var util = require_util();
    function OneOf(name, fieldNames, options, comment) {
      if (!Array.isArray(fieldNames)) {
        options = fieldNames;
        fieldNames = void 0;
      }
      ReflectionObject.call(this, name, options);
      if (!(fieldNames === void 0 || Array.isArray(fieldNames)))
        throw TypeError("fieldNames must be an Array");
      this.oneof = fieldNames || [];
      this.fieldsArray = [];
      this.comment = comment;
    }
    OneOf.fromJSON = function fromJSON(name, json) {
      return new OneOf(name, json.oneof, json.options, json.comment);
    };
    OneOf.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "options",
        this.options,
        "oneof",
        this.oneof,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    function addFieldsToParent(oneof) {
      if (oneof.parent) {
        for (var i = 0; i < oneof.fieldsArray.length; ++i)
          if (!oneof.fieldsArray[i].parent)
            oneof.parent.add(oneof.fieldsArray[i]);
      }
    }
    OneOf.prototype.add = function add(field) {
      if (!(field instanceof Field))
        throw TypeError("field must be a Field");
      if (field.parent && field.parent !== this.parent)
        field.parent.remove(field);
      this.oneof.push(field.name);
      this.fieldsArray.push(field);
      field.partOf = this;
      addFieldsToParent(this);
      return this;
    };
    OneOf.prototype.remove = function remove(field) {
      if (!(field instanceof Field))
        throw TypeError("field must be a Field");
      var index = this.fieldsArray.indexOf(field);
      if (index < 0)
        throw Error(field + " is not a member of " + this);
      this.fieldsArray.splice(index, 1);
      index = this.oneof.indexOf(field.name);
      if (index > -1)
        this.oneof.splice(index, 1);
      field.partOf = null;
      return this;
    };
    OneOf.prototype.onAdd = function onAdd(parent) {
      ReflectionObject.prototype.onAdd.call(this, parent);
      var self2 = this;
      for (var i = 0; i < this.oneof.length; ++i) {
        var field = parent.get(this.oneof[i]);
        if (field && !field.partOf) {
          field.partOf = self2;
          self2.fieldsArray.push(field);
        }
      }
      addFieldsToParent(this);
    };
    OneOf.prototype.onRemove = function onRemove(parent) {
      for (var i = 0, field; i < this.fieldsArray.length; ++i)
        if ((field = this.fieldsArray[i]).parent)
          field.parent.remove(field);
      ReflectionObject.prototype.onRemove.call(this, parent);
    };
    OneOf.d = function decorateOneOf() {
      var fieldNames = new Array(arguments.length), index = 0;
      while (index < arguments.length)
        fieldNames[index] = arguments[index++];
      return function oneOfDecorator(prototype, oneofName) {
        util.decorateType(prototype.constructor).add(new OneOf(oneofName, fieldNames));
        Object.defineProperty(prototype, oneofName, {
          get: util.oneOfGetter(fieldNames),
          set: util.oneOfSetter(fieldNames)
        });
      };
    };
  }
});

// node_modules/protobufjs/src/namespace.js
var require_namespace = __commonJS({
  "node_modules/protobufjs/src/namespace.js"(exports2, module2) {
    "use strict";
    module2.exports = Namespace;
    var ReflectionObject = require_object();
    ((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = "Namespace";
    var Field = require_field();
    var util = require_util();
    var OneOf = require_oneof();
    var Type;
    var Service;
    var Enum;
    Namespace.fromJSON = function fromJSON(name, json) {
      return new Namespace(name, json.options).addJSON(json.nested);
    };
    function arrayToJSON(array, toJSONOptions) {
      if (!(array && array.length))
        return void 0;
      var obj = {};
      for (var i = 0; i < array.length; ++i)
        obj[array[i].name] = array[i].toJSON(toJSONOptions);
      return obj;
    }
    Namespace.arrayToJSON = arrayToJSON;
    Namespace.isReservedId = function isReservedId(reserved, id) {
      if (reserved) {
        for (var i = 0; i < reserved.length; ++i)
          if (typeof reserved[i] !== "string" && reserved[i][0] <= id && reserved[i][1] > id)
            return true;
      }
      return false;
    };
    Namespace.isReservedName = function isReservedName(reserved, name) {
      if (reserved) {
        for (var i = 0; i < reserved.length; ++i)
          if (reserved[i] === name)
            return true;
      }
      return false;
    };
    function Namespace(name, options) {
      ReflectionObject.call(this, name, options);
      this.nested = void 0;
      this._nestedArray = null;
    }
    function clearCache(namespace) {
      namespace._nestedArray = null;
      return namespace;
    }
    Object.defineProperty(Namespace.prototype, "nestedArray", {
      get: function() {
        return this._nestedArray || (this._nestedArray = util.toArray(this.nested));
      }
    });
    Namespace.prototype.toJSON = function toJSON(toJSONOptions) {
      return util.toObject([
        "options",
        this.options,
        "nested",
        arrayToJSON(this.nestedArray, toJSONOptions)
      ]);
    };
    Namespace.prototype.addJSON = function addJSON(nestedJson) {
      var ns = this;
      if (nestedJson) {
        for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {
          nested = nestedJson[names[i]];
          ns.add(
            // most to least likely
            (nested.fields !== void 0 ? Type.fromJSON : nested.values !== void 0 ? Enum.fromJSON : nested.methods !== void 0 ? Service.fromJSON : nested.id !== void 0 ? Field.fromJSON : Namespace.fromJSON)(names[i], nested)
          );
        }
      }
      return this;
    };
    Namespace.prototype.get = function get(name) {
      return this.nested && this.nested[name] || null;
    };
    Namespace.prototype.getEnum = function getEnum(name) {
      if (this.nested && this.nested[name] instanceof Enum)
        return this.nested[name].values;
      throw Error("no such enum: " + name);
    };
    Namespace.prototype.add = function add(object) {
      if (!(object instanceof Field && object.extend !== void 0 || object instanceof Type || object instanceof OneOf || object instanceof Enum || object instanceof Service || object instanceof Namespace))
        throw TypeError("object must be a valid nested object");
      if (!this.nested)
        this.nested = {};
      else {
        var prev = this.get(object.name);
        if (prev) {
          if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {
            var nested = prev.nestedArray;
            for (var i = 0; i < nested.length; ++i)
              object.add(nested[i]);
            this.remove(prev);
            if (!this.nested)
              this.nested = {};
            object.setOptions(prev.options, true);
          } else
            throw Error("duplicate name '" + object.name + "' in " + this);
        }
      }
      this.nested[object.name] = object;
      object.onAdd(this);
      return clearCache(this);
    };
    Namespace.prototype.remove = function remove(object) {
      if (!(object instanceof ReflectionObject))
        throw TypeError("object must be a ReflectionObject");
      if (object.parent !== this)
        throw Error(object + " is not a member of " + this);
      delete this.nested[object.name];
      if (!Object.keys(this.nested).length)
        this.nested = void 0;
      object.onRemove(this);
      return clearCache(this);
    };
    Namespace.prototype.define = function define(path4, json) {
      if (util.isString(path4))
        path4 = path4.split(".");
      else if (!Array.isArray(path4))
        throw TypeError("illegal path");
      if (path4 && path4.length && path4[0] === "")
        throw Error("path must be relative");
      var ptr = this;
      while (path4.length > 0) {
        var part = path4.shift();
        if (ptr.nested && ptr.nested[part]) {
          ptr = ptr.nested[part];
          if (!(ptr instanceof Namespace))
            throw Error("path conflicts with non-namespace objects");
        } else
          ptr.add(ptr = new Namespace(part));
      }
      if (json)
        ptr.addJSON(json);
      return ptr;
    };
    Namespace.prototype.resolveAll = function resolveAll() {
      var nested = this.nestedArray, i = 0;
      while (i < nested.length)
        if (nested[i] instanceof Namespace)
          nested[i++].resolveAll();
        else
          nested[i++].resolve();
      return this.resolve();
    };
    Namespace.prototype.lookup = function lookup(path4, filterTypes, parentAlreadyChecked) {
      if (typeof filterTypes === "boolean") {
        parentAlreadyChecked = filterTypes;
        filterTypes = void 0;
      } else if (filterTypes && !Array.isArray(filterTypes))
        filterTypes = [filterTypes];
      if (util.isString(path4) && path4.length) {
        if (path4 === ".")
          return this.root;
        path4 = path4.split(".");
      } else if (!path4.length)
        return this;
      if (path4[0] === "")
        return this.root.lookup(path4.slice(1), filterTypes);
      var found = this.get(path4[0]);
      if (found) {
        if (path4.length === 1) {
          if (!filterTypes || filterTypes.indexOf(found.constructor) > -1)
            return found;
        } else if (found instanceof Namespace && (found = found.lookup(path4.slice(1), filterTypes, true)))
          return found;
      } else
        for (var i = 0; i < this.nestedArray.length; ++i)
          if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path4, filterTypes, true)))
            return found;
      if (this.parent === null || parentAlreadyChecked)
        return null;
      return this.parent.lookup(path4, filterTypes);
    };
    Namespace.prototype.lookupType = function lookupType(path4) {
      var found = this.lookup(path4, [Type]);
      if (!found)
        throw Error("no such type: " + path4);
      return found;
    };
    Namespace.prototype.lookupEnum = function lookupEnum(path4) {
      var found = this.lookup(path4, [Enum]);
      if (!found)
        throw Error("no such Enum '" + path4 + "' in " + this);
      return found;
    };
    Namespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path4) {
      var found = this.lookup(path4, [Type, Enum]);
      if (!found)
        throw Error("no such Type or Enum '" + path4 + "' in " + this);
      return found;
    };
    Namespace.prototype.lookupService = function lookupService(path4) {
      var found = this.lookup(path4, [Service]);
      if (!found)
        throw Error("no such Service '" + path4 + "' in " + this);
      return found;
    };
    Namespace._configure = function(Type_, Service_, Enum_) {
      Type = Type_;
      Service = Service_;
      Enum = Enum_;
    };
  }
});

// node_modules/protobufjs/src/mapfield.js
var require_mapfield = __commonJS({
  "node_modules/protobufjs/src/mapfield.js"(exports2, module2) {
    "use strict";
    module2.exports = MapField;
    var Field = require_field();
    ((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = "MapField";
    var types = require_types();
    var util = require_util();
    function MapField(name, id, keyType, type, options, comment) {
      Field.call(this, name, id, type, void 0, void 0, options, comment);
      if (!util.isString(keyType))
        throw TypeError("keyType must be a string");
      this.keyType = keyType;
      this.resolvedKeyType = null;
      this.map = true;
    }
    MapField.fromJSON = function fromJSON(name, json) {
      return new MapField(name, json.id, json.keyType, json.type, json.options, json.comment);
    };
    MapField.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "keyType",
        this.keyType,
        "type",
        this.type,
        "id",
        this.id,
        "extend",
        this.extend,
        "options",
        this.options,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    MapField.prototype.resolve = function resolve() {
      if (this.resolved)
        return this;
      if (types.mapKey[this.keyType] === void 0)
        throw Error("invalid key type: " + this.keyType);
      return Field.prototype.resolve.call(this);
    };
    MapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {
      if (typeof fieldValueType === "function")
        fieldValueType = util.decorateType(fieldValueType).name;
      else if (fieldValueType && typeof fieldValueType === "object")
        fieldValueType = util.decorateEnum(fieldValueType).name;
      return function mapFieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor).add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));
      };
    };
  }
});

// node_modules/protobufjs/src/method.js
var require_method = __commonJS({
  "node_modules/protobufjs/src/method.js"(exports2, module2) {
    "use strict";
    module2.exports = Method;
    var ReflectionObject = require_object();
    ((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = "Method";
    var util = require_util();
    function Method(name, type, requestType, responseType, requestStream, responseStream, options, comment, parsedOptions) {
      if (util.isObject(requestStream)) {
        options = requestStream;
        requestStream = responseStream = void 0;
      } else if (util.isObject(responseStream)) {
        options = responseStream;
        responseStream = void 0;
      }
      if (!(type === void 0 || util.isString(type)))
        throw TypeError("type must be a string");
      if (!util.isString(requestType))
        throw TypeError("requestType must be a string");
      if (!util.isString(responseType))
        throw TypeError("responseType must be a string");
      ReflectionObject.call(this, name, options);
      this.type = type || "rpc";
      this.requestType = requestType;
      this.requestStream = requestStream ? true : void 0;
      this.responseType = responseType;
      this.responseStream = responseStream ? true : void 0;
      this.resolvedRequestType = null;
      this.resolvedResponseType = null;
      this.comment = comment;
      this.parsedOptions = parsedOptions;
    }
    Method.fromJSON = function fromJSON(name, json) {
      return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment, json.parsedOptions);
    };
    Method.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "type",
        this.type !== "rpc" && /* istanbul ignore next */
        this.type || void 0,
        "requestType",
        this.requestType,
        "requestStream",
        this.requestStream,
        "responseType",
        this.responseType,
        "responseStream",
        this.responseStream,
        "options",
        this.options,
        "comment",
        keepComments ? this.comment : void 0,
        "parsedOptions",
        this.parsedOptions
      ]);
    };
    Method.prototype.resolve = function resolve() {
      if (this.resolved)
        return this;
      this.resolvedRequestType = this.parent.lookupType(this.requestType);
      this.resolvedResponseType = this.parent.lookupType(this.responseType);
      return ReflectionObject.prototype.resolve.call(this);
    };
  }
});

// node_modules/protobufjs/src/service.js
var require_service2 = __commonJS({
  "node_modules/protobufjs/src/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service;
    var Namespace = require_namespace();
    ((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = "Service";
    var Method = require_method();
    var util = require_util();
    var rpc = require_rpc();
    function Service(name, options) {
      Namespace.call(this, name, options);
      this.methods = {};
      this._methodsArray = null;
    }
    Service.fromJSON = function fromJSON(name, json) {
      var service = new Service(name, json.options);
      if (json.methods)
        for (var names = Object.keys(json.methods), i = 0; i < names.length; ++i)
          service.add(Method.fromJSON(names[i], json.methods[names[i]]));
      if (json.nested)
        service.addJSON(json.nested);
      service.comment = json.comment;
      return service;
    };
    Service.prototype.toJSON = function toJSON(toJSONOptions) {
      var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "options",
        inherited && inherited.options || void 0,
        "methods",
        Namespace.arrayToJSON(this.methodsArray, toJSONOptions) || /* istanbul ignore next */
        {},
        "nested",
        inherited && inherited.nested || void 0,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    Object.defineProperty(Service.prototype, "methodsArray", {
      get: function() {
        return this._methodsArray || (this._methodsArray = util.toArray(this.methods));
      }
    });
    function clearCache(service) {
      service._methodsArray = null;
      return service;
    }
    Service.prototype.get = function get(name) {
      return this.methods[name] || Namespace.prototype.get.call(this, name);
    };
    Service.prototype.resolveAll = function resolveAll() {
      var methods = this.methodsArray;
      for (var i = 0; i < methods.length; ++i)
        methods[i].resolve();
      return Namespace.prototype.resolve.call(this);
    };
    Service.prototype.add = function add(object) {
      if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);
      if (object instanceof Method) {
        this.methods[object.name] = object;
        object.parent = this;
        return clearCache(this);
      }
      return Namespace.prototype.add.call(this, object);
    };
    Service.prototype.remove = function remove(object) {
      if (object instanceof Method) {
        if (this.methods[object.name] !== object)
          throw Error(object + " is not a member of " + this);
        delete this.methods[object.name];
        object.parent = null;
        return clearCache(this);
      }
      return Namespace.prototype.remove.call(this, object);
    };
    Service.prototype.create = function create(rpcImpl, requestDelimited, responseDelimited) {
      var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);
      for (var i = 0, method; i < /* initializes */
      this.methodsArray.length; ++i) {
        var methodName = util.lcFirst((method = this._methodsArray[i]).resolve().name).replace(/[^$\w_]/g, "");
        rpcService[methodName] = util.codegen(["r", "c"], util.isReserved(methodName) ? methodName + "_" : methodName)("return this.rpcCall(m,q,s,r,c)")({
          m: method,
          q: method.resolvedRequestType.ctor,
          s: method.resolvedResponseType.ctor
        });
      }
      return rpcService;
    };
  }
});

// node_modules/protobufjs/src/message.js
var require_message = __commonJS({
  "node_modules/protobufjs/src/message.js"(exports2, module2) {
    "use strict";
    module2.exports = Message;
    var util = require_minimal();
    function Message(properties) {
      if (properties)
        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          this[keys[i]] = properties[keys[i]];
    }
    Message.create = function create(properties) {
      return this.$type.create(properties);
    };
    Message.encode = function encode(message, writer) {
      return this.$type.encode(message, writer);
    };
    Message.encodeDelimited = function encodeDelimited(message, writer) {
      return this.$type.encodeDelimited(message, writer);
    };
    Message.decode = function decode(reader) {
      return this.$type.decode(reader);
    };
    Message.decodeDelimited = function decodeDelimited(reader) {
      return this.$type.decodeDelimited(reader);
    };
    Message.verify = function verify(message) {
      return this.$type.verify(message);
    };
    Message.fromObject = function fromObject(object) {
      return this.$type.fromObject(object);
    };
    Message.toObject = function toObject(message, options) {
      return this.$type.toObject(message, options);
    };
    Message.prototype.toJSON = function toJSON() {
      return this.$type.toObject(this, util.toJSONOptions);
    };
  }
});

// node_modules/protobufjs/src/decoder.js
var require_decoder = __commonJS({
  "node_modules/protobufjs/src/decoder.js"(exports2, module2) {
    "use strict";
    module2.exports = decoder;
    var Enum = require_enum();
    var types = require_types();
    var util = require_util();
    function missing(field) {
      return "missing required '" + field.name + "'";
    }
    function decoder(mtype) {
      var gen = util.codegen(["r", "l"], mtype.name + "$decode")("if(!(r instanceof Reader))")("r=Reader.create(r)")("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (mtype.fieldsArray.filter(function(field2) {
        return field2.map;
      }).length ? ",k,value" : ""))("while(r.pos<c){")("var t=r.uint32()");
      if (mtype.group) gen("if((t&7)===4)")("break");
      gen("switch(t>>>3){");
      var i = 0;
      for (; i < /* initializes */
      mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(), type = field.resolvedType instanceof Enum ? "int32" : field.type, ref = "m" + util.safeProp(field.name);
        gen("case %i: {", field.id);
        if (field.map) {
          gen("if(%s===util.emptyObject)", ref)("%s={}", ref)("var c2 = r.uint32()+r.pos");
          if (types.defaults[field.keyType] !== void 0) gen("k=%j", types.defaults[field.keyType]);
          else gen("k=null");
          if (types.defaults[type] !== void 0) gen("value=%j", types.defaults[type]);
          else gen("value=null");
          gen("while(r.pos<c2){")("var tag2=r.uint32()")("switch(tag2>>>3){")("case 1: k=r.%s(); break", field.keyType)("case 2:");
          if (types.basic[type] === void 0) gen("value=types[%i].decode(r,r.uint32())", i);
          else gen("value=r.%s()", type);
          gen("break")("default:")("r.skipType(tag2&7)")("break")("}")("}");
          if (types.long[field.keyType] !== void 0) gen('%s[typeof k==="object"?util.longToHash(k):k]=value', ref);
          else gen("%s[k]=value", ref);
        } else if (field.repeated) {
          gen("if(!(%s&&%s.length))", ref, ref)("%s=[]", ref);
          if (types.packed[type] !== void 0) gen("if((t&7)===2){")("var c2=r.uint32()+r.pos")("while(r.pos<c2)")("%s.push(r.%s())", ref, type)("}else");
          if (types.basic[type] === void 0) gen(field.resolvedType.group ? "%s.push(types[%i].decode(r))" : "%s.push(types[%i].decode(r,r.uint32()))", ref, i);
          else gen("%s.push(r.%s())", ref, type);
        } else if (types.basic[type] === void 0) gen(field.resolvedType.group ? "%s=types[%i].decode(r)" : "%s=types[%i].decode(r,r.uint32())", ref, i);
        else gen("%s=r.%s()", ref, type);
        gen("break")("}");
      }
      gen("default:")("r.skipType(t&7)")("break")("}")("}");
      for (i = 0; i < mtype._fieldsArray.length; ++i) {
        var rfield = mtype._fieldsArray[i];
        if (rfield.required) gen("if(!m.hasOwnProperty(%j))", rfield.name)("throw util.ProtocolError(%j,{instance:m})", missing(rfield));
      }
      return gen("return m");
    }
  }
});

// node_modules/protobufjs/src/verifier.js
var require_verifier = __commonJS({
  "node_modules/protobufjs/src/verifier.js"(exports2, module2) {
    "use strict";
    module2.exports = verifier;
    var Enum = require_enum();
    var util = require_util();
    function invalid(field, expected) {
      return field.name + ": " + expected + (field.repeated && expected !== "array" ? "[]" : field.map && expected !== "object" ? "{k:" + field.keyType + "}" : "") + " expected";
    }
    function genVerifyValue(gen, field, fieldIndex, ref) {
      if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) {
          gen("switch(%s){", ref)("default:")("return%j", invalid(field, "enum value"));
          for (var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j) gen("case %i:", field.resolvedType.values[keys[j]]);
          gen("break")("}");
        } else {
          gen("{")("var e=types[%i].verify(%s);", fieldIndex, ref)("if(e)")("return%j+e", field.name + ".")("}");
        }
      } else {
        switch (field.type) {
          case "int32":
          case "uint32":
          case "sint32":
          case "fixed32":
          case "sfixed32":
            gen("if(!util.isInteger(%s))", ref)("return%j", invalid(field, "integer"));
            break;
          case "int64":
          case "uint64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            gen("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", ref, ref, ref, ref)("return%j", invalid(field, "integer|Long"));
            break;
          case "float":
          case "double":
            gen('if(typeof %s!=="number")', ref)("return%j", invalid(field, "number"));
            break;
          case "bool":
            gen('if(typeof %s!=="boolean")', ref)("return%j", invalid(field, "boolean"));
            break;
          case "string":
            gen("if(!util.isString(%s))", ref)("return%j", invalid(field, "string"));
            break;
          case "bytes":
            gen('if(!(%s&&typeof %s.length==="number"||util.isString(%s)))', ref, ref, ref)("return%j", invalid(field, "buffer"));
            break;
        }
      }
      return gen;
    }
    function genVerifyKey(gen, field, ref) {
      switch (field.keyType) {
        case "int32":
        case "uint32":
        case "sint32":
        case "fixed32":
        case "sfixed32":
          gen("if(!util.key32Re.test(%s))", ref)("return%j", invalid(field, "integer key"));
          break;
        case "int64":
        case "uint64":
        case "sint64":
        case "fixed64":
        case "sfixed64":
          gen("if(!util.key64Re.test(%s))", ref)("return%j", invalid(field, "integer|Long key"));
          break;
        case "bool":
          gen("if(!util.key2Re.test(%s))", ref)("return%j", invalid(field, "boolean key"));
          break;
      }
      return gen;
    }
    function verifier(mtype) {
      var gen = util.codegen(["m"], mtype.name + "$verify")('if(typeof m!=="object"||m===null)')("return%j", "object expected");
      var oneofs = mtype.oneofsArray, seenFirstField = {};
      if (oneofs.length) gen("var p={}");
      for (var i = 0; i < /* initializes */
      mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(), ref = "m" + util.safeProp(field.name);
        if (field.optional) gen("if(%s!=null&&m.hasOwnProperty(%j)){", ref, field.name);
        if (field.map) {
          gen("if(!util.isObject(%s))", ref)("return%j", invalid(field, "object"))("var k=Object.keys(%s)", ref)("for(var i=0;i<k.length;++i){");
          genVerifyKey(gen, field, "k[i]");
          genVerifyValue(gen, field, i, ref + "[k[i]]")("}");
        } else if (field.repeated) {
          gen("if(!Array.isArray(%s))", ref)("return%j", invalid(field, "array"))("for(var i=0;i<%s.length;++i){", ref);
          genVerifyValue(gen, field, i, ref + "[i]")("}");
        } else {
          if (field.partOf) {
            var oneofProp = util.safeProp(field.partOf.name);
            if (seenFirstField[field.partOf.name] === 1) gen("if(p%s===1)", oneofProp)("return%j", field.partOf.name + ": multiple values");
            seenFirstField[field.partOf.name] = 1;
            gen("p%s=1", oneofProp);
          }
          genVerifyValue(gen, field, i, ref);
        }
        if (field.optional) gen("}");
      }
      return gen("return null");
    }
  }
});

// node_modules/protobufjs/src/converter.js
var require_converter = __commonJS({
  "node_modules/protobufjs/src/converter.js"(exports2) {
    "use strict";
    var converter = exports2;
    var Enum = require_enum();
    var util = require_util();
    function genValuePartial_fromObject(gen, field, fieldIndex, prop) {
      var defaultAlreadyEmitted = false;
      if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) {
          gen("switch(d%s){", prop);
          for (var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i) {
            if (values[keys[i]] === field.typeDefault && !defaultAlreadyEmitted) {
              gen("default:")('if(typeof(d%s)==="number"){m%s=d%s;break}', prop, prop, prop);
              if (!field.repeated) gen("break");
              defaultAlreadyEmitted = true;
            }
            gen("case%j:", keys[i])("case %i:", values[keys[i]])("m%s=%j", prop, values[keys[i]])("break");
          }
          gen("}");
        } else gen('if(typeof d%s!=="object")', prop)("throw TypeError(%j)", field.fullName + ": object expected")("m%s=types[%i].fromObject(d%s)", prop, fieldIndex, prop);
      } else {
        var isUnsigned = false;
        switch (field.type) {
          case "double":
          case "float":
            gen("m%s=Number(d%s)", prop, prop);
            break;
          case "uint32":
          case "fixed32":
            gen("m%s=d%s>>>0", prop, prop);
            break;
          case "int32":
          case "sint32":
          case "sfixed32":
            gen("m%s=d%s|0", prop, prop);
            break;
          case "uint64":
            isUnsigned = true;
          case "int64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            gen("if(util.Long)")("(m%s=util.Long.fromValue(d%s)).unsigned=%j", prop, prop, isUnsigned)('else if(typeof d%s==="string")', prop)("m%s=parseInt(d%s,10)", prop, prop)('else if(typeof d%s==="number")', prop)("m%s=d%s", prop, prop)('else if(typeof d%s==="object")', prop)("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", prop, prop, prop, isUnsigned ? "true" : "");
            break;
          case "bytes":
            gen('if(typeof d%s==="string")', prop)("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", prop, prop, prop)("else if(d%s.length >= 0)", prop)("m%s=d%s", prop, prop);
            break;
          case "string":
            gen("m%s=String(d%s)", prop, prop);
            break;
          case "bool":
            gen("m%s=Boolean(d%s)", prop, prop);
            break;
        }
      }
      return gen;
    }
    converter.fromObject = function fromObject(mtype) {
      var fields = mtype.fieldsArray;
      var gen = util.codegen(["d"], mtype.name + "$fromObject")("if(d instanceof this.ctor)")("return d");
      if (!fields.length) return gen("return new this.ctor");
      gen("var m=new this.ctor");
      for (var i = 0; i < fields.length; ++i) {
        var field = fields[i].resolve(), prop = util.safeProp(field.name);
        if (field.map) {
          gen("if(d%s){", prop)('if(typeof d%s!=="object")', prop)("throw TypeError(%j)", field.fullName + ": object expected")("m%s={}", prop)("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", prop);
          genValuePartial_fromObject(
            gen,
            field,
            /* not sorted */
            i,
            prop + "[ks[i]]"
          )("}")("}");
        } else if (field.repeated) {
          gen("if(d%s){", prop)("if(!Array.isArray(d%s))", prop)("throw TypeError(%j)", field.fullName + ": array expected")("m%s=[]", prop)("for(var i=0;i<d%s.length;++i){", prop);
          genValuePartial_fromObject(
            gen,
            field,
            /* not sorted */
            i,
            prop + "[i]"
          )("}")("}");
        } else {
          if (!(field.resolvedType instanceof Enum)) gen("if(d%s!=null){", prop);
          genValuePartial_fromObject(
            gen,
            field,
            /* not sorted */
            i,
            prop
          );
          if (!(field.resolvedType instanceof Enum)) gen("}");
        }
      }
      return gen("return m");
    };
    function genValuePartial_toObject(gen, field, fieldIndex, prop) {
      if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) gen("d%s=o.enums===String?(types[%i].values[m%s]===undefined?m%s:types[%i].values[m%s]):m%s", prop, fieldIndex, prop, prop, fieldIndex, prop, prop);
        else gen("d%s=types[%i].toObject(m%s,o)", prop, fieldIndex, prop);
      } else {
        var isUnsigned = false;
        switch (field.type) {
          case "double":
          case "float":
            gen("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", prop, prop, prop, prop);
            break;
          case "uint64":
            isUnsigned = true;
          case "int64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            gen('if(typeof m%s==="number")', prop)("d%s=o.longs===String?String(m%s):m%s", prop, prop, prop)("else")("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", prop, prop, prop, prop, isUnsigned ? "true" : "", prop);
            break;
          case "bytes":
            gen("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", prop, prop, prop, prop, prop);
            break;
          default:
            gen("d%s=m%s", prop, prop);
            break;
        }
      }
      return gen;
    }
    converter.toObject = function toObject(mtype) {
      var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);
      if (!fields.length)
        return util.codegen()("return {}");
      var gen = util.codegen(["m", "o"], mtype.name + "$toObject")("if(!o)")("o={}")("var d={}");
      var repeatedFields = [], mapFields = [], normalFields = [], i = 0;
      for (; i < fields.length; ++i)
        if (!fields[i].partOf)
          (fields[i].resolve().repeated ? repeatedFields : fields[i].map ? mapFields : normalFields).push(fields[i]);
      if (repeatedFields.length) {
        gen("if(o.arrays||o.defaults){");
        for (i = 0; i < repeatedFields.length; ++i) gen("d%s=[]", util.safeProp(repeatedFields[i].name));
        gen("}");
      }
      if (mapFields.length) {
        gen("if(o.objects||o.defaults){");
        for (i = 0; i < mapFields.length; ++i) gen("d%s={}", util.safeProp(mapFields[i].name));
        gen("}");
      }
      if (normalFields.length) {
        gen("if(o.defaults){");
        for (i = 0; i < normalFields.length; ++i) {
          var field = normalFields[i], prop = util.safeProp(field.name);
          if (field.resolvedType instanceof Enum) gen("d%s=o.enums===String?%j:%j", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);
          else if (field.long) gen("if(util.Long){")("var n=new util.Long(%i,%i,%j)", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", prop)("}else")("d%s=o.longs===String?%j:%i", prop, field.typeDefault.toString(), field.typeDefault.toNumber());
          else if (field.bytes) {
            var arrayDefault = "[" + Array.prototype.slice.call(field.typeDefault).join(",") + "]";
            gen("if(o.bytes===String)d%s=%j", prop, String.fromCharCode.apply(String, field.typeDefault))("else{")("d%s=%s", prop, arrayDefault)("if(o.bytes!==Array)d%s=util.newBuffer(d%s)", prop, prop)("}");
          } else gen("d%s=%j", prop, field.typeDefault);
        }
        gen("}");
      }
      var hasKs2 = false;
      for (i = 0; i < fields.length; ++i) {
        var field = fields[i], index = mtype._fieldsArray.indexOf(field), prop = util.safeProp(field.name);
        if (field.map) {
          if (!hasKs2) {
            hasKs2 = true;
            gen("var ks2");
          }
          gen("if(m%s&&(ks2=Object.keys(m%s)).length){", prop, prop)("d%s={}", prop)("for(var j=0;j<ks2.length;++j){");
          genValuePartial_toObject(
            gen,
            field,
            /* sorted */
            index,
            prop + "[ks2[j]]"
          )("}");
        } else if (field.repeated) {
          gen("if(m%s&&m%s.length){", prop, prop)("d%s=[]", prop)("for(var j=0;j<m%s.length;++j){", prop);
          genValuePartial_toObject(
            gen,
            field,
            /* sorted */
            index,
            prop + "[j]"
          )("}");
        } else {
          gen("if(m%s!=null&&m.hasOwnProperty(%j)){", prop, field.name);
          genValuePartial_toObject(
            gen,
            field,
            /* sorted */
            index,
            prop
          );
          if (field.partOf) gen("if(o.oneofs)")("d%s=%j", util.safeProp(field.partOf.name), field.name);
        }
        gen("}");
      }
      return gen("return d");
    };
  }
});

// node_modules/protobufjs/src/wrappers.js
var require_wrappers = __commonJS({
  "node_modules/protobufjs/src/wrappers.js"(exports2) {
    "use strict";
    var wrappers = exports2;
    var Message = require_message();
    wrappers[".google.protobuf.Any"] = {
      fromObject: function(object) {
        if (object && object["@type"]) {
          var name = object["@type"].substring(object["@type"].lastIndexOf("/") + 1);
          var type = this.lookup(name);
          if (type) {
            var type_url = object["@type"].charAt(0) === "." ? object["@type"].slice(1) : object["@type"];
            if (type_url.indexOf("/") === -1) {
              type_url = "/" + type_url;
            }
            return this.create({
              type_url,
              value: type.encode(type.fromObject(object)).finish()
            });
          }
        }
        return this.fromObject(object);
      },
      toObject: function(message, options) {
        var googleApi = "type.googleapis.com/";
        var prefix = "";
        var name = "";
        if (options && options.json && message.type_url && message.value) {
          name = message.type_url.substring(message.type_url.lastIndexOf("/") + 1);
          prefix = message.type_url.substring(0, message.type_url.lastIndexOf("/") + 1);
          var type = this.lookup(name);
          if (type)
            message = type.decode(message.value);
        }
        if (!(message instanceof this.ctor) && message instanceof Message) {
          var object = message.$type.toObject(message, options);
          var messageName = message.$type.fullName[0] === "." ? message.$type.fullName.slice(1) : message.$type.fullName;
          if (prefix === "") {
            prefix = googleApi;
          }
          name = prefix + messageName;
          object["@type"] = name;
          return object;
        }
        return this.toObject(message, options);
      }
    };
  }
});

// node_modules/protobufjs/src/type.js
var require_type = __commonJS({
  "node_modules/protobufjs/src/type.js"(exports2, module2) {
    "use strict";
    module2.exports = Type;
    var Namespace = require_namespace();
    ((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = "Type";
    var Enum = require_enum();
    var OneOf = require_oneof();
    var Field = require_field();
    var MapField = require_mapfield();
    var Service = require_service2();
    var Message = require_message();
    var Reader = require_reader();
    var Writer = require_writer();
    var util = require_util();
    var encoder = require_encoder();
    var decoder = require_decoder();
    var verifier = require_verifier();
    var converter = require_converter();
    var wrappers = require_wrappers();
    function Type(name, options) {
      Namespace.call(this, name, options);
      this.fields = {};
      this.oneofs = void 0;
      this.extensions = void 0;
      this.reserved = void 0;
      this.group = void 0;
      this._fieldsById = null;
      this._fieldsArray = null;
      this._oneofsArray = null;
      this._ctor = null;
    }
    Object.defineProperties(Type.prototype, {
      /**
       * Message fields by id.
       * @name Type#fieldsById
       * @type {Object.<number,Field>}
       * @readonly
       */
      fieldsById: {
        get: function() {
          if (this._fieldsById)
            return this._fieldsById;
          this._fieldsById = {};
          for (var names = Object.keys(this.fields), i = 0; i < names.length; ++i) {
            var field = this.fields[names[i]], id = field.id;
            if (this._fieldsById[id])
              throw Error("duplicate id " + id + " in " + this);
            this._fieldsById[id] = field;
          }
          return this._fieldsById;
        }
      },
      /**
       * Fields of this message as an array for iteration.
       * @name Type#fieldsArray
       * @type {Field[]}
       * @readonly
       */
      fieldsArray: {
        get: function() {
          return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));
        }
      },
      /**
       * Oneofs of this message as an array for iteration.
       * @name Type#oneofsArray
       * @type {OneOf[]}
       * @readonly
       */
      oneofsArray: {
        get: function() {
          return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));
        }
      },
      /**
       * The registered constructor, if any registered, otherwise a generic constructor.
       * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.
       * @name Type#ctor
       * @type {Constructor<{}>}
       */
      ctor: {
        get: function() {
          return this._ctor || (this.ctor = Type.generateConstructor(this)());
        },
        set: function(ctor) {
          var prototype = ctor.prototype;
          if (!(prototype instanceof Message)) {
            (ctor.prototype = new Message()).constructor = ctor;
            util.merge(ctor.prototype, prototype);
          }
          ctor.$type = ctor.prototype.$type = this;
          util.merge(ctor, Message, true);
          this._ctor = ctor;
          var i = 0;
          for (; i < /* initializes */
          this.fieldsArray.length; ++i)
            this._fieldsArray[i].resolve();
          var ctorProperties = {};
          for (i = 0; i < /* initializes */
          this.oneofsArray.length; ++i)
            ctorProperties[this._oneofsArray[i].resolve().name] = {
              get: util.oneOfGetter(this._oneofsArray[i].oneof),
              set: util.oneOfSetter(this._oneofsArray[i].oneof)
            };
          if (i)
            Object.defineProperties(ctor.prototype, ctorProperties);
        }
      }
    });
    Type.generateConstructor = function generateConstructor(mtype) {
      var gen = util.codegen(["p"], mtype.name);
      for (var i = 0, field; i < mtype.fieldsArray.length; ++i)
        if ((field = mtype._fieldsArray[i]).map) gen("this%s={}", util.safeProp(field.name));
        else if (field.repeated) gen("this%s=[]", util.safeProp(field.name));
      return gen("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)")("this[ks[i]]=p[ks[i]]");
    };
    function clearCache(type) {
      type._fieldsById = type._fieldsArray = type._oneofsArray = null;
      delete type.encode;
      delete type.decode;
      delete type.verify;
      return type;
    }
    Type.fromJSON = function fromJSON(name, json) {
      var type = new Type(name, json.options);
      type.extensions = json.extensions;
      type.reserved = json.reserved;
      var names = Object.keys(json.fields), i = 0;
      for (; i < names.length; ++i)
        type.add(
          (typeof json.fields[names[i]].keyType !== "undefined" ? MapField.fromJSON : Field.fromJSON)(names[i], json.fields[names[i]])
        );
      if (json.oneofs)
        for (names = Object.keys(json.oneofs), i = 0; i < names.length; ++i)
          type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));
      if (json.nested)
        for (names = Object.keys(json.nested), i = 0; i < names.length; ++i) {
          var nested = json.nested[names[i]];
          type.add(
            // most to least likely
            (nested.id !== void 0 ? Field.fromJSON : nested.fields !== void 0 ? Type.fromJSON : nested.values !== void 0 ? Enum.fromJSON : nested.methods !== void 0 ? Service.fromJSON : Namespace.fromJSON)(names[i], nested)
          );
        }
      if (json.extensions && json.extensions.length)
        type.extensions = json.extensions;
      if (json.reserved && json.reserved.length)
        type.reserved = json.reserved;
      if (json.group)
        type.group = true;
      if (json.comment)
        type.comment = json.comment;
      return type;
    };
    Type.prototype.toJSON = function toJSON(toJSONOptions) {
      var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "options",
        inherited && inherited.options || void 0,
        "oneofs",
        Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),
        "fields",
        Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) {
          return !obj.declaringField;
        }), toJSONOptions) || {},
        "extensions",
        this.extensions && this.extensions.length ? this.extensions : void 0,
        "reserved",
        this.reserved && this.reserved.length ? this.reserved : void 0,
        "group",
        this.group || void 0,
        "nested",
        inherited && inherited.nested || void 0,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    Type.prototype.resolveAll = function resolveAll() {
      var fields = this.fieldsArray, i = 0;
      while (i < fields.length)
        fields[i++].resolve();
      var oneofs = this.oneofsArray;
      i = 0;
      while (i < oneofs.length)
        oneofs[i++].resolve();
      return Namespace.prototype.resolveAll.call(this);
    };
    Type.prototype.get = function get(name) {
      return this.fields[name] || this.oneofs && this.oneofs[name] || this.nested && this.nested[name] || null;
    };
    Type.prototype.add = function add(object) {
      if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);
      if (object instanceof Field && object.extend === void 0) {
        if (this._fieldsById ? (
          /* istanbul ignore next */
          this._fieldsById[object.id]
        ) : this.fieldsById[object.id])
          throw Error("duplicate id " + object.id + " in " + this);
        if (this.isReservedId(object.id))
          throw Error("id " + object.id + " is reserved in " + this);
        if (this.isReservedName(object.name))
          throw Error("name '" + object.name + "' is reserved in " + this);
        if (object.parent)
          object.parent.remove(object);
        this.fields[object.name] = object;
        object.message = this;
        object.onAdd(this);
        return clearCache(this);
      }
      if (object instanceof OneOf) {
        if (!this.oneofs)
          this.oneofs = {};
        this.oneofs[object.name] = object;
        object.onAdd(this);
        return clearCache(this);
      }
      return Namespace.prototype.add.call(this, object);
    };
    Type.prototype.remove = function remove(object) {
      if (object instanceof Field && object.extend === void 0) {
        if (!this.fields || this.fields[object.name] !== object)
          throw Error(object + " is not a member of " + this);
        delete this.fields[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
      }
      if (object instanceof OneOf) {
        if (!this.oneofs || this.oneofs[object.name] !== object)
          throw Error(object + " is not a member of " + this);
        delete this.oneofs[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
      }
      return Namespace.prototype.remove.call(this, object);
    };
    Type.prototype.isReservedId = function isReservedId(id) {
      return Namespace.isReservedId(this.reserved, id);
    };
    Type.prototype.isReservedName = function isReservedName(name) {
      return Namespace.isReservedName(this.reserved, name);
    };
    Type.prototype.create = function create(properties) {
      return new this.ctor(properties);
    };
    Type.prototype.setup = function setup() {
      var fullName = this.fullName, types = [];
      for (var i = 0; i < /* initializes */
      this.fieldsArray.length; ++i)
        types.push(this._fieldsArray[i].resolve().resolvedType);
      this.encode = encoder(this)({
        Writer,
        types,
        util
      });
      this.decode = decoder(this)({
        Reader,
        types,
        util
      });
      this.verify = verifier(this)({
        types,
        util
      });
      this.fromObject = converter.fromObject(this)({
        types,
        util
      });
      this.toObject = converter.toObject(this)({
        types,
        util
      });
      var wrapper = wrappers[fullName];
      if (wrapper) {
        var originalThis = Object.create(this);
        originalThis.fromObject = this.fromObject;
        this.fromObject = wrapper.fromObject.bind(originalThis);
        originalThis.toObject = this.toObject;
        this.toObject = wrapper.toObject.bind(originalThis);
      }
      return this;
    };
    Type.prototype.encode = function encode_setup(message, writer) {
      return this.setup().encode(message, writer);
    };
    Type.prototype.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
    };
    Type.prototype.decode = function decode_setup(reader, length) {
      return this.setup().decode(reader, length);
    };
    Type.prototype.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof Reader))
        reader = Reader.create(reader);
      return this.decode(reader, reader.uint32());
    };
    Type.prototype.verify = function verify_setup(message) {
      return this.setup().verify(message);
    };
    Type.prototype.fromObject = function fromObject(object) {
      return this.setup().fromObject(object);
    };
    Type.prototype.toObject = function toObject(message, options) {
      return this.setup().toObject(message, options);
    };
    Type.d = function decorateType(typeName) {
      return function typeDecorator(target) {
        util.decorateType(target, typeName);
      };
    };
  }
});

// node_modules/protobufjs/src/root.js
var require_root = __commonJS({
  "node_modules/protobufjs/src/root.js"(exports2, module2) {
    "use strict";
    module2.exports = Root;
    var Namespace = require_namespace();
    ((Root.prototype = Object.create(Namespace.prototype)).constructor = Root).className = "Root";
    var Field = require_field();
    var Enum = require_enum();
    var OneOf = require_oneof();
    var util = require_util();
    var Type;
    var parse;
    var common;
    function Root(options) {
      Namespace.call(this, "", options);
      this.deferred = [];
      this.files = [];
    }
    Root.fromJSON = function fromJSON(json, root) {
      if (!root)
        root = new Root();
      if (json.options)
        root.setOptions(json.options);
      return root.addJSON(json.nested);
    };
    Root.prototype.resolvePath = util.path.resolve;
    Root.prototype.fetch = util.fetch;
    function SYNC() {
    }
    Root.prototype.load = function load(filename, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = void 0;
      }
      var self2 = this;
      if (!callback)
        return util.asPromise(load, self2, filename, options);
      var sync = callback === SYNC;
      function finish(err, root) {
        if (!callback)
          return;
        if (sync)
          throw err;
        var cb = callback;
        callback = null;
        cb(err, root);
      }
      function getBundledFileName(filename2) {
        var idx = filename2.lastIndexOf("google/protobuf/");
        if (idx > -1) {
          var altname = filename2.substring(idx);
          if (altname in common) return altname;
        }
        return null;
      }
      function process2(filename2, source) {
        try {
          if (util.isString(source) && source.charAt(0) === "{")
            source = JSON.parse(source);
          if (!util.isString(source))
            self2.setOptions(source.options).addJSON(source.nested);
          else {
            parse.filename = filename2;
            var parsed = parse(source, self2, options), resolved2, i2 = 0;
            if (parsed.imports) {
              for (; i2 < parsed.imports.length; ++i2)
                if (resolved2 = getBundledFileName(parsed.imports[i2]) || self2.resolvePath(filename2, parsed.imports[i2]))
                  fetch(resolved2);
            }
            if (parsed.weakImports) {
              for (i2 = 0; i2 < parsed.weakImports.length; ++i2)
                if (resolved2 = getBundledFileName(parsed.weakImports[i2]) || self2.resolvePath(filename2, parsed.weakImports[i2]))
                  fetch(resolved2, true);
            }
          }
        } catch (err) {
          finish(err);
        }
        if (!sync && !queued)
          finish(null, self2);
      }
      function fetch(filename2, weak) {
        filename2 = getBundledFileName(filename2) || filename2;
        if (self2.files.indexOf(filename2) > -1)
          return;
        self2.files.push(filename2);
        if (filename2 in common) {
          if (sync)
            process2(filename2, common[filename2]);
          else {
            ++queued;
            setTimeout(function() {
              --queued;
              process2(filename2, common[filename2]);
            });
          }
          return;
        }
        if (sync) {
          var source;
          try {
            source = util.fs.readFileSync(filename2).toString("utf8");
          } catch (err) {
            if (!weak)
              finish(err);
            return;
          }
          process2(filename2, source);
        } else {
          ++queued;
          self2.fetch(filename2, function(err, source2) {
            --queued;
            if (!callback)
              return;
            if (err) {
              if (!weak)
                finish(err);
              else if (!queued)
                finish(null, self2);
              return;
            }
            process2(filename2, source2);
          });
        }
      }
      var queued = 0;
      if (util.isString(filename))
        filename = [filename];
      for (var i = 0, resolved; i < filename.length; ++i)
        if (resolved = self2.resolvePath("", filename[i]))
          fetch(resolved);
      if (sync)
        return self2;
      if (!queued)
        finish(null, self2);
      return void 0;
    };
    Root.prototype.loadSync = function loadSync(filename, options) {
      if (!util.isNode)
        throw Error("not supported");
      return this.load(filename, options, SYNC);
    };
    Root.prototype.resolveAll = function resolveAll() {
      if (this.deferred.length)
        throw Error("unresolvable extensions: " + this.deferred.map(function(field) {
          return "'extend " + field.extend + "' in " + field.parent.fullName;
        }).join(", "));
      return Namespace.prototype.resolveAll.call(this);
    };
    var exposeRe = /^[A-Z]/;
    function tryHandleExtension(root, field) {
      var extendedType = field.parent.lookup(field.extend);
      if (extendedType) {
        var sisterField = new Field(field.fullName, field.id, field.type, field.rule, void 0, field.options);
        if (extendedType.get(sisterField.name)) {
          return true;
        }
        sisterField.declaringField = field;
        field.extensionField = sisterField;
        extendedType.add(sisterField);
        return true;
      }
      return false;
    }
    Root.prototype._handleAdd = function _handleAdd(object) {
      if (object instanceof Field) {
        if (
          /* an extension field (implies not part of a oneof) */
          object.extend !== void 0 && /* not already handled */
          !object.extensionField
        ) {
          if (!tryHandleExtension(this, object))
            this.deferred.push(object);
        }
      } else if (object instanceof Enum) {
        if (exposeRe.test(object.name))
          object.parent[object.name] = object.values;
      } else if (!(object instanceof OneOf)) {
        if (object instanceof Type)
          for (var i = 0; i < this.deferred.length; )
            if (tryHandleExtension(this, this.deferred[i]))
              this.deferred.splice(i, 1);
            else
              ++i;
        for (var j = 0; j < /* initializes */
        object.nestedArray.length; ++j)
          this._handleAdd(object._nestedArray[j]);
        if (exposeRe.test(object.name))
          object.parent[object.name] = object;
      }
    };
    Root.prototype._handleRemove = function _handleRemove(object) {
      if (object instanceof Field) {
        if (
          /* an extension field */
          object.extend !== void 0
        ) {
          if (
            /* already handled */
            object.extensionField
          ) {
            object.extensionField.parent.remove(object.extensionField);
            object.extensionField = null;
          } else {
            var index = this.deferred.indexOf(object);
            if (index > -1)
              this.deferred.splice(index, 1);
          }
        }
      } else if (object instanceof Enum) {
        if (exposeRe.test(object.name))
          delete object.parent[object.name];
      } else if (object instanceof Namespace) {
        for (var i = 0; i < /* initializes */
        object.nestedArray.length; ++i)
          this._handleRemove(object._nestedArray[i]);
        if (exposeRe.test(object.name))
          delete object.parent[object.name];
      }
    };
    Root._configure = function(Type_, parse_, common_) {
      Type = Type_;
      parse = parse_;
      common = common_;
    };
  }
});

// node_modules/protobufjs/src/util.js
var require_util = __commonJS({
  "node_modules/protobufjs/src/util.js"(exports2, module2) {
    "use strict";
    var util = module2.exports = require_minimal();
    var roots = require_roots();
    var Type;
    var Enum;
    util.codegen = require_codegen();
    util.fetch = require_fetch();
    util.path = require_path();
    util.fs = util.inquire("fs");
    util.toArray = function toArray(object) {
      if (object) {
        var keys = Object.keys(object), array = new Array(keys.length), index = 0;
        while (index < keys.length)
          array[index] = object[keys[index++]];
        return array;
      }
      return [];
    };
    util.toObject = function toObject(array) {
      var object = {}, index = 0;
      while (index < array.length) {
        var key = array[index++], val = array[index++];
        if (val !== void 0)
          object[key] = val;
      }
      return object;
    };
    var safePropBackslashRe = /\\/g;
    var safePropQuoteRe = /"/g;
    util.isReserved = function isReserved(name) {
      return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);
    };
    util.safeProp = function safeProp(prop) {
      if (!/^[$\w_]+$/.test(prop) || util.isReserved(prop))
        return '["' + prop.replace(safePropBackslashRe, "\\\\").replace(safePropQuoteRe, '\\"') + '"]';
      return "." + prop;
    };
    util.ucFirst = function ucFirst(str) {
      return str.charAt(0).toUpperCase() + str.substring(1);
    };
    var camelCaseRe = /_([a-z])/g;
    util.camelCase = function camelCase(str) {
      return str.substring(0, 1) + str.substring(1).replace(camelCaseRe, function($0, $1) {
        return $1.toUpperCase();
      });
    };
    util.compareFieldsById = function compareFieldsById(a, b) {
      return a.id - b.id;
    };
    util.decorateType = function decorateType(ctor, typeName) {
      if (ctor.$type) {
        if (typeName && ctor.$type.name !== typeName) {
          util.decorateRoot.remove(ctor.$type);
          ctor.$type.name = typeName;
          util.decorateRoot.add(ctor.$type);
        }
        return ctor.$type;
      }
      if (!Type)
        Type = require_type();
      var type = new Type(typeName || ctor.name);
      util.decorateRoot.add(type);
      type.ctor = ctor;
      Object.defineProperty(ctor, "$type", { value: type, enumerable: false });
      Object.defineProperty(ctor.prototype, "$type", { value: type, enumerable: false });
      return type;
    };
    var decorateEnumIndex = 0;
    util.decorateEnum = function decorateEnum(object) {
      if (object.$type)
        return object.$type;
      if (!Enum)
        Enum = require_enum();
      var enm = new Enum("Enum" + decorateEnumIndex++, object);
      util.decorateRoot.add(enm);
      Object.defineProperty(object, "$type", { value: enm, enumerable: false });
      return enm;
    };
    util.setProperty = function setProperty(dst, path4, value) {
      function setProp(dst2, path5, value2) {
        var part = path5.shift();
        if (part === "__proto__" || part === "prototype") {
          return dst2;
        }
        if (path5.length > 0) {
          dst2[part] = setProp(dst2[part] || {}, path5, value2);
        } else {
          var prevValue = dst2[part];
          if (prevValue)
            value2 = [].concat(prevValue).concat(value2);
          dst2[part] = value2;
        }
        return dst2;
      }
      if (typeof dst !== "object")
        throw TypeError("dst must be an object");
      if (!path4)
        throw TypeError("path must be specified");
      path4 = path4.split(".");
      return setProp(dst, path4, value);
    };
    Object.defineProperty(util, "decorateRoot", {
      get: function() {
        return roots["decorated"] || (roots["decorated"] = new (require_root())());
      }
    });
  }
});

// node_modules/protobufjs/src/object.js
var require_object = __commonJS({
  "node_modules/protobufjs/src/object.js"(exports2, module2) {
    "use strict";
    module2.exports = ReflectionObject;
    ReflectionObject.className = "ReflectionObject";
    var util = require_util();
    var Root;
    function ReflectionObject(name, options) {
      if (!util.isString(name))
        throw TypeError("name must be a string");
      if (options && !util.isObject(options))
        throw TypeError("options must be an object");
      this.options = options;
      this.parsedOptions = null;
      this.name = name;
      this.parent = null;
      this.resolved = false;
      this.comment = null;
      this.filename = null;
    }
    Object.defineProperties(ReflectionObject.prototype, {
      /**
       * Reference to the root namespace.
       * @name ReflectionObject#root
       * @type {Root}
       * @readonly
       */
      root: {
        get: function() {
          var ptr = this;
          while (ptr.parent !== null)
            ptr = ptr.parent;
          return ptr;
        }
      },
      /**
       * Full name including leading dot.
       * @name ReflectionObject#fullName
       * @type {string}
       * @readonly
       */
      fullName: {
        get: function() {
          var path4 = [this.name], ptr = this.parent;
          while (ptr) {
            path4.unshift(ptr.name);
            ptr = ptr.parent;
          }
          return path4.join(".");
        }
      }
    });
    ReflectionObject.prototype.toJSON = /* istanbul ignore next */
    function toJSON() {
      throw Error();
    };
    ReflectionObject.prototype.onAdd = function onAdd(parent) {
      if (this.parent && this.parent !== parent)
        this.parent.remove(this);
      this.parent = parent;
      this.resolved = false;
      var root = parent.root;
      if (root instanceof Root)
        root._handleAdd(this);
    };
    ReflectionObject.prototype.onRemove = function onRemove(parent) {
      var root = parent.root;
      if (root instanceof Root)
        root._handleRemove(this);
      this.parent = null;
      this.resolved = false;
    };
    ReflectionObject.prototype.resolve = function resolve() {
      if (this.resolved)
        return this;
      if (this.root instanceof Root)
        this.resolved = true;
      return this;
    };
    ReflectionObject.prototype.getOption = function getOption(name) {
      if (this.options)
        return this.options[name];
      return void 0;
    };
    ReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {
      if (!ifNotSet || !this.options || this.options[name] === void 0)
        (this.options || (this.options = {}))[name] = value;
      return this;
    };
    ReflectionObject.prototype.setParsedOption = function setParsedOption(name, value, propName) {
      if (!this.parsedOptions) {
        this.parsedOptions = [];
      }
      var parsedOptions = this.parsedOptions;
      if (propName) {
        var opt = parsedOptions.find(function(opt2) {
          return Object.prototype.hasOwnProperty.call(opt2, name);
        });
        if (opt) {
          var newValue = opt[name];
          util.setProperty(newValue, propName, value);
        } else {
          opt = {};
          opt[name] = util.setProperty({}, propName, value);
          parsedOptions.push(opt);
        }
      } else {
        var newOpt = {};
        newOpt[name] = value;
        parsedOptions.push(newOpt);
      }
      return this;
    };
    ReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {
      if (options)
        for (var keys = Object.keys(options), i = 0; i < keys.length; ++i)
          this.setOption(keys[i], options[keys[i]], ifNotSet);
      return this;
    };
    ReflectionObject.prototype.toString = function toString() {
      var className = this.constructor.className, fullName = this.fullName;
      if (fullName.length)
        return className + " " + fullName;
      return className;
    };
    ReflectionObject._configure = function(Root_) {
      Root = Root_;
    };
  }
});

// node_modules/protobufjs/src/enum.js
var require_enum = __commonJS({
  "node_modules/protobufjs/src/enum.js"(exports2, module2) {
    "use strict";
    module2.exports = Enum;
    var ReflectionObject = require_object();
    ((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = "Enum";
    var Namespace = require_namespace();
    var util = require_util();
    function Enum(name, values, options, comment, comments, valuesOptions) {
      ReflectionObject.call(this, name, options);
      if (values && typeof values !== "object")
        throw TypeError("values must be an object");
      this.valuesById = {};
      this.values = Object.create(this.valuesById);
      this.comment = comment;
      this.comments = comments || {};
      this.valuesOptions = valuesOptions;
      this.reserved = void 0;
      if (values) {
        for (var keys = Object.keys(values), i = 0; i < keys.length; ++i)
          if (typeof values[keys[i]] === "number")
            this.valuesById[this.values[keys[i]] = values[keys[i]]] = keys[i];
      }
    }
    Enum.fromJSON = function fromJSON(name, json) {
      var enm = new Enum(name, json.values, json.options, json.comment, json.comments);
      enm.reserved = json.reserved;
      return enm;
    };
    Enum.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "options",
        this.options,
        "valuesOptions",
        this.valuesOptions,
        "values",
        this.values,
        "reserved",
        this.reserved && this.reserved.length ? this.reserved : void 0,
        "comment",
        keepComments ? this.comment : void 0,
        "comments",
        keepComments ? this.comments : void 0
      ]);
    };
    Enum.prototype.add = function add(name, id, comment, options) {
      if (!util.isString(name))
        throw TypeError("name must be a string");
      if (!util.isInteger(id))
        throw TypeError("id must be an integer");
      if (this.values[name] !== void 0)
        throw Error("duplicate name '" + name + "' in " + this);
      if (this.isReservedId(id))
        throw Error("id " + id + " is reserved in " + this);
      if (this.isReservedName(name))
        throw Error("name '" + name + "' is reserved in " + this);
      if (this.valuesById[id] !== void 0) {
        if (!(this.options && this.options.allow_alias))
          throw Error("duplicate id " + id + " in " + this);
        this.values[name] = id;
      } else
        this.valuesById[this.values[name] = id] = name;
      if (options) {
        if (this.valuesOptions === void 0)
          this.valuesOptions = {};
        this.valuesOptions[name] = options || null;
      }
      this.comments[name] = comment || null;
      return this;
    };
    Enum.prototype.remove = function remove(name) {
      if (!util.isString(name))
        throw TypeError("name must be a string");
      var val = this.values[name];
      if (val == null)
        throw Error("name '" + name + "' does not exist in " + this);
      delete this.valuesById[val];
      delete this.values[name];
      delete this.comments[name];
      if (this.valuesOptions)
        delete this.valuesOptions[name];
      return this;
    };
    Enum.prototype.isReservedId = function isReservedId(id) {
      return Namespace.isReservedId(this.reserved, id);
    };
    Enum.prototype.isReservedName = function isReservedName(name) {
      return Namespace.isReservedName(this.reserved, name);
    };
  }
});

// node_modules/protobufjs/src/encoder.js
var require_encoder = __commonJS({
  "node_modules/protobufjs/src/encoder.js"(exports2, module2) {
    "use strict";
    module2.exports = encoder;
    var Enum = require_enum();
    var types = require_types();
    var util = require_util();
    function genTypePartial(gen, field, fieldIndex, ref) {
      return field.resolvedType.group ? gen("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0) : gen("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", fieldIndex, ref, (field.id << 3 | 2) >>> 0);
    }
    function encoder(mtype) {
      var gen = util.codegen(["m", "w"], mtype.name + "$encode")("if(!w)")("w=Writer.create()");
      var i, ref;
      var fields = (
        /* initializes */
        mtype.fieldsArray.slice().sort(util.compareFieldsById)
      );
      for (var i = 0; i < fields.length; ++i) {
        var field = fields[i].resolve(), index = mtype._fieldsArray.indexOf(field), type = field.resolvedType instanceof Enum ? "int32" : field.type, wireType = types.basic[type];
        ref = "m" + util.safeProp(field.name);
        if (field.map) {
          gen("if(%s!=null&&Object.hasOwnProperty.call(m,%j)){", ref, field.name)("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", ref)("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);
          if (wireType === void 0) gen("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", index, ref);
          else gen(".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | wireType, type, ref);
          gen("}")("}");
        } else if (field.repeated) {
          gen("if(%s!=null&&%s.length){", ref, ref);
          if (field.packed && types.packed[type] !== void 0) {
            gen("w.uint32(%i).fork()", (field.id << 3 | 2) >>> 0)("for(var i=0;i<%s.length;++i)", ref)("w.%s(%s[i])", type, ref)("w.ldelim()");
          } else {
            gen("for(var i=0;i<%s.length;++i)", ref);
            if (wireType === void 0)
              genTypePartial(gen, field, index, ref + "[i]");
            else gen("w.uint32(%i).%s(%s[i])", (field.id << 3 | wireType) >>> 0, type, ref);
          }
          gen("}");
        } else {
          if (field.optional) gen("if(%s!=null&&Object.hasOwnProperty.call(m,%j))", ref, field.name);
          if (wireType === void 0)
            genTypePartial(gen, field, index, ref);
          else gen("w.uint32(%i).%s(%s)", (field.id << 3 | wireType) >>> 0, type, ref);
        }
      }
      return gen("return w");
    }
  }
});

// node_modules/protobufjs/src/index-light.js
var require_index_light = __commonJS({
  "node_modules/protobufjs/src/index-light.js"(exports2, module2) {
    "use strict";
    var protobuf = module2.exports = require_index_minimal();
    protobuf.build = "light";
    function load(filename, root, callback) {
      if (typeof root === "function") {
        callback = root;
        root = new protobuf.Root();
      } else if (!root)
        root = new protobuf.Root();
      return root.load(filename, callback);
    }
    protobuf.load = load;
    function loadSync(filename, root) {
      if (!root)
        root = new protobuf.Root();
      return root.loadSync(filename);
    }
    protobuf.loadSync = loadSync;
    protobuf.encoder = require_encoder();
    protobuf.decoder = require_decoder();
    protobuf.verifier = require_verifier();
    protobuf.converter = require_converter();
    protobuf.ReflectionObject = require_object();
    protobuf.Namespace = require_namespace();
    protobuf.Root = require_root();
    protobuf.Enum = require_enum();
    protobuf.Type = require_type();
    protobuf.Field = require_field();
    protobuf.OneOf = require_oneof();
    protobuf.MapField = require_mapfield();
    protobuf.Service = require_service2();
    protobuf.Method = require_method();
    protobuf.Message = require_message();
    protobuf.wrappers = require_wrappers();
    protobuf.types = require_types();
    protobuf.util = require_util();
    protobuf.ReflectionObject._configure(protobuf.Root);
    protobuf.Namespace._configure(protobuf.Type, protobuf.Service, protobuf.Enum);
    protobuf.Root._configure(protobuf.Type);
    protobuf.Field._configure(protobuf.Type);
  }
});

// node_modules/protobufjs/src/tokenize.js
var require_tokenize = __commonJS({
  "node_modules/protobufjs/src/tokenize.js"(exports2, module2) {
    "use strict";
    module2.exports = tokenize;
    var delimRe = /[\s{}=;:[\],'"()<>]/g;
    var stringDoubleRe = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g;
    var stringSingleRe = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g;
    var setCommentRe = /^ *[*/]+ */;
    var setCommentAltRe = /^\s*\*?\/*/;
    var setCommentSplitRe = /\n/g;
    var whitespaceRe = /\s/;
    var unescapeRe = /\\(.?)/g;
    var unescapeMap = {
      "0": "\0",
      "r": "\r",
      "n": "\n",
      "t": "	"
    };
    function unescape(str) {
      return str.replace(unescapeRe, function($0, $1) {
        switch ($1) {
          case "\\":
          case "":
            return $1;
          default:
            return unescapeMap[$1] || "";
        }
      });
    }
    tokenize.unescape = unescape;
    function tokenize(source, alternateCommentMode) {
      source = source.toString();
      var offset = 0, length = source.length, line = 1, lastCommentLine = 0, comments = {};
      var stack = [];
      var stringDelim = null;
      function illegal(subject) {
        return Error("illegal " + subject + " (line " + line + ")");
      }
      function readString() {
        var re = stringDelim === "'" ? stringSingleRe : stringDoubleRe;
        re.lastIndex = offset - 1;
        var match = re.exec(source);
        if (!match)
          throw illegal("string");
        offset = re.lastIndex;
        push(stringDelim);
        stringDelim = null;
        return unescape(match[1]);
      }
      function charAt(pos) {
        return source.charAt(pos);
      }
      function setComment(start, end, isLeading) {
        var comment = {
          type: source.charAt(start++),
          lineEmpty: false,
          leading: isLeading
        };
        var lookback;
        if (alternateCommentMode) {
          lookback = 2;
        } else {
          lookback = 3;
        }
        var commentOffset = start - lookback, c;
        do {
          if (--commentOffset < 0 || (c = source.charAt(commentOffset)) === "\n") {
            comment.lineEmpty = true;
            break;
          }
        } while (c === " " || c === "	");
        var lines = source.substring(start, end).split(setCommentSplitRe);
        for (var i = 0; i < lines.length; ++i)
          lines[i] = lines[i].replace(alternateCommentMode ? setCommentAltRe : setCommentRe, "").trim();
        comment.text = lines.join("\n").trim();
        comments[line] = comment;
        lastCommentLine = line;
      }
      function isDoubleSlashCommentLine(startOffset) {
        var endOffset = findEndOfLine(startOffset);
        var lineText = source.substring(startOffset, endOffset);
        var isComment = /^\s*\/\//.test(lineText);
        return isComment;
      }
      function findEndOfLine(cursor) {
        var endOffset = cursor;
        while (endOffset < length && charAt(endOffset) !== "\n") {
          endOffset++;
        }
        return endOffset;
      }
      function next() {
        if (stack.length > 0)
          return stack.shift();
        if (stringDelim)
          return readString();
        var repeat, prev, curr, start, isDoc, isLeadingComment = offset === 0;
        do {
          if (offset === length)
            return null;
          repeat = false;
          while (whitespaceRe.test(curr = charAt(offset))) {
            if (curr === "\n") {
              isLeadingComment = true;
              ++line;
            }
            if (++offset === length)
              return null;
          }
          if (charAt(offset) === "/") {
            if (++offset === length) {
              throw illegal("comment");
            }
            if (charAt(offset) === "/") {
              if (!alternateCommentMode) {
                isDoc = charAt(start = offset + 1) === "/";
                while (charAt(++offset) !== "\n") {
                  if (offset === length) {
                    return null;
                  }
                }
                ++offset;
                if (isDoc) {
                  setComment(start, offset - 1, isLeadingComment);
                  isLeadingComment = true;
                }
                ++line;
                repeat = true;
              } else {
                start = offset;
                isDoc = false;
                if (isDoubleSlashCommentLine(offset - 1)) {
                  isDoc = true;
                  do {
                    offset = findEndOfLine(offset);
                    if (offset === length) {
                      break;
                    }
                    offset++;
                    if (!isLeadingComment) {
                      break;
                    }
                  } while (isDoubleSlashCommentLine(offset));
                } else {
                  offset = Math.min(length, findEndOfLine(offset) + 1);
                }
                if (isDoc) {
                  setComment(start, offset, isLeadingComment);
                  isLeadingComment = true;
                }
                line++;
                repeat = true;
              }
            } else if ((curr = charAt(offset)) === "*") {
              start = offset + 1;
              isDoc = alternateCommentMode || charAt(start) === "*";
              do {
                if (curr === "\n") {
                  ++line;
                }
                if (++offset === length) {
                  throw illegal("comment");
                }
                prev = curr;
                curr = charAt(offset);
              } while (prev !== "*" || curr !== "/");
              ++offset;
              if (isDoc) {
                setComment(start, offset - 2, isLeadingComment);
                isLeadingComment = true;
              }
              repeat = true;
            } else {
              return "/";
            }
          }
        } while (repeat);
        var end = offset;
        delimRe.lastIndex = 0;
        var delim = delimRe.test(charAt(end++));
        if (!delim)
          while (end < length && !delimRe.test(charAt(end)))
            ++end;
        var token = source.substring(offset, offset = end);
        if (token === '"' || token === "'")
          stringDelim = token;
        return token;
      }
      function push(token) {
        stack.push(token);
      }
      function peek() {
        if (!stack.length) {
          var token = next();
          if (token === null)
            return null;
          push(token);
        }
        return stack[0];
      }
      function skip(expected, optional) {
        var actual = peek(), equals = actual === expected;
        if (equals) {
          next();
          return true;
        }
        if (!optional)
          throw illegal("token '" + actual + "', '" + expected + "' expected");
        return false;
      }
      function cmnt(trailingLine) {
        var ret = null;
        var comment;
        if (trailingLine === void 0) {
          comment = comments[line - 1];
          delete comments[line - 1];
          if (comment && (alternateCommentMode || comment.type === "*" || comment.lineEmpty)) {
            ret = comment.leading ? comment.text : null;
          }
        } else {
          if (lastCommentLine < trailingLine) {
            peek();
          }
          comment = comments[trailingLine];
          delete comments[trailingLine];
          if (comment && !comment.lineEmpty && (alternateCommentMode || comment.type === "/")) {
            ret = comment.leading ? null : comment.text;
          }
        }
        return ret;
      }
      return Object.defineProperty({
        next,
        peek,
        push,
        skip,
        cmnt
      }, "line", {
        get: function() {
          return line;
        }
      });
    }
  }
});

// node_modules/protobufjs/src/parse.js
var require_parse = __commonJS({
  "node_modules/protobufjs/src/parse.js"(exports2, module2) {
    "use strict";
    module2.exports = parse;
    parse.filename = null;
    parse.defaults = { keepCase: false };
    var tokenize = require_tokenize();
    var Root = require_root();
    var Type = require_type();
    var Field = require_field();
    var MapField = require_mapfield();
    var OneOf = require_oneof();
    var Enum = require_enum();
    var Service = require_service2();
    var Method = require_method();
    var types = require_types();
    var util = require_util();
    var base10Re = /^[1-9][0-9]*$/;
    var base10NegRe = /^-?[1-9][0-9]*$/;
    var base16Re = /^0[x][0-9a-fA-F]+$/;
    var base16NegRe = /^-?0[x][0-9a-fA-F]+$/;
    var base8Re = /^0[0-7]+$/;
    var base8NegRe = /^-?0[0-7]+$/;
    var numberRe = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/;
    var nameRe = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
    var typeRefRe = /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\.[a-zA-Z_][a-zA-Z_0-9]*)*$/;
    var fqTypeRefRe = /^(?:\.[a-zA-Z_][a-zA-Z_0-9]*)+$/;
    function parse(source, root, options) {
      if (!(root instanceof Root)) {
        options = root;
        root = new Root();
      }
      if (!options)
        options = parse.defaults;
      var preferTrailingComment = options.preferTrailingComment || false;
      var tn = tokenize(source, options.alternateCommentMode || false), next = tn.next, push = tn.push, peek = tn.peek, skip = tn.skip, cmnt = tn.cmnt;
      var head = true, pkg, imports, weakImports, syntax, isProto3 = false;
      var ptr = root;
      var applyCase = options.keepCase ? function(name) {
        return name;
      } : util.camelCase;
      function illegal(token2, name, insideTryCatch) {
        var filename = parse.filename;
        if (!insideTryCatch)
          parse.filename = null;
        return Error("illegal " + (name || "token") + " '" + token2 + "' (" + (filename ? filename + ", " : "") + "line " + tn.line + ")");
      }
      function readString() {
        var values = [], token2;
        do {
          if ((token2 = next()) !== '"' && token2 !== "'")
            throw illegal(token2);
          values.push(next());
          skip(token2);
          token2 = peek();
        } while (token2 === '"' || token2 === "'");
        return values.join("");
      }
      function readValue(acceptTypeRef) {
        var token2 = next();
        switch (token2) {
          case "'":
          case '"':
            push(token2);
            return readString();
          case "true":
          case "TRUE":
            return true;
          case "false":
          case "FALSE":
            return false;
        }
        try {
          return parseNumber(
            token2,
            /* insideTryCatch */
            true
          );
        } catch (e) {
          if (acceptTypeRef && typeRefRe.test(token2))
            return token2;
          throw illegal(token2, "value");
        }
      }
      function readRanges(target, acceptStrings) {
        var token2, start;
        do {
          if (acceptStrings && ((token2 = peek()) === '"' || token2 === "'"))
            target.push(readString());
          else
            target.push([start = parseId(next()), skip("to", true) ? parseId(next()) : start]);
        } while (skip(",", true));
        var dummy = { options: void 0 };
        dummy.setOption = function(name, value) {
          if (this.options === void 0) this.options = {};
          this.options[name] = value;
        };
        ifBlock(
          dummy,
          function parseRange_block(token3) {
            if (token3 === "option") {
              parseOption(dummy, token3);
              skip(";");
            } else
              throw illegal(token3);
          },
          function parseRange_line() {
            parseInlineOptions(dummy);
          }
        );
      }
      function parseNumber(token2, insideTryCatch) {
        var sign = 1;
        if (token2.charAt(0) === "-") {
          sign = -1;
          token2 = token2.substring(1);
        }
        switch (token2) {
          case "inf":
          case "INF":
          case "Inf":
            return sign * Infinity;
          case "nan":
          case "NAN":
          case "Nan":
          case "NaN":
            return NaN;
          case "0":
            return 0;
        }
        if (base10Re.test(token2))
          return sign * parseInt(token2, 10);
        if (base16Re.test(token2))
          return sign * parseInt(token2, 16);
        if (base8Re.test(token2))
          return sign * parseInt(token2, 8);
        if (numberRe.test(token2))
          return sign * parseFloat(token2);
        throw illegal(token2, "number", insideTryCatch);
      }
      function parseId(token2, acceptNegative) {
        switch (token2) {
          case "max":
          case "MAX":
          case "Max":
            return 536870911;
          case "0":
            return 0;
        }
        if (!acceptNegative && token2.charAt(0) === "-")
          throw illegal(token2, "id");
        if (base10NegRe.test(token2))
          return parseInt(token2, 10);
        if (base16NegRe.test(token2))
          return parseInt(token2, 16);
        if (base8NegRe.test(token2))
          return parseInt(token2, 8);
        throw illegal(token2, "id");
      }
      function parsePackage() {
        if (pkg !== void 0)
          throw illegal("package");
        pkg = next();
        if (!typeRefRe.test(pkg))
          throw illegal(pkg, "name");
        ptr = ptr.define(pkg);
        skip(";");
      }
      function parseImport() {
        var token2 = peek();
        var whichImports;
        switch (token2) {
          case "weak":
            whichImports = weakImports || (weakImports = []);
            next();
            break;
          case "public":
            next();
          default:
            whichImports = imports || (imports = []);
            break;
        }
        token2 = readString();
        skip(";");
        whichImports.push(token2);
      }
      function parseSyntax() {
        skip("=");
        syntax = readString();
        isProto3 = syntax === "proto3";
        if (!isProto3 && syntax !== "proto2")
          throw illegal(syntax, "syntax");
        skip(";");
      }
      function parseCommon(parent, token2) {
        switch (token2) {
          case "option":
            parseOption(parent, token2);
            skip(";");
            return true;
          case "message":
            parseType(parent, token2);
            return true;
          case "enum":
            parseEnum(parent, token2);
            return true;
          case "service":
            parseService(parent, token2);
            return true;
          case "extend":
            parseExtension(parent, token2);
            return true;
        }
        return false;
      }
      function ifBlock(obj, fnIf, fnElse) {
        var trailingLine = tn.line;
        if (obj) {
          if (typeof obj.comment !== "string") {
            obj.comment = cmnt();
          }
          obj.filename = parse.filename;
        }
        if (skip("{", true)) {
          var token2;
          while ((token2 = next()) !== "}")
            fnIf(token2);
          skip(";", true);
        } else {
          if (fnElse)
            fnElse();
          skip(";");
          if (obj && (typeof obj.comment !== "string" || preferTrailingComment))
            obj.comment = cmnt(trailingLine) || obj.comment;
        }
      }
      function parseType(parent, token2) {
        if (!nameRe.test(token2 = next()))
          throw illegal(token2, "type name");
        var type = new Type(token2);
        ifBlock(type, function parseType_block(token3) {
          if (parseCommon(type, token3))
            return;
          switch (token3) {
            case "map":
              parseMapField(type, token3);
              break;
            case "required":
            case "repeated":
              parseField(type, token3);
              break;
            case "optional":
              if (isProto3) {
                parseField(type, "proto3_optional");
              } else {
                parseField(type, "optional");
              }
              break;
            case "oneof":
              parseOneOf(type, token3);
              break;
            case "extensions":
              readRanges(type.extensions || (type.extensions = []));
              break;
            case "reserved":
              readRanges(type.reserved || (type.reserved = []), true);
              break;
            default:
              if (!isProto3 || !typeRefRe.test(token3))
                throw illegal(token3);
              push(token3);
              parseField(type, "optional");
              break;
          }
        });
        parent.add(type);
      }
      function parseField(parent, rule, extend) {
        var type = next();
        if (type === "group") {
          parseGroup(parent, rule);
          return;
        }
        while (type.endsWith(".") || peek().startsWith(".")) {
          type += next();
        }
        if (!typeRefRe.test(type))
          throw illegal(type, "type");
        var name = next();
        if (!nameRe.test(name))
          throw illegal(name, "name");
        name = applyCase(name);
        skip("=");
        var field = new Field(name, parseId(next()), type, rule, extend);
        ifBlock(field, function parseField_block(token2) {
          if (token2 === "option") {
            parseOption(field, token2);
            skip(";");
          } else
            throw illegal(token2);
        }, function parseField_line() {
          parseInlineOptions(field);
        });
        if (rule === "proto3_optional") {
          var oneof = new OneOf("_" + name);
          field.setOption("proto3_optional", true);
          oneof.add(field);
          parent.add(oneof);
        } else {
          parent.add(field);
        }
        if (!isProto3 && field.repeated && (types.packed[type] !== void 0 || types.basic[type] === void 0))
          field.setOption(
            "packed",
            false,
            /* ifNotSet */
            true
          );
      }
      function parseGroup(parent, rule) {
        var name = next();
        if (!nameRe.test(name))
          throw illegal(name, "name");
        var fieldName = util.lcFirst(name);
        if (name === fieldName)
          name = util.ucFirst(name);
        skip("=");
        var id = parseId(next());
        var type = new Type(name);
        type.group = true;
        var field = new Field(fieldName, id, name, rule);
        field.filename = parse.filename;
        ifBlock(type, function parseGroup_block(token2) {
          switch (token2) {
            case "option":
              parseOption(type, token2);
              skip(";");
              break;
            case "required":
            case "repeated":
              parseField(type, token2);
              break;
            case "optional":
              if (isProto3) {
                parseField(type, "proto3_optional");
              } else {
                parseField(type, "optional");
              }
              break;
            case "message":
              parseType(type, token2);
              break;
            case "enum":
              parseEnum(type, token2);
              break;
            default:
              throw illegal(token2);
          }
        });
        parent.add(type).add(field);
      }
      function parseMapField(parent) {
        skip("<");
        var keyType = next();
        if (types.mapKey[keyType] === void 0)
          throw illegal(keyType, "type");
        skip(",");
        var valueType = next();
        if (!typeRefRe.test(valueType))
          throw illegal(valueType, "type");
        skip(">");
        var name = next();
        if (!nameRe.test(name))
          throw illegal(name, "name");
        skip("=");
        var field = new MapField(applyCase(name), parseId(next()), keyType, valueType);
        ifBlock(field, function parseMapField_block(token2) {
          if (token2 === "option") {
            parseOption(field, token2);
            skip(";");
          } else
            throw illegal(token2);
        }, function parseMapField_line() {
          parseInlineOptions(field);
        });
        parent.add(field);
      }
      function parseOneOf(parent, token2) {
        if (!nameRe.test(token2 = next()))
          throw illegal(token2, "name");
        var oneof = new OneOf(applyCase(token2));
        ifBlock(oneof, function parseOneOf_block(token3) {
          if (token3 === "option") {
            parseOption(oneof, token3);
            skip(";");
          } else {
            push(token3);
            parseField(oneof, "optional");
          }
        });
        parent.add(oneof);
      }
      function parseEnum(parent, token2) {
        if (!nameRe.test(token2 = next()))
          throw illegal(token2, "name");
        var enm = new Enum(token2);
        ifBlock(enm, function parseEnum_block(token3) {
          switch (token3) {
            case "option":
              parseOption(enm, token3);
              skip(";");
              break;
            case "reserved":
              readRanges(enm.reserved || (enm.reserved = []), true);
              break;
            default:
              parseEnumValue(enm, token3);
          }
        });
        parent.add(enm);
      }
      function parseEnumValue(parent, token2) {
        if (!nameRe.test(token2))
          throw illegal(token2, "name");
        skip("=");
        var value = parseId(next(), true), dummy = {
          options: void 0
        };
        dummy.setOption = function(name, value2) {
          if (this.options === void 0)
            this.options = {};
          this.options[name] = value2;
        };
        ifBlock(dummy, function parseEnumValue_block(token3) {
          if (token3 === "option") {
            parseOption(dummy, token3);
            skip(";");
          } else
            throw illegal(token3);
        }, function parseEnumValue_line() {
          parseInlineOptions(dummy);
        });
        parent.add(token2, value, dummy.comment, dummy.options);
      }
      function parseOption(parent, token2) {
        var isCustom = skip("(", true);
        if (!typeRefRe.test(token2 = next()))
          throw illegal(token2, "name");
        var name = token2;
        var option = name;
        var propName;
        if (isCustom) {
          skip(")");
          name = "(" + name + ")";
          option = name;
          token2 = peek();
          if (fqTypeRefRe.test(token2)) {
            propName = token2.slice(1);
            name += token2;
            next();
          }
        }
        skip("=");
        var optionValue = parseOptionValue(parent, name);
        setParsedOption(parent, option, optionValue, propName);
      }
      function parseOptionValue(parent, name) {
        if (skip("{", true)) {
          var objectResult = {};
          while (!skip("}", true)) {
            if (!nameRe.test(token = next())) {
              throw illegal(token, "name");
            }
            if (token === null) {
              throw illegal(token, "end of input");
            }
            var value;
            var propName = token;
            skip(":", true);
            if (peek() === "{")
              value = parseOptionValue(parent, name + "." + token);
            else if (peek() === "[") {
              value = [];
              var lastValue;
              if (skip("[", true)) {
                do {
                  lastValue = readValue(true);
                  value.push(lastValue);
                } while (skip(",", true));
                skip("]");
                if (typeof lastValue !== "undefined") {
                  setOption(parent, name + "." + token, lastValue);
                }
              }
            } else {
              value = readValue(true);
              setOption(parent, name + "." + token, value);
            }
            var prevValue = objectResult[propName];
            if (prevValue)
              value = [].concat(prevValue).concat(value);
            objectResult[propName] = value;
            skip(",", true);
            skip(";", true);
          }
          return objectResult;
        }
        var simpleValue = readValue(true);
        setOption(parent, name, simpleValue);
        return simpleValue;
      }
      function setOption(parent, name, value) {
        if (parent.setOption)
          parent.setOption(name, value);
      }
      function setParsedOption(parent, name, value, propName) {
        if (parent.setParsedOption)
          parent.setParsedOption(name, value, propName);
      }
      function parseInlineOptions(parent) {
        if (skip("[", true)) {
          do {
            parseOption(parent, "option");
          } while (skip(",", true));
          skip("]");
        }
        return parent;
      }
      function parseService(parent, token2) {
        if (!nameRe.test(token2 = next()))
          throw illegal(token2, "service name");
        var service = new Service(token2);
        ifBlock(service, function parseService_block(token3) {
          if (parseCommon(service, token3))
            return;
          if (token3 === "rpc")
            parseMethod(service, token3);
          else
            throw illegal(token3);
        });
        parent.add(service);
      }
      function parseMethod(parent, token2) {
        var commentText = cmnt();
        var type = token2;
        if (!nameRe.test(token2 = next()))
          throw illegal(token2, "name");
        var name = token2, requestType, requestStream, responseType, responseStream;
        skip("(");
        if (skip("stream", true))
          requestStream = true;
        if (!typeRefRe.test(token2 = next()))
          throw illegal(token2);
        requestType = token2;
        skip(")");
        skip("returns");
        skip("(");
        if (skip("stream", true))
          responseStream = true;
        if (!typeRefRe.test(token2 = next()))
          throw illegal(token2);
        responseType = token2;
        skip(")");
        var method = new Method(name, type, requestType, responseType, requestStream, responseStream);
        method.comment = commentText;
        ifBlock(method, function parseMethod_block(token3) {
          if (token3 === "option") {
            parseOption(method, token3);
            skip(";");
          } else
            throw illegal(token3);
        });
        parent.add(method);
      }
      function parseExtension(parent, token2) {
        if (!typeRefRe.test(token2 = next()))
          throw illegal(token2, "reference");
        var reference = token2;
        ifBlock(null, function parseExtension_block(token3) {
          switch (token3) {
            case "required":
            case "repeated":
              parseField(parent, token3, reference);
              break;
            case "optional":
              if (isProto3) {
                parseField(parent, "proto3_optional", reference);
              } else {
                parseField(parent, "optional", reference);
              }
              break;
            default:
              if (!isProto3 || !typeRefRe.test(token3))
                throw illegal(token3);
              push(token3);
              parseField(parent, "optional", reference);
              break;
          }
        });
      }
      var token;
      while ((token = next()) !== null) {
        switch (token) {
          case "package":
            if (!head)
              throw illegal(token);
            parsePackage();
            break;
          case "import":
            if (!head)
              throw illegal(token);
            parseImport();
            break;
          case "syntax":
            if (!head)
              throw illegal(token);
            parseSyntax();
            break;
          case "option":
            parseOption(ptr, token);
            skip(";");
            break;
          default:
            if (parseCommon(ptr, token)) {
              head = false;
              continue;
            }
            throw illegal(token);
        }
      }
      parse.filename = null;
      return {
        "package": pkg,
        "imports": imports,
        weakImports,
        syntax,
        root
      };
    }
  }
});

// node_modules/protobufjs/src/common.js
var require_common = __commonJS({
  "node_modules/protobufjs/src/common.js"(exports2, module2) {
    "use strict";
    module2.exports = common;
    var commonRe = /\/|\./;
    function common(name, json) {
      if (!commonRe.test(name)) {
        name = "google/protobuf/" + name + ".proto";
        json = { nested: { google: { nested: { protobuf: { nested: json } } } } };
      }
      common[name] = json;
    }
    common("any", {
      /**
       * Properties of a google.protobuf.Any message.
       * @interface IAny
       * @type {Object}
       * @property {string} [typeUrl]
       * @property {Uint8Array} [bytes]
       * @memberof common
       */
      Any: {
        fields: {
          type_url: {
            type: "string",
            id: 1
          },
          value: {
            type: "bytes",
            id: 2
          }
        }
      }
    });
    var timeType;
    common("duration", {
      /**
       * Properties of a google.protobuf.Duration message.
       * @interface IDuration
       * @type {Object}
       * @property {number|Long} [seconds]
       * @property {number} [nanos]
       * @memberof common
       */
      Duration: timeType = {
        fields: {
          seconds: {
            type: "int64",
            id: 1
          },
          nanos: {
            type: "int32",
            id: 2
          }
        }
      }
    });
    common("timestamp", {
      /**
       * Properties of a google.protobuf.Timestamp message.
       * @interface ITimestamp
       * @type {Object}
       * @property {number|Long} [seconds]
       * @property {number} [nanos]
       * @memberof common
       */
      Timestamp: timeType
    });
    common("empty", {
      /**
       * Properties of a google.protobuf.Empty message.
       * @interface IEmpty
       * @memberof common
       */
      Empty: {
        fields: {}
      }
    });
    common("struct", {
      /**
       * Properties of a google.protobuf.Struct message.
       * @interface IStruct
       * @type {Object}
       * @property {Object.<string,IValue>} [fields]
       * @memberof common
       */
      Struct: {
        fields: {
          fields: {
            keyType: "string",
            type: "Value",
            id: 1
          }
        }
      },
      /**
       * Properties of a google.protobuf.Value message.
       * @interface IValue
       * @type {Object}
       * @property {string} [kind]
       * @property {0} [nullValue]
       * @property {number} [numberValue]
       * @property {string} [stringValue]
       * @property {boolean} [boolValue]
       * @property {IStruct} [structValue]
       * @property {IListValue} [listValue]
       * @memberof common
       */
      Value: {
        oneofs: {
          kind: {
            oneof: [
              "nullValue",
              "numberValue",
              "stringValue",
              "boolValue",
              "structValue",
              "listValue"
            ]
          }
        },
        fields: {
          nullValue: {
            type: "NullValue",
            id: 1
          },
          numberValue: {
            type: "double",
            id: 2
          },
          stringValue: {
            type: "string",
            id: 3
          },
          boolValue: {
            type: "bool",
            id: 4
          },
          structValue: {
            type: "Struct",
            id: 5
          },
          listValue: {
            type: "ListValue",
            id: 6
          }
        }
      },
      NullValue: {
        values: {
          NULL_VALUE: 0
        }
      },
      /**
       * Properties of a google.protobuf.ListValue message.
       * @interface IListValue
       * @type {Object}
       * @property {Array.<IValue>} [values]
       * @memberof common
       */
      ListValue: {
        fields: {
          values: {
            rule: "repeated",
            type: "Value",
            id: 1
          }
        }
      }
    });
    common("wrappers", {
      /**
       * Properties of a google.protobuf.DoubleValue message.
       * @interface IDoubleValue
       * @type {Object}
       * @property {number} [value]
       * @memberof common
       */
      DoubleValue: {
        fields: {
          value: {
            type: "double",
            id: 1
          }
        }
      },
      /**
       * Properties of a google.protobuf.FloatValue message.
       * @interface IFloatValue
       * @type {Object}
       * @property {number} [value]
       * @memberof common
       */
      FloatValue: {
        fields: {
          value: {
            type: "float",
            id: 1
          }
        }
      },
      /**
       * Properties of a google.protobuf.Int64Value message.
       * @interface IInt64Value
       * @type {Object}
       * @property {number|Long} [value]
       * @memberof common
       */
      Int64Value: {
        fields: {
          value: {
            type: "int64",
            id: 1
          }
        }
      },
      /**
       * Properties of a google.protobuf.UInt64Value message.
       * @interface IUInt64Value
       * @type {Object}
       * @property {number|Long} [value]
       * @memberof common
       */
      UInt64Value: {
        fields: {
          value: {
            type: "uint64",
            id: 1
          }
        }
      },
      /**
       * Properties of a google.protobuf.Int32Value message.
       * @interface IInt32Value
       * @type {Object}
       * @property {number} [value]
       * @memberof common
       */
      Int32Value: {
        fields: {
          value: {
            type: "int32",
            id: 1
          }
        }
      },
      /**
       * Properties of a google.protobuf.UInt32Value message.
       * @interface IUInt32Value
       * @type {Object}
       * @property {number} [value]
       * @memberof common
       */
      UInt32Value: {
        fields: {
          value: {
            type: "uint32",
            id: 1
          }
        }
      },
      /**
       * Properties of a google.protobuf.BoolValue message.
       * @interface IBoolValue
       * @type {Object}
       * @property {boolean} [value]
       * @memberof common
       */
      BoolValue: {
        fields: {
          value: {
            type: "bool",
            id: 1
          }
        }
      },
      /**
       * Properties of a google.protobuf.StringValue message.
       * @interface IStringValue
       * @type {Object}
       * @property {string} [value]
       * @memberof common
       */
      StringValue: {
        fields: {
          value: {
            type: "string",
            id: 1
          }
        }
      },
      /**
       * Properties of a google.protobuf.BytesValue message.
       * @interface IBytesValue
       * @type {Object}
       * @property {Uint8Array} [value]
       * @memberof common
       */
      BytesValue: {
        fields: {
          value: {
            type: "bytes",
            id: 1
          }
        }
      }
    });
    common("field_mask", {
      /**
       * Properties of a google.protobuf.FieldMask message.
       * @interface IDoubleValue
       * @type {Object}
       * @property {number} [value]
       * @memberof common
       */
      FieldMask: {
        fields: {
          paths: {
            rule: "repeated",
            type: "string",
            id: 1
          }
        }
      }
    });
    common.get = function get(file) {
      return common[file] || null;
    };
  }
});

// node_modules/protobufjs/src/index.js
var require_src = __commonJS({
  "node_modules/protobufjs/src/index.js"(exports2, module2) {
    "use strict";
    var protobuf = module2.exports = require_index_light();
    protobuf.build = "full";
    protobuf.tokenize = require_tokenize();
    protobuf.parse = require_parse();
    protobuf.common = require_common();
    protobuf.Root._configure(protobuf.Type, protobuf.parse, protobuf.common);
  }
});

// node_modules/protobufjs/index.js
var require_protobufjs = __commonJS({
  "node_modules/protobufjs/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_src();
  }
});

// assets/scripts/framework/plugins/config/Lang.ts
var Lang_exports = {};
__export(Lang_exports, {
  Language: () => Language,
  Language_ARRAY: () => Language_ARRAY
});
var import_protobufjs, $Reader, $Writer, $util, Language, Language_ARRAY;
var init_Lang = __esm({
  "assets/scripts/framework/plugins/config/Lang.ts"() {
    import_protobufjs = __toESM(require_protobufjs());
    $Reader = import_protobufjs.default.Reader;
    $Writer = import_protobufjs.default.Writer;
    $util = import_protobufjs.default.util;
    Language = class _Language {
      /**
       * Properties of a Language.
       * @memberof GameData
       * @interface ILanguage
       * @property {string|null} [ID] Language ID
       * @property {string|null} [Text] Language Text
       */
      /**
       * Constructs a new Language.
       * @memberof GameData
       * @classdesc Represents a Language.
       * @implements ILanguage
       * @constructor
       * @param {ILanguage=} [properties] Properties to set
       */
      constructor(properties) {
        /**
         * Language ID.
         * @member {string} ID
         * @memberof Language
         * @instance
         */
        this.ID = "";
        /**
         * Language Text.
         * @member {string} Text
         * @memberof Language
         * @instance
         */
        this.Text = "";
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      /**
       * Creates a new Language instance using the specified properties.
       * @function create
       * @memberof Language
       * @static
       * @param {ILanguage=} [properties] Properties to set
       * @returns {Language} Language instance
       */
      static create(properties) {
        return new _Language(properties);
      }
      /**
       * Encodes the specified Language message. Does not implicitly {@link Language.verify|verify} messages.
       * @function encode
       * @memberof Language
       * @static
       * @param {ILanguage} message Language message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      static encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.ID != null && Object.hasOwnProperty.call(message, "ID"))
          writer.uint32(
            /* id 1, wireType 2 =*/
            10
          ).string(message.ID);
        if (message.Text != null && Object.hasOwnProperty.call(message, "Text"))
          writer.uint32(
            /* id 2, wireType 2 =*/
            18
          ).string(message.Text);
        return writer;
      }
      /**
       * Encodes the specified Language message, length delimited. Does not implicitly {@link Language.verify|verify} messages.
       * @function encodeDelimited
       * @memberof Language
       * @static
       * @param {ILanguage} message Language message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      static encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }
      /**
       * Decodes a Language message from the specified reader or buffer.
       * @function decode
       * @memberof Language
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {Language} Language
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      static decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new _Language();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.ID = reader.string();
              break;
            case 2:
              message.Text = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }
      /**
       * Decodes a Language message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof Language
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {Language} Language
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      static decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      }
      /**
       * Verifies a Language message.
       * @function verify
       * @memberof Language
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      static verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.ID != null && message.hasOwnProperty("ID")) {
          if (!$util.isString(message.ID))
            return "ID: string expected";
        }
        if (message.Text != null && message.hasOwnProperty("Text")) {
          if (!$util.isString(message.Text))
            return "Text: string expected";
        }
        return null;
      }
      /**
       * Creates a Language message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof Language
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {Language} Language
       */
      static fromObject(object) {
        if (object instanceof _Language)
          return object;
        var message = new _Language();
        if (object.ID != null)
          message.ID = String(object.ID);
        if (object.Text != null)
          message.Text = String(object.Text);
        return message;
      }
      /**
       * Creates a plain object from a Language message. Also converts values to other types if specified.
       * @function toObject
       * @memberof Language
       * @static
       * @param {Language} message Language
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      static toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.defaults) {
          object.ID = "";
          object.Text = "";
        }
        if (message.ID != null && message.hasOwnProperty("ID"))
          object.ID = message.ID;
        if (message.Text != null && message.hasOwnProperty("Text"))
          object.Text = message.Text;
        return object;
      }
      /**
       * Converts this Language to JSON.
       * @function toJSON
       * @memberof Language
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      toJSON() {
        return _Language.toObject(this, import_protobufjs.default.util.toJSONOptions);
      }
    };
    Language_ARRAY = class _Language_ARRAY {
      /**
       * Properties of a Language_ARRAY.
       * @memberof GameData
       * @interface ILanguage_ARRAY
       * @property {Array.<ILanguage>|null} [Items] Language_ARRAY Items
       */
      /**
       * Constructs a new Language_ARRAY.
       * @memberof GameData
       * @classdesc Represents a Language_ARRAY.
       * @implements ILanguage_ARRAY
       * @constructor
       * @param {ILanguage_ARRAY=} [properties] Properties to set
       */
      constructor(properties) {
        /**
         * Language_ARRAY Items.
         * @member {Array.<ILanguage>} Items
         * @memberof Language_ARRAY
         * @instance
         */
        this.Items = $util.emptyArray;
        this.Items = [];
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      /**
       * Creates a new Language_ARRAY instance using the specified properties.
       * @function create
       * @memberof Language_ARRAY
       * @static
       * @param {ILanguage_ARRAY=} [properties] Properties to set
       * @returns {Language_ARRAY} Language_ARRAY instance
       */
      static create(properties) {
        return new _Language_ARRAY(properties);
      }
      /**
       * Encodes the specified Language_ARRAY message. Does not implicitly {@link Language_ARRAY.verify|verify} messages.
       * @function encode
       * @memberof Language_ARRAY
       * @static
       * @param {ILanguage_ARRAY} message Language_ARRAY message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      static encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.Items != null && message.Items.length)
          for (var i = 0; i < message.Items.length; ++i)
            Language.encode(message.Items[i], writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork()).ldelim();
        return writer;
      }
      /**
       * Encodes the specified Language_ARRAY message, length delimited. Does not implicitly {@link Language_ARRAY.verify|verify} messages.
       * @function encodeDelimited
       * @memberof Language_ARRAY
       * @static
       * @param {ILanguage_ARRAY} message Language_ARRAY message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      static encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }
      /**
       * Decodes a Language_ARRAY message from the specified reader or buffer.
       * @function decode
       * @memberof Language_ARRAY
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {Language_ARRAY} Language_ARRAY
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      static decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new _Language_ARRAY();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.Items && message.Items.length))
                message.Items = [];
              message.Items.push(Language.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }
      /**
       * Decodes a Language_ARRAY message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof Language_ARRAY
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {Language_ARRAY} Language_ARRAY
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      static decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      }
      /**
       * Verifies a Language_ARRAY message.
       * @function verify
       * @memberof Language_ARRAY
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      static verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.Items != null && message.hasOwnProperty("Items")) {
          if (!Array.isArray(message.Items))
            return "Items: array expected";
          for (var i = 0; i < message.Items.length; ++i) {
            var error = Language.verify(message.Items[i]);
            if (error)
              return "Items." + error;
          }
        }
        return null;
      }
      /**
       * Creates a Language_ARRAY message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof Language_ARRAY
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {Language_ARRAY} Language_ARRAY
       */
      static fromObject(object) {
        if (object instanceof _Language_ARRAY)
          return object;
        var message = new _Language_ARRAY();
        if (object.Items) {
          if (!Array.isArray(object.Items))
            throw TypeError(".Language_ARRAY.Items: array expected");
          message.Items = [];
          for (var i = 0; i < object.Items.length; ++i) {
            if (typeof object.Items[i] !== "object")
              throw TypeError(".Language_ARRAY.Items: object expected");
            message.Items[i] = Language.fromObject(object.Items[i]);
          }
        }
        return message;
      }
      /**
       * Creates a plain object from a Language_ARRAY message. Also converts values to other types if specified.
       * @function toObject
       * @memberof Language_ARRAY
       * @static
       * @param {Language_ARRAY} message Language_ARRAY
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      static toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.arrays || options.defaults)
          object.Items = [];
        if (message.Items && message.Items.length) {
          object.Items = [];
          for (var j = 0; j < message.Items.length; ++j)
            object.Items[j] = Language.toObject(message.Items[j], options);
        }
        return object;
      }
      /**
       * Converts this Language_ARRAY to JSON.
       * @function toJSON
       * @memberof Language_ARRAY
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      toJSON() {
        return _Language_ARRAY.toObject(this, import_protobufjs.default.util.toJSONOptions);
      }
    };
  }
});

// assets/scripts/framework/plugins/config/I18N.ts
var I18N_exports = {};
__export(I18N_exports, {
  I18N: () => I18N
});
var _I18N, I18N;
var init_I18N = __esm({
  "assets/scripts/framework/plugins/config/I18N.ts"() {
    init_DataAccess();
    init_Lang();
    _I18N = class _I18N extends DataTable {
      static get inst() {
        if (!this._inst) {
          this._inst = new _I18N();
        }
        return this._inst;
      }
      constructor(keyName = "ID") {
        super(Language, keyName);
        this.initial(this.dataType, null, _I18N.getFilename);
      }
      load() {
        var buffer = this.onLoadData("Language_ARRAY");
        var message = Language_ARRAY.decode(buffer);
        return message.Items;
      }
      static setLanguage(lan = "cn") {
        if (this.currentLanguage != "") {
          this.inst.clear();
        }
        this.currentLanguage = lan;
      }
      static getFilename(typeName) {
        typeName = typeName.replace("_ARRAY", "");
        var datafile = DataAccess.dataDir + typeName.toLocaleLowerCase();
        return `${datafile}.${_I18N.currentLanguage}`;
      }
      static translate(key) {
        let lan = this.inst.itemMap[key];
        if (lan) {
          return lan.Text;
        }
        return null;
      }
    };
    _I18N.currentLanguage = "cn";
    I18N = _I18N;
  }
});

// assets/scripts/framework/plugins/fsm/FSM.ts
var FSM_exports = {};
__export(FSM_exports, {
  FSM: () => FSM
});
var FSM;
var init_FSM = __esm({
  "assets/scripts/framework/plugins/fsm/FSM.ts"() {
    ((FSM2) => {
      class State {
        constructor(owner, hsm, name) {
          this._name = name;
          this._hsm = hsm;
          this._owner = owner;
        }
        get isCompositeState() {
          return false;
        }
        init() {
        }
        onEnter(data) {
        }
        onExit() {
        }
        onStateChange(stateName) {
        }
        onUpdate(dt) {
        }
        onLaterUpdate(dt) {
        }
        onRefresh() {
        }
        get name() {
          return this._name;
        }
        get hierachicalName() {
          return this._name;
        }
        get hsm() {
          return this._hsm;
        }
        get owner() {
          return this._owner;
        }
      }
      FSM2.State = State;
      class CompositeState {
        constructor(owner, hsm, name) {
          this._hierachicalName = "";
          this._currentState = null;
          this._defaultStateName = "";
          this._nameDictionary = {};
          this._currentOverwriteFlag = false;
          this._name = name;
          this._hsm = hsm;
          this._owner = owner;
        }
        isCompositeState() {
          return true;
        }
        init(states, defaultStateName) {
          if (!(states instanceof Array)) {
            console.log("states must be array data!");
            return;
          }
          this._currentOverwriteFlag = false;
          for (var i in states) {
            var state = states[i];
            this._nameDictionary[state.name] = state;
          }
          this._defaultStateName = defaultStateName;
        }
        get currentState() {
          return this._currentState;
        }
        onEnter(data) {
          this._currentState = this.getStateByName(this._defaultStateName);
          if (!this._currentState) {
            console.log("Invalid state name:" + this._defaultStateName);
            return;
          }
          if (this._hsm.enableDebug) {
            console.log("CompositeState::onEnter " + this._currentState.name);
          }
          if (this._currentState && this._currentState.onEnter) {
            this._currentState.onEnter(data);
          }
        }
        onExit() {
          if (this._currentState && this._currentState.onExit) {
            this._currentState.onExit();
          }
          if (this._hsm.enableDebug) {
            console.log("CompositeState::onExit " + this._currentState.name);
          }
          this._currentState = null;
        }
        onStateChange(stateName) {
          if (this._currentState && this._currentState.onExit) {
            this._currentState.onExit();
          }
          var newState = this.getStateByName(stateName);
          if (!newState) {
            console.log("Invalid state name: " + stateName);
            return;
          }
          if (this._hsm.enableDebug) {
            console.log("Change sub state from " + (this._currentState ? this._currentState.name : "_empty_") + " to " + newState.name);
          }
          this._currentState = newState;
          if (this._currentState.onEnter) {
            this._currentState.onEnter();
          }
        }
        onUpdate(dt) {
          if (this._currentState && this._currentState.onUpdate) {
            this._currentState.onUpdate(dt);
          }
        }
        onLaterUpdate(dt) {
          if (this._currentState && this._currentState.onLaterUpdate) {
            this._currentState.onLaterUpdate(dt);
          }
        }
        get name() {
          return this._name;
        }
        get hierachicalName() {
          if (this._currentState) {
            return this.name + "::" + this._currentState.hierachicalName;
          } else {
            return this._name;
          }
        }
        getStateByName(stateName) {
          return this._nameDictionary[stateName];
        }
        get hsm() {
          return this._hsm;
        }
        get owner() {
          return this._owner;
        }
      }
      FSM2.CompositeState = CompositeState;
      class ChangeStateInfo {
        constructor() {
          this.dirtyFlag = false;
        }
      }
      class HierarchicalStateMachine {
        constructor(owner, enableDebug) {
          this.onStateChanged = null;
          this._enableDebug = false;
          this._currentState = null;
          this._previousState = null;
          this._nameDictionary = {};
          this._pendingStateChange = null;
          //string
          this._currentOverwriteFlag = false;
          this._changeStateData = null;
          this._states = [];
          this._pendingStateChangeInfo = new ChangeStateInfo();
          this._owner = owner;
          this._enableDebug = enableDebug || false;
        }
        get owner() {
          return this._owner;
        }
        get currentState() {
          return this._currentState;
        }
        get previousState() {
          return this._previousState;
        }
        get enableDebug() {
          return this._enableDebug;
        }
        set enableDebug(value) {
          this._enableDebug = value;
        }
        get states() {
          return this._states;
        }
        init(states, defaultStateName) {
          if (!(states instanceof Array)) {
            console.log("states must be array data!");
            return;
          }
          this._states = states;
          this._currentOverwriteFlag = false;
          for (var i in states) {
            var state = states[i];
            this._nameDictionary[state.name] = state;
          }
          if (defaultStateName) {
            this.doChangeState(defaultStateName);
          }
        }
        update(dt) {
          if (this._pendingStateChange) {
            this.doChangeState(this._pendingStateChange, this._changeStateData);
            this._pendingStateChange = null;
            this._changeStateData = null;
          }
          this._currentOverwriteFlag = true;
          if (this._currentState && this._currentState.onUpdate) {
            this._currentState.onUpdate(dt);
          }
          if (this._pendingStateChangeInfo.dirtyFlag) {
            let info = this._pendingStateChangeInfo;
            this._changeState(info.stateName, info.data, info.overwriteFlag);
            this._pendingStateChangeInfo.dirtyFlag = false;
          }
        }
        laterUpdate(dt) {
          if (this._pendingStateChange) {
            this.doChangeState(this._pendingStateChange, this._changeStateData);
            this._pendingStateChange = null;
            this._changeStateData = null;
          }
          this._currentOverwriteFlag = true;
          if (this._currentState && this._currentState.onLaterUpdate) {
            this._currentState.onLaterUpdate(dt);
          }
        }
        cleanPendingState() {
          this._pendingStateChange = null;
          this._currentOverwriteFlag = true;
          this._changeStateData = null;
        }
        forceChangeState(stateName, data) {
          this.doChangeState(stateName, data);
          this.cleanPendingState();
        }
        changeState(stateName, data, overwriteFlag) {
          if (this._currentState && this._currentState.name == stateName) {
            return;
          }
          let stateInfo = this._pendingStateChangeInfo;
          stateInfo.stateName = stateName;
          stateInfo.data = data;
          stateInfo.overwriteFlag = overwriteFlag || true;
          stateInfo.dirtyFlag = true;
        }
        _changeState(stateName, data, overwriteFlag) {
          overwriteFlag = overwriteFlag || true;
          if (this._currentOverwriteFlag) {
            if (this._pendingStateChange && this._enableDebug) {
              console.log("ChangeState will replace state " + this._pendingStateChange + " with " + stateName);
            }
            this._pendingStateChange = stateName;
            this._changeStateData = data;
          } else {
            if (this._pendingStateChange) {
              if (this._enableDebug) {
                console.log("Reject state changing from " + this._pendingStateChange + " to " + stateName);
              }
              return;
            }
            this._pendingStateChange = stateName;
            this._changeStateData = data;
          }
          this._currentOverwriteFlag = overwriteFlag;
        }
        hasState(stateName) {
          return this._nameDictionary[stateName] != null;
        }
        getStateByName(stateName) {
          return this._nameDictionary[stateName];
        }
        doChangeState(stateName, data) {
          this._previousState = this._currentState;
          var names = stateName.split("::");
          if (names.length == 1) {
            var name = names[0];
            if (this._currentState && this._currentState.onExit) {
              this._currentState.onExit();
            }
            var newState = this._nameDictionary[stateName];
            if (!newState) {
              console.log("Invalid state name: " + stateName);
              return;
            }
            if (this.enableDebug) {
              console.log("Change state from: " + (this._currentState ? this._currentState.name : "_empty_") + " to: " + newState.name);
            }
            this._currentState = newState;
            if (this._currentState.onEnter)
              this._currentState.onEnter(data);
          } else if (names.length == 2) {
            var parentStateName = names[0];
            var parentState = this.getStateByName(parentStateName);
            if (!parentState) {
              console.log("Invalid state name: " + parentStateName);
              return;
            }
            if (parentState != this._currentState) {
              if (this._currentState && this._currentState.onExit) {
                this._currentState.onExit();
                if (this.enableDebug) {
                  console.log("Transfer to internal state!");
                }
              }
            }
            var subStateName = names[1];
            parentState.onStateChange(subStateName);
          } else {
            console.log("Invalid state name: " + stateName);
          }
          if (this.onStateChanged) {
            this.onStateChanged(this._previousState.hierachicalName, this._currentState.hierachicalName);
          }
        }
      }
      FSM2.HierarchicalStateMachine = HierarchicalStateMachine;
    })(FSM || (FSM = {}));
  }
});

// assets/scripts/framework/plugins/gesture/Gesture.ts
var Gesture_exports = {};
__export(Gesture_exports, {
  default: () => Gesture
});
var Gesture;
var init_Gesture = __esm({
  "assets/scripts/framework/plugins/gesture/Gesture.ts"() {
    init_fairygui();
    Gesture = class {
      constructor(host) {
        this.touchDragSensitivity = UIConfig.touchDragSensitivity;
        this._host = host;
      }
      get host() {
        return this._host;
      }
      on(type, listener, target) {
        this.host.node.on(type, listener, target);
      }
      once(type, listener, target) {
        this.host.node.once(type, listener, target);
      }
      off(type, listener, target) {
        this.host.node.off(type, listener, target);
      }
      emit(type, event) {
        this.host.node.emit(type, event);
      }
      dispose() {
        this._host = null;
      }
      getTouchIds() {
        let touchIds = [];
        touchIds = GRoot.inst.inputProcessor.getAllTouches();
        if (!touchIds) {
          touchIds = [];
        }
        return touchIds;
      }
    };
  }
});

// assets/scripts/framework/plugins/gesture/LongTouchGesture.ts
var LongTouchGesture_exports = {};
__export(LongTouchGesture_exports, {
  default: () => LongTouchGesture
});
var import_cc17, _LongTouchGesture, LongTouchGesture;
var init_LongTouchGesture = __esm({
  "assets/scripts/framework/plugins/gesture/LongTouchGesture.ts"() {
    init_Gesture();
    import_cc17 = require("cc");
    init_fairygui();
    init_Timer();
    _LongTouchGesture = class _LongTouchGesture extends Gesture {
      constructor() {
        super(...arguments);
        /**
         * 长按时间(s)
         */
        this.touchTime = 1.5;
        /**
         * 长按位置最大移动距离(小于等于0不进行检查)
         */
        this.minDistance = 20;
        /**
         * 是否进行实时移动检查
         */
        this.checkEndOnMoving = true;
        this._touchPos = new import_cc17.Vec2();
        this._started = false;
        this._paused = false;
        this._enabled = false;
        this._timer = 0;
        this._triggered = false;
      }
      get started() {
        return this._started;
      }
      enable(value) {
        if (value) {
          if (!this._enabled) {
            this.on(Event.TOUCH_BEGIN, this.__touchBegin, this);
            this._enabled = true;
          }
        } else {
          this._started = false;
          if (this._enabled) {
            this.off(Event.TOUCH_BEGIN, this.__touchBegin, this);
            this._enabled = false;
          }
        }
      }
      dispose() {
        super.dispose();
        this.enable(false);
      }
      checkTouchValid(evt) {
        return this.minDistance <= 0 || import_cc17.Vec2.distance(evt.pos, this._touchPos) <= this.minDistance;
      }
      /**
       * 多段触摸时，时间重置
       * @param touchTime 
       */
      resetTime(touchTime = 1.5) {
        this._timer = 0;
        this.touchTime = touchTime;
        this._triggered = false;
        this._paused = false;
      }
      stopAndSetTime(touchTime = 1.5) {
        this.resetTime(touchTime);
        this._started = false;
      }
      __touchBegin(evt) {
        let touchIds = this.getTouchIds();
        if (touchIds.length >= 1) {
          this._started = true;
          this._timer = 0;
          this._touchPos.set(evt.pos);
          Timer.inst.clearAll(this);
          Timer.inst.frameLoop(1, () => {
            this._timer += Timer.inst.delta;
            if (!this._triggered && this._timer >= this.touchTime * 1e3) {
              if (this._started && !this._paused) {
                this._paused = true;
                if (this.checkTouchValid(evt)) {
                  this._triggered = true;
                  this.emit(_LongTouchGesture.LONG_TOUCH, evt);
                } else {
                  this.onEnd(evt);
                }
              }
            }
          }, this);
          if (this.checkEndOnMoving) {
            GRoot.inst.on(Event.TOUCH_MOVE, this.__touchMove, this);
          }
          GRoot.inst.on(Event.TOUCH_END, this.__touchEnd, this);
        }
      }
      onEnd(evt) {
        Timer.inst.clearAll(this);
        if (this.checkEndOnMoving) {
          GRoot.inst.off(Event.TOUCH_MOVE, this.__touchMove, this);
        }
        GRoot.inst.off(Event.TOUCH_END, this.__touchEnd, this);
        this._timer = 0;
        this._triggered = false;
        this._paused = false;
        if (this._started) {
          this.emit(_LongTouchGesture.LONG_TOUCH_END, evt);
        }
        this._started = false;
      }
      __touchMove(evt) {
        if (this._started) {
          if (!this.checkTouchValid(evt)) {
            this.onEnd(evt);
          }
        }
      }
      __touchEnd(evt) {
        this.onEnd(evt);
      }
    };
    /**
     *  长按事件。
     */
    _LongTouchGesture.LONG_TOUCH = "LONG_TOUCH";
    /**
     * 监听结束
     */
    _LongTouchGesture.LONG_TOUCH_END = "LONG_TOUCH_END";
    LongTouchGesture = _LongTouchGesture;
  }
});

// assets/scripts/framework/plugins/gesture/PinchGesture.ts
var PinchGesture_exports = {};
__export(PinchGesture_exports, {
  default: () => PinchGesture
});
var import_cc18, _PinchGesture, PinchGesture;
var init_PinchGesture = __esm({
  "assets/scripts/framework/plugins/gesture/PinchGesture.ts"() {
    init_Gesture();
    import_cc18 = require("cc");
    init_fairygui();
    _PinchGesture = class _PinchGesture extends Gesture {
      constructor() {
        super(...arguments);
        /// <summary>
        /// 总共缩放的量。
        /// </summary>
        this.scale = 0;
        /// <summary>
        /// 从上次通知后的改变量。
        /// </summary>
        this.delta = 0;
        /**
         * 中心位置
         */
        this.center = new import_cc18.Vec2();
        this._startDistance = 0;
        this._lastScale = 0;
        this._started = false;
        this._touchBegan = false;
        this._enabled = false;
      }
      enable(value) {
        if (value) {
          if (!this._enabled) {
            this.on(Event.TOUCH_BEGIN, this.__touchBegin, this);
            this._enabled = true;
          }
        } else {
          this._started = false;
          this._touchBegan = false;
          if (this._enabled) {
            this.off(Event.TOUCH_BEGIN, this.__touchBegin, this);
            this._enabled = false;
          }
        }
      }
      dispose() {
        super.dispose();
        this.enable(false);
      }
      __touchBegin(evt) {
        let touchIds = this.getTouchIds();
        if (touchIds.length == 2) {
          if (!this._started && !this._touchBegan) {
            this._touchBegan = true;
            evt.captureTouch();
            let pt1 = GRoot.inst.getTouchPosition(touchIds[0]);
            let pt2 = GRoot.inst.getTouchPosition(touchIds[1]);
            let dist = import_cc18.Vec2.distance(pt1, pt2);
            this._startDistance = Math.max(1, dist);
            GRoot.inst.on(Event.TOUCH_MOVE, this.__touchMove, this);
            GRoot.inst.on(Event.TOUCH_END, this.__touchEnd, this);
            console.log("PinchGesture begin");
          }
        } else if (this._started) {
          this.__touchEnd(evt);
        }
      }
      __touchMove(evt) {
        let touchIds = this.getTouchIds();
        if (!this._touchBegan || touchIds.length != 2) {
          this.__touchEnd(evt);
          return;
        }
        let pt1 = GRoot.inst.getTouchPosition(touchIds[0]);
        let pt2 = GRoot.inst.getTouchPosition(touchIds[1]);
        let dist = import_cc18.Vec2.distance(pt1, pt2);
        this.center.set(pt1);
        this.center.add(pt2).multiplyScalar(0.5);
        if (!this._started && Math.abs(dist - this._startDistance) > this.touchDragSensitivity) {
          this._started = true;
          this.scale = 1;
          this._lastScale = 1;
          this.emit(_PinchGesture.PINCH_BEGIN, evt);
        }
        if (this._started) {
          let ss = dist / this._startDistance;
          this.delta = ss - this._lastScale;
          this._lastScale = ss;
          this.scale += this.delta;
          this.emit(_PinchGesture.PINCH_ACTION, evt);
        }
      }
      __touchEnd(evt) {
        if (!this._touchBegan) {
          return;
        }
        GRoot.inst.off(Event.TOUCH_MOVE, this.__touchMove, this);
        GRoot.inst.off(Event.TOUCH_END, this.__touchEnd, this);
        this._touchBegan = false;
        if (this._started) {
          this._started = false;
          this.emit(_PinchGesture.PINCH_END, evt);
          console.log("PinchGesture end");
        } else {
          console.log("PinchGesture cancel");
        }
      }
    };
    /// <summary>
    /// 当两个手指开始呈捏手势时派发该事件。
    /// </summary>
    _PinchGesture.PINCH_BEGIN = "onPinchBegin";
    /// <summary>
    /// 当其中一个手指离开屏幕时派发该事件。
    /// </summary>
    _PinchGesture.PINCH_END = "onPinchEnd";
    /// <summary>
    /// 当手势动作时派发该事件。
    /// </summary>
    _PinchGesture.PINCH_ACTION = "onPinchAction";
    PinchGesture = _PinchGesture;
  }
});

// assets/scripts/framework/plugins/gesture/SwipeGesture.ts
var SwipeGesture_exports = {};
__export(SwipeGesture_exports, {
  default: () => SwipeGesture
});
var import_cc19, _SwipeGesture, SwipeGesture, s_vec22;
var init_SwipeGesture = __esm({
  "assets/scripts/framework/plugins/gesture/SwipeGesture.ts"() {
    import_cc19 = require("cc");
    init_fairygui();
    init_Pool();
    init_Timer();
    init_Gesture();
    _SwipeGesture = class _SwipeGesture extends Gesture {
      constructor() {
        super(...arguments);
        /// <summary>
        /// 手指离开时的加速度
        /// </summary>
        this.velocity = new import_cc19.Vec2(0, 0);
        /// <summary>
        /// 你可以在onBegin事件中设置这个值，那个后续将根据手指移动的距离修改这个值。如果不设置，那position初始为(0,0)，反映手指扫过的距离。
        /// </summary>
        this.position = new import_cc19.Vec2(0, 0);
        /// <summary>
        /// 移动的变化值
        /// </summary>
        this.delta = new import_cc19.Vec2(0, 0);
        /// <summary>
        /// The min distance to fire onAction event
        /// 派发onAction事件的最小距离。如果手指扫过的距离少于此值，onAction不会触发（但onEnd仍然会派发）
        /// </summary>
        this.actionDistance = 0;
        /// <summary>
        /// 是否把变化量强制为整数。默认true。
        /// </summary>
        this.snapping = true;
        this._enabled = false;
        this._startPoint = new import_cc19.Vec2(0, 0);
        this._lastPoint = new import_cc19.Vec2(0, 0);
        this._lastPoint2 = new import_cc19.Vec2(0, 0);
        this._time = 0;
        this._deltaTime = 0;
        this._started = false;
        this._touchBegan = false;
        this._lastTouchId = -1;
      }
      enable(value) {
        if (value) {
          if (!this._enabled) {
            this.on(Event.TOUCH_BEGIN, this.__touchBegin, this);
            this._enabled = true;
          }
        } else {
          this._started = false;
          this._touchBegan = false;
          if (this._enabled) {
            this.off(Event.TOUCH_BEGIN, this.__touchBegin, this);
            this._enabled = false;
          }
        }
      }
      dispose() {
        super.dispose();
        this.enable(false);
      }
      __touchBegin(evt) {
        let touchIds = this.getTouchIds();
        if (touchIds.length > 1) {
          this._touchBegan = false;
          if (this._started) {
            this._started = false;
            this.emit(_SwipeGesture.SWIPE_END, evt);
          }
          return;
        }
        s_vec22 = this.host.globalToLocal(evt.pos.x, evt.pos.y, s_vec22);
        this._lastPoint.set(s_vec22);
        this._startPoint.set(s_vec22);
        this._time = Timer.inst.unscaleTimer;
        this._started = false;
        this.velocity.set(0, 0);
        this.position.set(0, 0);
        this._touchBegan = true;
        this._lastTouchId = evt.touchId;
        evt.captureTouch();
        GRoot.inst.on(Event.TOUCH_MOVE, this.__touchMove, this);
        GRoot.inst.on(Event.TOUCH_END, this.__touchEnd, this);
      }
      __touchMove(evt) {
        let touchIds = this.getTouchIds();
        if (!this._touchBegan || touchIds.length > 1 || evt.touchId != this._lastTouchId) {
          if (this._started) {
            this._started = false;
            this.emit(_SwipeGesture.SWIPE_END, evt);
          }
          return;
        }
        s_vec22 = this.host.globalToLocal(evt.pos.x, evt.pos.y, s_vec22);
        let curPos = Vec2Pool.get(s_vec22);
        s_vec22.subtract(this._lastPoint);
        this.delta.set(s_vec22);
        if (this.snapping) {
          this.delta.x = Math.round(this.delta.x);
          this.delta.y = Math.round(this.delta.y);
          if (this.delta.x == 0 && this.delta.y == 0) {
            return;
          }
        }
        let deltaTime = Timer.inst.unscaleDelta * 1e-3;
        let elapsed = (Timer.inst.unscaleTimer - this._time) * 1e-3 * 60 - 1;
        if (elapsed > 1) {
          this.velocity.multiplyScalar(Math.pow(0.833, elapsed));
        }
        s_vec22.set(this.delta);
        s_vec22.divide2f(deltaTime, deltaTime);
        import_cc19.Vec2.lerp(this.velocity, this.velocity, s_vec22, deltaTime * 10);
        this._time = Timer.inst.unscaleTimer;
        this.position.add(this.delta);
        this._lastPoint2.set(this._lastPoint);
        this._lastPoint.set(curPos);
        Vec2Pool.put(curPos);
        if (!this._started) {
          let sensitivity = 0;
          sensitivity = this.touchDragSensitivity;
          if (Math.abs(this.delta.x) < sensitivity && Math.abs(this.delta.y) < sensitivity) {
            return;
          }
          this._started = true;
          this.emit(_SwipeGesture.SWIPE_BEGIN, evt);
        }
        this.emit(_SwipeGesture.SWIPE_MOVE, evt);
      }
      __touchEnd(evt) {
        this._touchBegan = false;
        GRoot.inst.off(Event.TOUCH_MOVE, this.__touchMove, this);
        GRoot.inst.off(Event.TOUCH_END, this.__touchEnd, this);
        if (!this._started) {
          return;
        }
        this._started = false;
        this._lastTouchId = -1;
        s_vec22 = this.host.globalToLocal(evt.pos.x, evt.pos.y, s_vec22);
        let pt = Vec2Pool.get(s_vec22);
        this.delta.set(s_vec22.subtract(this._lastPoint2));
        if (this.snapping) {
          this.delta.x = Math.round(this.delta.x);
          this.delta.y = Math.round(this.delta.y);
        }
        let elapsed = (Timer.inst.unscaleTimer - this._time) * 1e-3 * 60 - 1;
        if (elapsed > 1) {
          this.velocity.multiplyScalar(Math.pow(0.833, elapsed));
        }
        if (this.snapping) {
          this.velocity.x = Math.round(this.velocity.x);
          this.velocity.y = Math.round(this.velocity.y);
        }
        this.emit(_SwipeGesture.SWIPE_END, evt);
        pt.subtract(this._startPoint);
        if (Math.abs(pt.x) > this.actionDistance || Math.abs(pt.y) > this.actionDistance) {
          this.emit(_SwipeGesture.SWIPE_ACTION, evt);
        }
        Vec2Pool.put(pt);
      }
    };
    /// <summary>
    /// 当手指开始扫动时派发该事件。
    /// </summary>
    _SwipeGesture.SWIPE_BEGIN = "onSwipeBegin";
    /// <summary>
    /// 手指离开屏幕时派发该事件。
    /// </summary>
    _SwipeGesture.SWIPE_END = "onSwipeEnd";
    /// <summary>
    /// 手指在滑动时派发该事件。
    /// </summary>
    _SwipeGesture.SWIPE_MOVE = "onSwipeMove";
    /// <summary>
    /// 当手指从按下到离开经过的距离大于actionDistance时派发该事件。
    /// </summary>
    _SwipeGesture.SWIPE_ACTION = "onSwipeAction";
    SwipeGesture = _SwipeGesture;
    s_vec22 = new import_cc19.Vec2(0, 0);
  }
});

// assets/scripts/framework/plugins/reddot/serialize.ts
var serialize_exports = {};
__export(serialize_exports, {
  TNode: () => TNode,
  TTree: () => TTree
});
var TNode, TTree;
var init_serialize = __esm({
  "assets/scripts/framework/plugins/reddot/serialize.ts"() {
    TNode = class {
    };
    TTree = class {
    };
  }
});

// assets/scripts/framework/plugins/reddot/RedDotNode.ts
var RedDotNode_exports = {};
__export(RedDotNode_exports, {
  RedDotNode: () => RedDotNode
});
var _RedDotNode, RedDotNode;
var init_RedDotNode = __esm({
  "assets/scripts/framework/plugins/reddot/RedDotNode.ts"() {
    init_EventHandler();
    init_serialize();
    _RedDotNode = class _RedDotNode {
      constructor(tree, name, path4, parent, userData) {
        this._selfMsgCount = 0;
        this._dirty = false;
        this._messageCount = 0;
        this._internalOp = false;
        this._level = 0;
        this._tree = tree;
        this._name = name;
        this._path = path4;
        this.userData = userData;
        this._key = _RedDotNode._sKey++;
        this._children = [];
        if (parent != null && parent.children.indexOf(this) < 0) {
          parent.addChild(this);
        }
      }
      get onChanged() {
        if (!this._onChanged) {
          this._onChanged = new EventHandler();
        }
        return this._onChanged;
      }
      get tree() {
        return this._tree;
      }
      get key() {
        return this._key;
      }
      get name() {
        return this._name;
      }
      get path() {
        return this._path;
      }
      get parent() {
        return this._parent;
      }
      get children() {
        return this._children;
      }
      get level() {
        return this._level;
      }
      get messageCount() {
        if (!this._dirty) {
          return this._messageCount;
        }
        this._dirty = false;
        this._messageCount = this._selfMsgCount;
        for (let i = 0; i < this._children.length; i++) {
          this._messageCount += this._children[i].messageCount;
        }
        return this._messageCount;
      }
      addChild(node) {
        if (node == null || this.children.indexOf(node) >= 0) {
          return;
        }
        node.removeFromParent();
        this._children.push(node);
        node._parent = this;
        node._level = this._level + 1;
      }
      removeFromParent() {
        if (this._parent) {
          this._parent.removeChild(this);
        }
      }
      removeChild(node) {
        let idx = this.children.indexOf(node);
        if (node == null || idx < 0) {
          return;
        }
        node._parent = null;
        node._level = 0;
        this.children.splice(idx, 1);
      }
      addMessage(count = 1) {
        this._selfMsgCount = Math.max(0, this._selfMsgCount + count);
        this.onDirty();
      }
      setMessage(count = 1) {
        this._selfMsgCount = Math.max(0, count);
        this.onDirty();
      }
      clearMessage() {
        this._selfMsgCount = 0;
        this.onDirty();
      }
      clearAllMessage() {
        this._internalOp = true;
        this.clearMessage();
        for (let i = 0; i < this.children.length; i++) {
          this.children[i].clearAllMessage();
        }
        this._internalOp = false;
        this.onDirty();
      }
      onDirty() {
        this._dirty = true;
        if (this._internalOp) {
          return;
        }
        this.onChanged.fire(this);
        if (this._parent) {
          this._parent.onDirty();
        }
      }
      toTNode() {
        var _a;
        let tnode = new TNode();
        tnode.key = this._key;
        tnode.name = this._name;
        tnode.parent = ((_a = this._parent) == null ? void 0 : _a.key) ?? -1;
        tnode.selfCount = this._selfMsgCount;
        tnode.totalCount = this._messageCount;
        return tnode;
      }
      fromTNode(node) {
        this._key = node.key;
        this._name = node.name;
        this._path = node.name;
        this._selfMsgCount = node.selfCount;
        this._messageCount = node.totalCount;
        if (node.parent != -1) {
          let p = this.tree.getNode(node.parent);
        }
      }
      tranverse(nodes) {
        nodes.push(this);
        for (let i = 0; i < this.children.length; i++) {
          let node = this.children[i];
          node.tranverse(nodes);
        }
      }
      convertToTNodes() {
        let nodes = [];
        this.tranverse(nodes);
        let tnodes = nodes.map((i) => i.toTNode());
        tnodes.sort((a, b) => {
          return a.key - b.key;
        });
        return tnodes;
      }
      static createNode(tree, nodes, onAddNode) {
        if (nodes == null || nodes.length == 0) return null;
        nodes.sort((a, b) => {
          return a.key - b.key;
        });
        let maxKey = -1;
        let root = new _RedDotNode(tree);
        root.fromTNode(nodes[0]);
        for (let i = 0; i < nodes.length; i++) {
          let node = new _RedDotNode(tree);
          node.fromTNode(node[i]);
          maxKey = Math.max(node.key, maxKey);
          onAddNode || onAddNode(node);
        }
        this._sKey = Math.max(this._sKey, maxKey);
        return root;
      }
    };
    _RedDotNode._sKey = 1;
    RedDotNode = _RedDotNode;
  }
});

// assets/scripts/framework/plugins/reddot/RedDotTree.ts
var RedDotTree_exports = {};
__export(RedDotTree_exports, {
  RedDotTree: () => RedDotTree
});
var RedDotTree;
var init_RedDotTree = __esm({
  "assets/scripts/framework/plugins/reddot/RedDotTree.ts"() {
    init_RedDotNode();
    init_serialize();
    RedDotTree = class _RedDotTree {
      constructor() {
        this._keyNodes = {};
        this._pathNodes = {};
        this._root = null;
        this._root = new RedDotNode(this, "root", "");
        this._keyNodes[this._root.key] = this._root;
        this._pathNodes[this._root.path] = this._root;
      }
      get root() {
        return this._root;
      }
      printTree() {
        let sb = [`---${this._root.name}:${this._root.messageCount}---`];
        if (this.root.children.length > 0) {
          let nodes = this.root.children;
          this.print(sb, nodes);
        }
        console.log(sb.join());
      }
      print(sb, nodes) {
        sb.push("\r\n\r\n");
        let subnodes = [];
        let list = [];
        var maxChildCnt = 0;
        nodes.forEach((item) => {
          maxChildCnt = Math.max((item == null ? void 0 : item.children.length) || 0, 0);
        });
        for (let i = 0; i < nodes.length; i++) {
          let child = nodes[i];
          if (child != null) {
            sb.push(`---${child.name}:${child.messageCount}---`);
          } else {
            sb.push("----");
          }
          for (let j = 0; j < maxChildCnt; j++) {
            if (child && j < child.children.length) {
              list.push(child.children[j]);
            } else {
              list.push(null);
            }
          }
        }
        if (list.length > 0) {
          this.print(sb, list);
        }
      }
      addMessage(key, count = 1) {
        let node = this.getNode(key);
        if (node == null) {
          throw `can not find node which key equal to ${key}`;
        }
        node.addMessage(count);
      }
      setMessage(key, count = 1) {
        let node = this.getNode(key);
        if (!node) {
          throw `can not find node which key equal to ${key}`;
        }
        node.setMessage(count);
      }
      clearMessage(key) {
        let node = this.getNode(key);
        if (node == null) {
          throw `can not find node which key equal to ${key}`;
        }
        node.clearMessage();
      }
      clearAllMessage(key) {
        let node = this.getNode(key);
        if (node == null) {
          throw `can not find node which key equal to ${key}`;
        }
        node.clearAllMessage();
      }
      addNode(path4, userData, index = -1) {
        if (!path4.trim()) {
          throw "path can not be empty";
        }
        path4 = _RedDotTree.getChildPath(path4, index);
        let n = this.getNodeByPath(path4);
        if (n) {
          n.userData = userData;
          return n;
        }
        let strs = path4.split(".");
        let baseNode = this._root;
        let subPath = [];
        for (let i = 0; i < strs.length; i++) {
          let name = strs[i];
          if (i > 0) {
            subPath.push(".");
          }
          subPath.push(name);
          let spath = subPath.join();
          let node = this.getNodeByPath(spath);
          let last = i == strs.length - 1;
          if (!node) {
            node = new RedDotNode(this, name, spath, baseNode, last ? userData : null);
            this._keyNodes[node.key] = node;
            this._pathNodes[spath] = node;
          } else {
            node.userData = userData;
          }
          baseNode = node;
        }
        return baseNode;
      }
      removeNode(node) {
        if (node) {
          if (node.parent) {
            node.parent.removeChild(node);
          }
          delete this._keyNodes[node.key];
          delete this._pathNodes[node.path];
        }
      }
      removeNodeByPath(path4, index = -1) {
        path4 = _RedDotTree.getChildPath(path4, index);
        let node = this.getNodeByPath(path4);
        this.removeNode(node);
      }
      removeNodeByKey(key) {
        let node = this.getNode(key);
        this.removeNode(node);
      }
      getNode(key) {
        return this._keyNodes[key];
      }
      getNodeByPath(path4, index = -1) {
        path4 = _RedDotTree.getChildPath(path4, index);
        return this._pathNodes[path4];
      }
      serialize() {
        let tree = new TTree();
        tree.nodes = this.root.convertToTNodes();
        return JSON.stringify(tree);
      }
      deserialize(data) {
        let tree = JSON.parse(data);
        this._keyNodes = {};
        this._pathNodes = {};
        let root = RedDotNode.createNode(this, tree.nodes, (node) => {
          this._keyNodes[node.key] = node;
          this._pathNodes[node.path] = node;
        });
      }
      static getChildPath(path4, index) {
        if (index < 0) {
          return path4;
        }
        return `${path4}.${index}`;
      }
    };
  }
});

// assets/scripts/framework/plugins/reddot/RedDotManager.ts
var RedDotManager_exports = {};
__export(RedDotManager_exports, {
  RedDotItemInfo: () => RedDotItemInfo,
  RedDotManager: () => RedDotManager
});
var import_cc20, RedDotItemInfo, compPool, RedDotManager;
var init_RedDotManager = __esm({
  "assets/scripts/framework/plugins/reddot/RedDotManager.ts"() {
    import_cc20 = require("cc");
    init_fairygui();
    init_RedDotTree();
    init_Timer();
    RedDotItemInfo = class {
      constructor() {
        /**
         * 控制器名称，如果为空，选择第一个
         */
        this.controllerName = null;
        /**
         * 控制器选择
         */
        this.selectedIndex = -1;
        // 相对位置(0-1)
        this.pos = (0, import_cc20.v2)();
      }
    };
    compPool = /* @__PURE__ */ new Map();
    RedDotManager = class _RedDotManager {
      constructor() {
        this._tree = new RedDotTree();
      }
      static get inst() {
        if (!this._inst) {
          this._inst = new _RedDotManager();
        }
        return this._inst;
      }
      get tree() {
        return this._tree;
      }
      initial(defaultResUrl, onRedDotShown) {
        this._defaultRedDotResUrl = defaultResUrl;
        this._onReddotShown = onRedDotShown;
        if (!onRedDotShown) {
          this._onReddotShown = this._internalShowReddot;
        }
      }
      create(path4, childNum = 0) {
        let node = this._tree.addNode(path4);
        for (let i = 0; i < childNum; i++) {
          const childPath = RedDotTree.getChildPath(path4, i);
          this.create(childPath);
        }
        return node;
      }
      regist(path4, config) {
        let index = config.index ?? -1;
        let info = null;
        let node = this._tree.getNodeByPath(path4, index);
        if (node) {
          info = node.userData;
        }
        if (!info) {
          info = new RedDotItemInfo();
        }
        info.holder = config.holder;
        info.pos.set(config.pos);
        info.controllerName = config.controllerName;
        info.selectedIndex = config.ctrlIdx ?? -1;
        info.onRender = config.onRender;
        info.realDocker = config.realDocker;
        node = this.bind(path4, info, index);
        this._regist(path4);
        return node;
      }
      bind(path4, info, index = -1) {
        if (info.node) {
          this.unRegist(info.node, false);
        }
        let node = this._tree.getNodeByPath(path4, index);
        node.userData = info;
        info.node = node;
        return node;
      }
      _regist(path4) {
        let node = this._tree.getNodeByPath(path4);
        node.onChanged.add(this._internalHandleNodeChanged, this);
        this.refresh(path4);
        return node;
      }
      refresh(path4) {
        let node = this._tree.getNodeByPath(path4);
        if (node) {
          this._internalHandleNodeChanged(node);
        }
      }
      unRegist(node, destory = false) {
        if (node) {
          let data = node.userData;
          if (data && data.reddot) {
            if (destory) {
              data.reddot.dispose();
              data.reddot = null;
            } else {
              let url = data.reddotResUrl ?? this._defaultRedDotResUrl;
              let pool = compPool.get(url);
              if (!pool) {
                pool = [];
                compPool.set(url, pool);
              }
              pool.push(data.reddot);
              data.reddot.removeFromParent();
              data.reddot = null;
            }
          }
          node.onChanged.remove(this._internalHandleNodeChanged, this);
          if (node.children) {
            for (let child of node.children) {
              this.unRegist(child, destory);
            }
          }
        }
      }
      showRedDot(node) {
        if (!node) {
          return;
        }
        if (!node.userData) {
          return;
        }
        let info = node.userData;
        let reddot = info.reddot;
        if (reddot) {
          reddot.visible = true;
        }
      }
      hideRedDot(node) {
        if (!node.userData) {
          return;
        }
        let info = node.userData;
        let reddot = info.reddot;
        if (reddot) {
          reddot.visible = false;
        }
      }
      refreshRedDot(path4) {
        let node = this._tree.getNodeByPath(path4);
        if (node) {
          let info = node.userData;
          let reddot = info.reddot;
          if (reddot) {
            this.setPosition(reddot, info, false);
          }
        }
      }
      setPosition(reddot, info, add) {
        let x = info.holder.width * info.pos.x;
        let y = info.holder.height * info.pos.y;
        if (info.realDocker !== null) {
          if (add) {
            info.realDocker.addChild(reddot);
          }
          if (info.holder.pivotAsAnchor) {
            x -= info.holder.width * info.holder.pivotX;
            y -= info.holder.height * info.holder.pivotY;
          }
          Timer.inst.callLater(() => {
            let pos = info.holder.localToGlobal(x, y, new import_cc20.Vec2());
            pos = info.realDocker.globalToLocal(pos.x, pos.y, pos);
            reddot.setPosition(pos.x, pos.y);
          }, this);
        } else {
          if (add) {
            info.holder.addChild(reddot);
          }
          reddot.setPosition(x, y);
        }
      }
      _internalShowReddot(node, info) {
        if (info.onRender) {
          info.onRender(node, info);
        }
      }
      _internalHandleNodeChanged(node) {
        if (!node.userData) {
          return;
        }
        let info = node.userData;
        let reddot = info.reddot;
        if (node.messageCount > 0) {
          if (reddot == null) {
            const url = info.reddotResUrl ?? this._defaultRedDotResUrl;
            let reddotPool = compPool.get(url);
            while ((reddot == null || reddot.isDisposed) && reddotPool && reddotPool.length > 0) {
              reddot = reddotPool.pop();
            }
            if (!reddot) {
              reddot = UIPackage.createObjectFromURL(url);
            }
            if (reddot) {
              info.holder.addChild(reddot);
              this.setPosition(reddot, info, true);
              info.reddot = reddot;
            }
          }
          if (reddot) {
            reddot.visible = true;
            reddot.text = node.messageCount.toString();
            this._onReddotShown(node, info);
          }
        } else if (reddot) {
          reddot.visible = false;
        }
      }
    };
  }
});

// assets/scripts/framework/utils/MathUtils.ts
var MathUtils_exports = {};
__export(MathUtils_exports, {
  MathUtils: () => MathUtils
});
var MathUtils;
var init_MathUtils = __esm({
  "assets/scripts/framework/utils/MathUtils.ts"() {
    MathUtils = class {
      /**
       * 返回一个随机整数
       * @param min 最小数，左闭
       * @param max 最大数，右闭
       */
      static randomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1) + min);
      }
      /** 随机返回一个数组成员 */
      static randOneList(list) {
        let results;
        results = list[this.randomInt(0, list.length - 1)];
        return results;
      }
      /**
       * 判定是否满足随机条件
       * @param weight 权重
       * @param totalWeight 总权重 
       * @returns 
       */
      static randRequest(weight, totalWeight) {
        return Math.random() * totalWeight <= weight;
      }
      /**
       * 通过权重随机一个
       * @param weightList 
       * @returns 
       */
      static randomByWeight(weightList) {
        let totalWeight = 0;
        for (let i = 0; i < weightList.length; i++) {
          totalWeight += weightList[i];
        }
        let rand = Math.random() * totalWeight;
        let index = 0;
        for (let i = 0; i < weightList.length; i++) {
          if (rand <= weightList[i]) {
            index = i;
            break;
          }
          rand -= weightList[i];
        }
        return index;
      }
      static listWeightSelect(source, key = "weight") {
        let sum = 0;
        for (const itr of source) {
          sum += itr[key];
        }
        let random = Math.random() * sum;
        for (const itr of source) {
          if (random <= itr[key]) {
            return itr;
          }
          random = random - itr[key];
        }
        return source[0];
      }
      static shuffle(arr) {
        const result = [];
        while (arr.length > 0) {
          const rdm = Math.floor(Math.random() * arr.length);
          result.push(arr[rdm]);
          arr.splice(rdm, 1);
        }
        return result;
      }
      static seededRandomInt(min, max, seed) {
        return Math.floor(this.seededRandom(min, max, seed));
      }
      static remap(x, t1, t2, s1, s2) {
        return (s2 - s1) / (t2 - t1) * (x - t1) + s1;
      }
    };
    MathUtils.seededRandom = function(min, max, seed) {
      max = max || 1;
      min = min || 0;
      seed = (seed * 9301 + 49297) % 233280;
      let rnd = seed / 233280;
      return min + rnd * (max - min);
    };
  }
});

// assets/scripts/framework/utils/SpaceUtils.ts
var SpaceUtils_exports = {};
__export(SpaceUtils_exports, {
  SpaceUtils: () => SpaceUtils
});
var import_cc21, s_vec23, s_vec32, s_vec3_22, SpaceUtils;
var init_SpaceUtils = __esm({
  "assets/scripts/framework/utils/SpaceUtils.ts"() {
    import_cc21 = require("cc");
    init_Pool();
    init_fairygui();
    s_vec23 = new import_cc21.Vec2();
    s_vec32 = new import_cc21.Vec3();
    s_vec3_22 = new import_cc21.Vec3();
    SpaceUtils = class {
      static convertTouchLocationToNodeSpaceAR(pos, node, outPos, nodeCamera) {
        var camera = nodeCamera ? nodeCamera.camera : import_cc21.director.root.batcher2D.getFirstRenderCamera(node);
        s_vec3_22.set(pos.x, pos.y, 0);
        camera.screenToWorld(s_vec32, s_vec3_22);
        node._uiProps.uiTransformComp.convertToNodeSpaceAR(s_vec32, s_vec3_22);
        if (!outPos) {
          outPos = new import_cc21.Vec3();
        }
        outPos.set(s_vec3_22);
        return outPos;
      }
      static convertTouchLocationToGRoot(pos, node, outPos, nodeCamera) {
        let vec3 = Vec3Pool.get();
        this.convertTouchLocationToNodeSpaceAR(pos, node, vec3, nodeCamera);
        let vec2 = Vec2Pool.get(vec3.x, vec3.y);
        this.cnode2groot(vec2, node, vec2);
        if (!outPos) {
          outPos = new import_cc21.Vec2();
        }
        outPos.set(vec2);
        Vec3Pool.put(vec3);
        Vec2Pool.put(vec2);
        return outPos;
      }
      static convertToNodeSpace(pos, sourceNode, targetNode, outPos) {
        if (!outPos) {
          outPos = new import_cc21.Vec3();
        }
        outPos.set(s_vec32);
        sourceNode.updateWorldTransform();
        targetNode.updateWorldTransform();
        sourceNode._uiProps.uiTransformComp.convertToWorldSpaceAR(pos, outPos);
        targetNode._uiProps.uiTransformComp.convertToNodeSpaceAR(outPos, outPos);
        return outPos;
      }
      static grootYFlip(gpos, outpos) {
        s_vec32.set(gpos.x, GRoot.inst.height - gpos.y, 0);
        if (!outpos) {
          outpos = new import_cc21.Vec2();
        }
        outpos.set(s_vec32.x, s_vec32.y);
        return outpos;
      }
      static groot2Screen(gpos, outpos) {
        outpos = this.grootYFlip(gpos, outpos);
        s_vec32.set(outpos.x, outpos.y, 0);
        var camera = import_cc21.director.root.batcher2D.getFirstRenderCamera(GRoot.inst.node);
        camera.worldToScreen(s_vec32, s_vec32);
        outpos.set(s_vec32.x, s_vec32.y);
        return outpos;
      }
      static groot2cnode(gpos, node, outpos) {
        var camera = import_cc21.director.root.batcher2D.getFirstRenderCamera(GRoot.inst.node);
        s_vec32.set(gpos.x, GRoot.inst.height - gpos.y, 0);
        camera.worldToScreen(s_vec3_22, s_vec32);
        camera = import_cc21.director.root.batcher2D.getFirstRenderCamera(node);
        camera.screenToWorld(s_vec32, s_vec3_22);
        node.updateWorldTransform();
        node.getComponent(import_cc21.UITransform).convertToNodeSpaceAR(s_vec32, s_vec3_22);
        if (!outpos) {
          outpos = new import_cc21.Vec2();
        }
        outpos.set(s_vec3_22.x, s_vec3_22.y);
        return outpos;
      }
      static cnode2fnode(npos, node, fnode, outpos) {
        this.cnode2groot(npos, node, outpos);
        fnode.globalToLocal(outpos.x + fnode.width * fnode.pivotX, outpos.y + fnode.height * fnode.pivotY, outpos);
        return outpos;
      }
      static world2groot(node, camera, outpos) {
        node.updateWorldTransform();
        node.getWorldPosition(s_vec32);
        camera.convertToUINode(s_vec32, GRoot.inst.node, s_vec32);
        s_vec32.y = -s_vec32.y;
        if (!outpos) {
          outpos = new import_cc21.Vec2();
        }
        outpos.set(s_vec32.x, s_vec32.y);
        return outpos;
      }
      static cnode2groot(npos, node, outpos) {
        var camera = import_cc21.director.root.batcher2D.getFirstRenderCamera(node);
        s_vec3_22.set(npos.x, npos.y);
        node.updateWorldTransform();
        node.getComponent(import_cc21.UITransform).convertToWorldSpaceAR(s_vec3_22, s_vec32);
        camera.worldToScreen(s_vec3_22, s_vec32);
        camera = import_cc21.director.root.batcher2D.getFirstRenderCamera(GRoot.inst.node);
        camera.screenToWorld(s_vec32, s_vec3_22);
        s_vec23.set(s_vec32.x, GRoot.inst.height - s_vec32.y);
        if (!outpos) {
          outpos = new import_cc21.Vec2();
        }
        outpos.set(s_vec23);
        return outpos;
      }
      /**
       * 获取节点的中心世界坐标系坐标值
       * @param node 
       * @param outPos 
       * @returns 
       */
      static getNodeCenterInWorld(node, outPos) {
        let tr = node._uiProps.uiTransformComp;
        let temp = Vec3Pool.get();
        temp.set(tr.width * (0.5 - tr.anchorX), tr.height * (0.5 - tr.anchorY));
        tr.convertToWorldSpaceAR(temp, temp);
        outPos.set(temp.x, temp.y);
        Vec3Pool.put(temp);
        return outPos;
      }
      /**
       * 获取节点的中心坐标
       * @param go 
       * @param outPos 
       * @returns 
       */
      static getGObjectCenterPos(go, outPos) {
        let x = go.pivotAsAnchor ? go.width * (0.5 - go.pivotX) : go.width * 0.5;
        let y = go.pivotAsAnchor ? go.height * (0.5 - go.pivotY) : go.height * 0.5;
        if (!outPos) {
          outPos = new import_cc21.Vec2();
        }
        outPos.set(x, y);
        return outPos;
      }
    };
  }
});

// assets/scripts/framework/utils/TimeUtils.ts
var TimeUtils_exports = {};
__export(TimeUtils_exports, {
  TimeUtils: () => TimeUtils
});
var TimeUtils;
var init_TimeUtils = __esm({
  "assets/scripts/framework/utils/TimeUtils.ts"() {
    init_SystemController();
    TimeUtils = class {
      static isSameDay(time) {
        let nextDay = new Date(systemController.getTimeMS());
        let createTime = new Date(time);
        if (nextDay.getFullYear() != createTime.getFullYear() || nextDay.getMonth() != createTime.getMonth() || nextDay.getDate() != createTime.getDate()) {
          return false;
        }
        return true;
      }
      // 第一天为周一 而非周日
      static isSameWeek(time) {
        const today = new Date(systemController.getTimeMS());
        const day = today.getDay();
        const firstOfWeek = new Date(today.getTime() - ((day || 7) - 1) * 864e5);
        firstOfWeek.setHours(0, 0, 0, 0);
        const lastOfWeek = new Date(today.getTime() + (7 - (day || 7)) * 864e5);
        lastOfWeek.setHours(23, 59, 59, 999);
        return time >= firstOfWeek.getTime() && time <= lastOfWeek.getTime();
      }
      // 获取本周一0点的时间戳
      static getStartOfWeek() {
        const now = systemController.getServerDate();
        now.setDate(now.getDate() - ((now.getDay() || 7) - 1));
        now.setHours(0, 0, 0, 0);
        return Math.floor(now.getTime() / 1e3);
      }
      // 获取距离本周一0点的秒数
      static getPassedTimeByWeek() {
        return systemController.getTime() - this.getStartOfWeek();
      }
      /**
       * 判断是否是新的一天
       * @param {Object|Number} dateValue 时间（ms)
       * @returns {boolean}
       */
      static isNewDay(dateValue) {
        var oldDate = new Date(dateValue);
        var curDate = systemController.getServerDate();
        var oldYear = oldDate.getYear();
        var oldMonth = oldDate.getMonth();
        var oldDay = oldDate.getDate();
        var curYear = curDate.getYear();
        var curMonth = curDate.getMonth();
        var curDay = curDate.getDate();
        if (curYear > oldYear) {
          return true;
        } else {
          if (curMonth > oldMonth) {
            return true;
          } else {
            if (curDay > oldDay) {
              return true;
            }
          }
        }
        return false;
      }
      /**
       * 获取任意一天,任意时间点
       * @param day 天
       * @param hour 小时
       * @returns ms
       */
      static getDayTime(day = 0, hour = 0) {
        return new Date(new Date(systemController.getServerDate()).setDate(new Date(systemController.getServerDate()).getDate() + day)).setHours(hour, 0, 0, 0);
      }
      /**
       * 获取指定日期任意时间点
       * @param date 时间戳(s)
       * @param hour 小时
       * @returns ms
       */
      static getTargetDayTime(date, hour = 0) {
        let ret = new Date(date * 1e3).setHours(hour, 0, 0, 0);
        return ret;
      }
      /**
       * 把一天通过h划分n个等分,获取上一个整点位置
       * @param h 小时 必须24/h 必须为整数
       */
      static getLastBisectionTime(h) {
        let hour = new Date(systemController.getServerDate()).getHours();
        let num = Math.floor(hour / h);
        return this.getDayTime(0) + num * h * 60 * 60 * 1e3;
      }
      /**
       * 时间戳转换年月日时分秒
       * @param t 时间戳（秒）
       * @param type 1 年月日时分秒 2 年月日时分 3年月日
       * @returns 
       */
      static getYMDhms(t, type = 1) {
        var time = new Date(t * 1e3);
        var y = time.getFullYear();
        var m = time.getMonth() + 1;
        var d = time.getDate();
        if (type == 3) {
          return y + "." + this.add(m) + "." + this.add(d);
        }
        var h = time.getHours();
        var mm = time.getMinutes();
        var s = time.getSeconds();
        return y + "." + this.add(m) + "." + this.add(d) + " " + this.add(h) + ":" + this.add(mm) + (type == 2 ? "" : ":" + this.add(s));
      }
      //当前距离下周一0点的毫秒数
      static getWeekTime() {
        let now = systemController.getServerDate();
        let day = now.getDay();
        day = day == 0 ? 7 : day;
        let hour = now.getHours();
        let minute = now.getMinutes();
        let second = now.getSeconds();
        let millisecond = now.getMilliseconds();
        let weekTime = 864e5 * (7 - day + 1) - (hour * 60 * 60 * 1e3 + minute * 60 * 1e3 + second * 1e3 + millisecond);
        return weekTime;
      }
      /**
       * 返回 
       * @param t 秒
       * @param type 1： 00:00:00  2：1h2m  3 00:00:00(h为0也要) 4 hm 5h
       * @returns 
       */
      static getHMS(t, type = 1) {
        let h = Math.floor(t / 3600);
        let m = Math.floor(t % 3600 / 60);
        let s = Math.floor(t % 60);
        switch (type) {
          case 5:
            return h + "h";
          case 4:
            return this.add(h) + ":" + this.add(m);
          case 3:
            return this.add(h) + ":" + this.add(m) + ":" + this.add(s);
          case 2:
            return h > 0 ? h + "h" + (m > 0 ? m + "m" : "") : m + "m" + (s > 0 ? s + "s" : "");
          case 1:
          default:
            return h > 0 ? h + ":" + this.add(m) + ":" + this.add(s) : this.add(m) + ":" + this.add(s);
        }
      }
      /**
       * 返回 
       * @param t 秒
       * @returns 几天 不足1天返回0;
       */
      static getDay(t) {
        let d = Math.floor(t / (3600 * 24));
        return d;
      }
      static add(num) {
        return num < 10 ? "0" + num : num;
      }
      static dateFormat(time, fmt = "yyyy-MM-dd hh:mm:ss") {
        let date = new Date(time);
        var o = {
          "M+": date.getMonth() + 1,
          //月份
          "d+": date.getDate(),
          //日
          "h+": date.getHours(),
          //小时
          "m+": date.getMinutes(),
          //分
          "s+": date.getSeconds(),
          //秒
          "q+": Math.floor((date.getMonth() + 3) / 3),
          //季度
          "S": date.getMilliseconds()
          //毫秒
        };
        return this.formatDateOrTime(fmt, o, date.getFullYear());
      }
      static timeFormat(t, format = "hh:mm:ss") {
        const day = Math.floor(t / 86400);
        const hour = Math.floor(t % 86400 / 3600);
        const minute = Math.floor(t % 3600 / 60);
        const second = Math.floor(t % 60);
        var o = {
          "D+": day,
          "h+": hour,
          "m+": minute,
          "s+": second
        };
        return this.formatDateOrTime(format, o);
      }
      static formatDateOrTime(fmt, o, year) {
        if (year && /(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (year + "").substr(4 - RegExp.$1.length));
        for (var k in o) {
          if (new RegExp("(" + k + ")").test(fmt)) {
            fmt = fmt.replace(RegExp.$1, RegExp.$1.length == 1 ? o[k] : ("00" + o[k]).substr(("" + o[k]).length));
          }
        }
        return fmt;
      }
    };
  }
});

// assets/scripts/framework/view/ViewObject.ts
var ViewObject_exports = {};
__export(ViewObject_exports, {
  default: () => ViewObject
});
var ViewObject;
var init_ViewObject = __esm({
  "assets/scripts/framework/view/ViewObject.ts"() {
    ViewObject = class {
      get component() {
        return this.go.asCom;
      }
      get container() {
        return this.warpper ?? this.go.asCom;
      }
    };
  }
});

// assets/scripts/framework/view/ViewHelper.ts
var ViewHelper_exports = {};
__export(ViewHelper_exports, {
  ELayer: () => ELayer,
  ViewHelper: () => ViewHelper
});
var import_cc22, ELayer, _ViewHelper, ViewHelper;
var init_ViewHelper = __esm({
  "assets/scripts/framework/view/ViewHelper.ts"() {
    init_fairygui();
    init_Skin();
    init_ViewMap();
    import_cc22 = require("cc");
    ELayer = /* @__PURE__ */ ((ELayer2) => {
      ELayer2[ELayer2["Background"] = 0] = "Background";
      ELayer2[ELayer2["UI"] = 1] = "UI";
      ELayer2[ELayer2["Overlay"] = 2] = "Overlay";
      return ELayer2;
    })(ELayer || {});
    _ViewHelper = class _ViewHelper {
      constructor() {
        this._views = {};
        this._windows = {};
        this._packages = {};
        this._initialed = false;
        this._layers = new Array();
        this._scaleX = 1;
        this._scaleY = 1;
      }
      get scaleX() {
        return this._scaleX;
      }
      get scaleY() {
        return this._scaleY;
      }
      get scale() {
        return Math.min(this._scaleX, this._scaleY);
      }
      static get instance() {
        if (this._instance == null) {
          this._instance = new _ViewHelper();
        }
        return this._instance;
      }
      get packages() {
        return this._packages;
      }
      initialize(opts = null) {
        if (this._initialed) {
          return;
        }
        this._initialed = true;
        let dsize = import_cc22.view.getDesignResolutionSize();
        let screenRatio = screen.width / screen.height;
        let designRatio = dsize.x / dsize.y;
        if (screenRatio > designRatio) {
          let swidth = screen.height * designRatio;
          this._scaleY = 1;
          this._scaleX = swidth / screen.width;
        } else {
          let sheight = screen.width / designRatio;
          this._scaleX = 1;
          this._scaleY = sheight / screen.height;
        }
        this.addLayer();
        this.addLayer();
        this.addLayer();
      }
      addLayer() {
        let comp = new GComponent();
        comp.setSize(GRoot.inst.width, GRoot.inst.height);
        GRoot.inst.addChild(comp);
        comp.addRelation(GRoot.inst, RelationType.Size);
        this._layers.push(comp);
      }
      getLayer(layer) {
        return this._layers[layer];
      }
      createWindow(mediator) {
        if (!mediator) {
          console.error("class type cannot be null!");
          return null;
        }
        let view5 = new mediator();
        let skin = view5.skin;
        if (!this._packages[skin.path]) {
          let pkg = UIPackage.addPackage(skin.path);
          this._packages[skin.path] = pkg;
        }
        view5.initial();
        if (!view5.component) {
          return null;
        }
        return view5;
      }
      createView(skin, mediator, layer = 1 /* UI */) {
        if (!mediator) {
          console.error("class type cannot be null!");
          return null;
        }
        let view5 = new mediator();
        skin = view5.skin;
        if (!this._packages[skin.path]) {
          let pkg = UIPackage.addPackage(skin.path);
          this._packages[skin.path] = pkg;
        }
        view5.initial();
        if (!view5.viewObject.container) {
          return null;
        }
        let container = this.getLayer(layer);
        let warpper = view5.viewObject.container;
        if (warpper != container) {
          container.addChild(warpper);
        }
        warpper.setSize(container.width, container.height);
        warpper.setScale(1, 1);
        warpper.addRelation(container, RelationType.Size);
        view5.create();
        return view5;
      }
      getSingleWindowByName(name) {
        let skin = ViewMap.instance.getSkinByName(name);
        return this.getSingleWindow(skin);
      }
      getSingleWindow(skin) {
        if (!skin) {
          console.error("can not get undefined skin!");
          return null;
        }
        let key = skin.getKey();
        let view5 = this._windows[key];
        if (!view5) {
          let viewClass = ViewMap.instance.get(skin);
          view5 = this.createWindow(viewClass);
          if (view5) {
            this._windows[key] = view5;
          }
        }
        return view5;
      }
      getSingleWindowByType(viewClass) {
        if (!viewClass) {
          console.error("can not get undefined viewType!");
          return null;
        }
        let skin = Skin.getSkin(viewClass);
        let key = skin.getKey();
        let view5 = this._windows[key];
        if (!view5) {
          view5 = this.createWindow(viewClass);
          if (view5) {
            this._windows[key] = view5;
          }
        }
        return view5;
      }
      getSingleView(skin, layer = 1 /* UI */) {
        if (!skin) {
          console.error("can not get undefined viewType!");
          return null;
        }
        let key = skin.getKey();
        let view5 = this._views[key];
        if (!view5) {
          let viewClass = ViewMap.instance.get(skin);
          view5 = this.createView(skin, viewClass, layer);
          if (view5) {
            this._views[key] = view5;
          }
        }
        return view5;
      }
      getSingleViewByType(viewClass, layer = 1 /* UI */) {
        if (!viewClass) {
          console.error("can not get undefined viewType!");
          return null;
        }
        let tempSkin = Skin.getSkin(viewClass);
        if (!tempSkin) {
          console.error("can not get viewType's binding skin!");
          return null;
        }
        let tempKey = tempSkin.getKey();
        let view5 = this._views[tempKey];
        if (!view5) {
          view5 = this.createView(null, viewClass, layer);
          if (view5) {
            let skin = view5.skin;
            let key = skin.getKey();
            this._views[key] = view5;
          }
        }
        return view5;
      }
      destoryWindow(skin) {
        let key = skin.getKey();
        let view5 = this._windows[key];
        if (view5) {
          view5.dispose();
          delete this._windows[key];
        }
      }
      destroyView(skin, layer = 1 /* UI */) {
        let key = skin.getKey();
        let view5 = this._views[key];
        if (view5) {
          let ui = this.getLayer(layer);
          ui.removeChild(view5.viewObject.container);
          try {
            view5.dispose();
          } catch (e) {
            console.error("view " + skin.getKey() + " onDestroy() error:" + e);
          }
          delete this._views[key];
        }
      }
    };
    _ViewHelper._instance = null;
    ViewHelper = _ViewHelper;
  }
});

// assets/scripts/framework/view/Window.ts
var Window_exports = {};
__export(Window_exports, {
  default: () => Window2
});
var import_cc23, import_env9, _Window, Window2;
var init_Window = __esm({
  "assets/scripts/framework/view/Window.ts"() {
    init_fairygui();
    init_Skin();
    init_SkinHelper();
    init_Container();
    import_cc23 = require("cc");
    init_UIManager();
    init_Timer();
    init_fairygui();
    import_env9 = require("cc/env");
    init_CaptureHelper();
    init_fairygui();
    init_SoundManager();
    init_CoroutineUtils();
    _Window = class _Window extends Container {
      constructor() {
        super(...arguments);
        this._special = false;
        this._index = 0;
        this.canAutoDestory = true;
        this.modal = true;
        this.topMost = false;
        this.topPriority = 0;
        this.enableClose = true;
        this.hideOnOverlay = false;
        this.canShowBanner = false;
        /**
         * 为true时将会等待动画完成调用onShow,[onHide强制等待]
         */
        this.waitAnimation = false;
        this.safeTopMargin = 0;
        this.injectInfos = {};
        this._updating = false;
        this._secondTicker = 0;
        this._enableUpdate = false;
        this._exitCode = 0;
        this._isShowing = false;
        this._modalLayerColor = new import_cc23.Color();
        /**
         * 此模式下，窗口背景将会被截图，用于提高性能(ios下有问题，先关闭)
         */
        this.preformanceMode = false;
        /**
         * 标记为全屏模式，此模式下，表明activity完全不可见，activity将会被隐藏
         */
        this.fullMode = false;
        this._preformanceBG = null;
        this.contentAsFrame = false;
        this.enableDefaultAudio = true;
        this.hideAudioSource = 0;
        this.shownAudioSource = 0;
        this._needBeWait = false;
      }
      get needBeWait() {
        return this._needBeWait;
      }
      get component() {
        return this._component;
      }
      get visible() {
        return this.window.visible;
      }
      get exitCode() {
        return this._exitCode;
      }
      get isShowing() {
        return this._isShowing;
      }
      get modalLayerColor() {
        return this._modalLayerColor;
      }
      get skin() {
        if (!this._skin) {
          this._skin = Skin.getSkin(this.constructor);
        }
        return this._skin;
      }
      get enableUpdate() {
        return this._enableUpdate;
      }
      set enableUpdate(val) {
        if (this._enableUpdate != val) {
          this._enableUpdate = val;
          if (this._isShown) {
            this.setUpdateEnable(val);
          }
        }
      }
      get bringToFontOnClick() {
        var _a;
        return (_a = this.window) == null ? void 0 : _a.bringToFontOnClick;
      }
      set bringToFontOnClick(val) {
        if (this.window) {
          this.window.bringToFontOnClick = val;
        }
      }
      inject(go, data) {
        this.beginCreate();
        UIManager.instance.onContainerCreate(this);
        this._component = go;
        this.onInitial();
        var content = go;
        if (this.contentAsFrame) {
          content = new GComponent();
          content.setPosition(go.x, go.y);
          content.setSize(go.width, go.height);
          content.setPivot(go.pivotX, go.pivotY);
          content.addChild(go);
          go.setPosition(0, 0);
          go.name = "frame";
        }
        this.window = new Window();
        this.window.data = this;
        this.window.contentPane = content;
        SkinHelper.InjectView(go, this);
        if (this.fullMode) {
          this.window.makeFullScreen();
        }
        this.window.center();
        this.bringToFontOnClick = false;
        this.onAfterInitial();
        let ret = this.onCreate();
        if (ret instanceof Promise) {
          async () => {
            await ret;
            this.endCreate();
          };
        } else {
          this.endCreate();
        }
      }
      async enterPreformance() {
        if (!import_env9.NATIVE && this.preformanceMode && !this.fullMode) {
          let bg = await CaptureHelper.captureFullScreen();
          let sf = new import_cc23.SpriteFrame();
          sf.texture = bg;
          bg.addRef();
          let image = new GLoader();
          image.texture = sf;
          sf.addRef();
          image.setSize(GRoot.inst.width, GRoot.inst.height);
          image.fill = LoaderFillType.ScaleFree;
          GRoot.inst.addChildAt(image, 0);
          this._preformanceBG = image;
        }
        if (this.fullMode && this.preformanceMode) {
          let curAcivity = UIManager.instance.peekOrNull();
          if (curAcivity) {
            curAcivity.pause();
          }
        }
      }
      async exitPreformance() {
        if (this._preformanceBG) {
          this._preformanceBG.texture.texture.destroy();
          this._preformanceBG.texture.destroy();
          this._preformanceBG.dispose();
          this._preformanceBG = null;
        }
        if (this.fullMode && this.preformanceMode) {
          let curAcivity = UIManager.instance.peekOrNull();
          if (curAcivity) {
            curAcivity.resume(curAcivity.data);
          }
        }
      }
      initial() {
        UIPackage.addPackage(this.skin.path);
        let go = UIPackage.createObject(this.skin.packageName, this.skin.componentName);
        this.inject(go.asCom);
      }
      setModalLayerColor(color) {
        GRoot.inst.modalLayer.color.set(color);
        GRoot.inst.modalLayer.drawRect(0, import_cc23.Color.TRANSPARENT, color);
      }
      overlayBy(otherWindow) {
        if (this.hideOnOverlay) {
          this.component.visible = false;
        }
        this.onOverlayBy(otherWindow);
      }
      bringToFront() {
        if (this.modal) {
          this.setModalLayerColor(this._modalLayerColor);
        }
        this.onBringToFront();
        this.component.visible = true;
      }
      show(data) {
        this._isShown = false;
        this._exitCode = 0;
        this.component.visible = true;
        this.data = data;
        this.window.visible = true;
        this.window.modal = this.modal;
        this._isShowing = true;
        let ret = this.onBeforeShow(data);
        if (ret instanceof Promise) {
          (async () => {
            await ret;
            await this.internalShow(data, false);
          })();
        } else {
          this.internalShow(data, false);
        }
      }
      showImmediately() {
        this.window.show();
      }
      async internalShow(data, immediately) {
        var _a;
        this.enterPreformance();
        (_a = this.window) == null ? void 0 : _a.show();
        if (immediately) {
          this.showImmediately();
        } else {
          let ret2 = this.playShowAnimation();
          if (ret2 instanceof Promise) {
            if (this.waitAnimation) {
              await ret2;
            } else {
              (async () => {
                await ret2;
                this._isShowing = false;
              })();
            }
          }
          this._isShowing = false;
        }
        this.children.forEach((view5) => {
          view5.show(data, false);
        });
        this.safeAlign();
        let ret = this.onShown(data);
        if (ret instanceof Promise) {
          await ret;
        }
        this.endShown();
        this.registTap();
        this.setUpdateEnable(this.enableUpdate);
        const audioSource = this.shownAudioSource || (this.enableDefaultAudio ? _Window.defaultShowAudioSource : 0);
        if (audioSource) {
          SoundManager.instance.playSound(audioSource);
        }
      }
      safeAlign() {
        if (this.safeTopMargin > 0) {
          let offsetY = this.component.height * this.component.pivotY;
          let top = this.component.y - offsetY;
          if (top < this.safeTopMargin) {
            this.component.y = this.safeTopMargin + offsetY;
          }
        }
      }
      getModualLayer() {
        return this.modal ? GRoot.inst.modalLayer : UIManager.instance.peekOrNull().component;
      }
      async registTap() {
        await CoroutineUtils.oneframe();
        if (this.enableTapClose) {
          let comp = this.getModualLayer();
          comp.onClick(this.modualClick, this);
        }
      }
      clearModualClick() {
        let comp = this.getModualLayer();
        comp.offClick(this.modualClick, this);
      }
      async modualClick(event) {
        let topWindow = UIManager.instance.getTopModalWindow();
        await CoroutineUtils.oneframe();
        if (topWindow == this) {
          UIManager.instance.hideCurrentWindow(false, null, true);
          this.clearModualClick();
        }
      }
      async playShowAnimation() {
      }
      async playHideAnimation() {
      }
      async internalHide(hideImmediately, code) {
        this._exitCode = code || 0;
        this._component.touchable = false;
        this.setUpdateEnable(false);
        this.clearModualClick();
        this.clearEventCenter();
        this.exitPreformance();
        this.onBeforeHide();
        this.emit(_Window.EVENT_WINDOW_BEFORE_HIDE, this);
        if (hideImmediately) {
          this.hideImmediately();
        } else {
          await this.playHideAnimation();
        }
        this.children.forEach((view5) => {
          view5.hide(false);
        });
        this.onHide();
        this.window.visible = false;
        this._component.touchable = true;
        this.emit(_Window.EVENT_WINDOW_HIDE, this);
        const audioSource = this.hideAudioSource || (this.enableDefaultAudio ? _Window.defaultHideAudioSource : 0);
        if (audioSource) {
          SoundManager.instance.playSound(audioSource);
        }
      }
      hideImmediately() {
        if (this.enableClose) {
          this.window.hide();
        }
      }
      hide(code) {
        this.internalHide(true, code);
      }
      dispose() {
        if (this._destoried) {
          return;
        }
        this._destoried = true;
        this.clearEventCenter();
        this.children.forEach((view5) => {
          view5.dispose();
        });
        if (this.window) {
          this.window.dispose();
        }
        this.onDispose();
      }
      registInfos() {
      }
      makeFullScreen() {
        this.window.makeFullScreen();
        let y = (GRoot.inst.height - this.window.height) / 2;
        this.window.y = y;
      }
      setUpdateEnable(val) {
        if (this._updating == val) {
          return;
        }
        this._updating = val;
        if (val) {
          Timer.inst.frameLoop(1, this.update, this);
        } else {
          Timer.inst.clear(this.update, this);
        }
      }
      update() {
        let dt = import_cc23.game.deltaTime * 1e3;
        this._secondTicker += dt;
        let seconds = false;
        if (this._secondTicker >= 1e3) {
          seconds = true;
          this._secondTicker = 0;
        }
        this.onUpdate(dt / 1e3, seconds);
      }
      //////////////////////////////////////////////////////////////////////////
      onInitial() {
      }
      onAfterInitial() {
      }
      onCreate(data) {
      }
      onBeforeShow(data) {
      }
      onShown(data) {
      }
      onBeforeHide() {
      }
      onHide() {
      }
      onBringToFront() {
      }
      onOverlayBy(otherWindow) {
      }
      onDispose() {
      }
      onUpdate(dt, secondTick) {
      }
    };
    _Window.EVENT_WINDOW_BEFORE_HIDE = "onwindowbeforehide";
    _Window.EVENT_WINDOW_HIDE = "onwindowhide";
    _Window.defaultShowAudioSource = 0;
    _Window.defaultHideAudioSource = 0;
    Window2 = _Window;
  }
});

// node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "node_modules/lru-cache/index.js"(exports2, module2) {
    var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
    var hasAbortController = typeof AbortController === "function";
    var AC = hasAbortController ? AbortController : class AbortController {
      constructor() {
        this.signal = new AS();
      }
      abort() {
        this.signal.dispatchEvent("abort");
      }
    };
    var hasAbortSignal = typeof AbortSignal === "function";
    var hasACAbortSignal = typeof AC.AbortSignal === "function";
    var AS = hasAbortSignal ? AbortSignal : hasACAbortSignal ? AC.AbortController : class AbortSignal {
      constructor() {
        this.aborted = false;
        this._listeners = [];
      }
      dispatchEvent(type) {
        if (type === "abort") {
          this.aborted = true;
          const e = { type, target: this };
          this.onabort(e);
          this._listeners.forEach((f) => f(e), this);
        }
      }
      onabort() {
      }
      addEventListener(ev, fn) {
        if (ev === "abort") {
          this._listeners.push(fn);
        }
      }
      removeEventListener(ev, fn) {
        if (ev === "abort") {
          this._listeners = this._listeners.filter((f) => f !== fn);
        }
      }
    };
    var warned = /* @__PURE__ */ new Set();
    var deprecatedOption = (opt, instead) => {
      const code = `LRU_CACHE_OPTION_${opt}`;
      if (shouldWarn(code)) {
        warn(code, `${opt} option`, `options.${instead}`, LRUCache);
      }
    };
    var deprecatedMethod = (method, instead) => {
      const code = `LRU_CACHE_METHOD_${method}`;
      if (shouldWarn(code)) {
        const { prototype } = LRUCache;
        const { get } = Object.getOwnPropertyDescriptor(prototype, method);
        warn(code, `${method} method`, `cache.${instead}()`, get);
      }
    };
    var deprecatedProperty = (field, instead) => {
      const code = `LRU_CACHE_PROPERTY_${field}`;
      if (shouldWarn(code)) {
        const { prototype } = LRUCache;
        const { get } = Object.getOwnPropertyDescriptor(prototype, field);
        warn(code, `${field} property`, `cache.${instead}`, get);
      }
    };
    var emitWarning = (...a) => {
      typeof process === "object" && process && typeof process.emitWarning === "function" ? process.emitWarning(...a) : console.error(...a);
    };
    var shouldWarn = (code) => !warned.has(code);
    var warn = (code, what, instead, fn) => {
      warned.add(code);
      const msg = `The ${what} is deprecated. Please use ${instead} instead.`;
      emitWarning(msg, "DeprecationWarning", code, fn);
    };
    var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
    var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
    var ZeroArray = class extends Array {
      constructor(size) {
        super(size);
        this.fill(0);
      }
    };
    var Stack = class {
      constructor(max) {
        if (max === 0) {
          return [];
        }
        const UintArray = getUintArray(max);
        this.heap = new UintArray(max);
        this.length = 0;
      }
      push(n) {
        this.heap[this.length++] = n;
      }
      pop() {
        return this.heap[--this.length];
      }
    };
    var LRUCache = class _LRUCache {
      constructor(options = {}) {
        const {
          max = 0,
          ttl,
          ttlResolution = 1,
          ttlAutopurge,
          updateAgeOnGet,
          updateAgeOnHas,
          allowStale,
          dispose,
          disposeAfter,
          noDisposeOnSet,
          noUpdateTTL,
          maxSize = 0,
          sizeCalculation,
          fetchMethod,
          fetchContext,
          noDeleteOnFetchRejection,
          noDeleteOnStaleGet
        } = options;
        const { length, maxAge, stale } = options instanceof _LRUCache ? {} : options;
        if (max !== 0 && !isPosInt(max)) {
          throw new TypeError("max option must be a nonnegative integer");
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
          throw new Error("invalid max value: " + max);
        }
        this.max = max;
        this.maxSize = maxSize;
        this.sizeCalculation = sizeCalculation || length;
        if (this.sizeCalculation) {
          if (!this.maxSize) {
            throw new TypeError(
              "cannot set sizeCalculation without setting maxSize"
            );
          }
          if (typeof this.sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation set to non-function");
          }
        }
        this.fetchMethod = fetchMethod || null;
        if (this.fetchMethod && typeof this.fetchMethod !== "function") {
          throw new TypeError(
            "fetchMethod must be a function if specified"
          );
        }
        this.fetchContext = fetchContext;
        if (!this.fetchMethod && fetchContext !== void 0) {
          throw new TypeError(
            "cannot set fetchContext without fetchMethod"
          );
        }
        this.keyMap = /* @__PURE__ */ new Map();
        this.keyList = new Array(max).fill(null);
        this.valList = new Array(max).fill(null);
        this.next = new UintArray(max);
        this.prev = new UintArray(max);
        this.head = 0;
        this.tail = 0;
        this.free = new Stack(max);
        this.initialFill = 1;
        this.size = 0;
        if (typeof dispose === "function") {
          this.dispose = dispose;
        }
        if (typeof disposeAfter === "function") {
          this.disposeAfter = disposeAfter;
          this.disposed = [];
        } else {
          this.disposeAfter = null;
          this.disposed = null;
        }
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        if (this.maxSize !== 0) {
          if (!isPosInt(this.maxSize)) {
            throw new TypeError(
              "maxSize must be a positive integer if specified"
            );
          }
          this.initializeSizeTracking();
        }
        this.allowStale = !!allowStale || !!stale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || maxAge || 0;
        if (this.ttl) {
          if (!isPosInt(this.ttl)) {
            throw new TypeError(
              "ttl must be a positive integer if specified"
            );
          }
          this.initializeTTLTracking();
        }
        if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {
          throw new TypeError(
            "At least one of max, maxSize, or ttl is required"
          );
        }
        if (!this.ttlAutopurge && !this.max && !this.maxSize) {
          const code = "LRU_CACHE_UNBOUNDED";
          if (shouldWarn(code)) {
            warned.add(code);
            const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
            emitWarning(msg, "UnboundedCacheWarning", code, _LRUCache);
          }
        }
        if (stale) {
          deprecatedOption("stale", "allowStale");
        }
        if (maxAge) {
          deprecatedOption("maxAge", "ttl");
        }
        if (length) {
          deprecatedOption("length", "sizeCalculation");
        }
      }
      getRemainingTTL(key) {
        return this.has(key, { updateAgeOnHas: false }) ? Infinity : 0;
      }
      initializeTTLTracking() {
        this.ttls = new ZeroArray(this.max);
        this.starts = new ZeroArray(this.max);
        this.setItemTTL = (index, ttl, start = perf.now()) => {
          this.starts[index] = ttl !== 0 ? start : 0;
          this.ttls[index] = ttl;
          if (ttl !== 0 && this.ttlAutopurge) {
            const t = setTimeout(() => {
              if (this.isStale(index)) {
                this.delete(this.keyList[index]);
              }
            }, ttl + 1);
            if (t.unref) {
              t.unref();
            }
          }
        };
        this.updateItemAge = (index) => {
          this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0;
        };
        let cachedNow = 0;
        const getNow = () => {
          const n = perf.now();
          if (this.ttlResolution > 0) {
            cachedNow = n;
            const t = setTimeout(
              () => cachedNow = 0,
              this.ttlResolution
            );
            if (t.unref) {
              t.unref();
            }
          }
          return n;
        };
        this.getRemainingTTL = (key) => {
          const index = this.keyMap.get(key);
          if (index === void 0) {
            return 0;
          }
          return this.ttls[index] === 0 || this.starts[index] === 0 ? Infinity : this.starts[index] + this.ttls[index] - (cachedNow || getNow());
        };
        this.isStale = (index) => {
          return this.ttls[index] !== 0 && this.starts[index] !== 0 && (cachedNow || getNow()) - this.starts[index] > this.ttls[index];
        };
      }
      updateItemAge(index) {
      }
      setItemTTL(index, ttl, start) {
      }
      isStale(index) {
        return false;
      }
      initializeSizeTracking() {
        this.calculatedSize = 0;
        this.sizes = new ZeroArray(this.max);
        this.removeItemSize = (index) => this.calculatedSize -= this.sizes[index];
        this.requireSize = (k, v, size, sizeCalculation) => {
          if (!isPosInt(size)) {
            if (sizeCalculation) {
              if (typeof sizeCalculation !== "function") {
                throw new TypeError("sizeCalculation must be a function");
              }
              size = sizeCalculation(v, k);
              if (!isPosInt(size)) {
                throw new TypeError(
                  "sizeCalculation return invalid (expect positive integer)"
                );
              }
            } else {
              throw new TypeError(
                "invalid size value (must be positive integer)"
              );
            }
          }
          return size;
        };
        this.addItemSize = (index, v, k, size) => {
          this.sizes[index] = size;
          const maxSize = this.maxSize - this.sizes[index];
          while (this.calculatedSize > maxSize) {
            this.evict(true);
          }
          this.calculatedSize += this.sizes[index];
        };
      }
      removeItemSize(index) {
      }
      addItemSize(index, v, k, size) {
      }
      requireSize(k, v, size, sizeCalculation) {
        if (size || sizeCalculation) {
          throw new TypeError(
            "cannot set size without setting maxSize on cache"
          );
        }
      }
      *indexes({ allowStale = this.allowStale } = {}) {
        if (this.size) {
          for (let i = this.tail; true; ) {
            if (!this.isValidIndex(i)) {
              break;
            }
            if (allowStale || !this.isStale(i)) {
              yield i;
            }
            if (i === this.head) {
              break;
            } else {
              i = this.prev[i];
            }
          }
        }
      }
      *rindexes({ allowStale = this.allowStale } = {}) {
        if (this.size) {
          for (let i = this.head; true; ) {
            if (!this.isValidIndex(i)) {
              break;
            }
            if (allowStale || !this.isStale(i)) {
              yield i;
            }
            if (i === this.tail) {
              break;
            } else {
              i = this.next[i];
            }
          }
        }
      }
      isValidIndex(index) {
        return this.keyMap.get(this.keyList[index]) === index;
      }
      *entries() {
        for (const i of this.indexes()) {
          yield [this.keyList[i], this.valList[i]];
        }
      }
      *rentries() {
        for (const i of this.rindexes()) {
          yield [this.keyList[i], this.valList[i]];
        }
      }
      *keys() {
        for (const i of this.indexes()) {
          yield this.keyList[i];
        }
      }
      *rkeys() {
        for (const i of this.rindexes()) {
          yield this.keyList[i];
        }
      }
      *values() {
        for (const i of this.indexes()) {
          yield this.valList[i];
        }
      }
      *rvalues() {
        for (const i of this.rindexes()) {
          yield this.valList[i];
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      find(fn, getOptions = {}) {
        for (const i of this.indexes()) {
          if (fn(this.valList[i], this.keyList[i], this)) {
            return this.get(this.keyList[i], getOptions);
          }
        }
      }
      forEach(fn, thisp = this) {
        for (const i of this.indexes()) {
          fn.call(thisp, this.valList[i], this.keyList[i], this);
        }
      }
      rforEach(fn, thisp = this) {
        for (const i of this.rindexes()) {
          fn.call(thisp, this.valList[i], this.keyList[i], this);
        }
      }
      get prune() {
        deprecatedMethod("prune", "purgeStale");
        return this.purgeStale;
      }
      purgeStale() {
        let deleted = false;
        for (const i of this.rindexes({ allowStale: true })) {
          if (this.isStale(i)) {
            this.delete(this.keyList[i]);
            deleted = true;
          }
        }
        return deleted;
      }
      dump() {
        const arr = [];
        for (const i of this.indexes({ allowStale: true })) {
          const key = this.keyList[i];
          const v = this.valList[i];
          const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          const entry = { value };
          if (this.ttls) {
            entry.ttl = this.ttls[i];
            const age = perf.now() - this.starts[i];
            entry.start = Math.floor(Date.now() - age);
          }
          if (this.sizes) {
            entry.size = this.sizes[i];
          }
          arr.unshift([key, entry]);
        }
        return arr;
      }
      load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
          if (entry.start) {
            const age = Date.now() - entry.start;
            entry.start = perf.now() - age;
          }
          this.set(key, entry.value, entry);
        }
      }
      dispose(v, k, reason) {
      }
      set(k, v, {
        ttl = this.ttl,
        start,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL
      } = {}) {
        size = this.requireSize(k, v, size, sizeCalculation);
        let index = this.size === 0 ? void 0 : this.keyMap.get(k);
        if (index === void 0) {
          index = this.newIndex();
          this.keyList[index] = k;
          this.valList[index] = v;
          this.keyMap.set(k, index);
          this.next[this.tail] = index;
          this.prev[index] = this.tail;
          this.tail = index;
          this.size++;
          this.addItemSize(index, v, k, size);
          noUpdateTTL = false;
        } else {
          const oldVal = this.valList[index];
          if (v !== oldVal) {
            if (this.isBackgroundFetch(oldVal)) {
              oldVal.__abortController.abort();
            } else {
              if (!noDisposeOnSet) {
                this.dispose(oldVal, k, "set");
                if (this.disposeAfter) {
                  this.disposed.push([oldVal, k, "set"]);
                }
              }
            }
            this.removeItemSize(index);
            this.valList[index] = v;
            this.addItemSize(index, v, k, size);
          }
          this.moveToTail(index);
        }
        if (ttl !== 0 && this.ttl === 0 && !this.ttls) {
          this.initializeTTLTracking();
        }
        if (!noUpdateTTL) {
          this.setItemTTL(index, ttl, start);
        }
        if (this.disposeAfter) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
        return this;
      }
      newIndex() {
        if (this.size === 0) {
          return this.tail;
        }
        if (this.size === this.max && this.max !== 0) {
          return this.evict(false);
        }
        if (this.free.length !== 0) {
          return this.free.pop();
        }
        return this.initialFill++;
      }
      pop() {
        if (this.size) {
          const val = this.valList[this.head];
          this.evict(true);
          return val;
        }
      }
      evict(free) {
        const head = this.head;
        const k = this.keyList[head];
        const v = this.valList[head];
        if (this.isBackgroundFetch(v)) {
          v.__abortController.abort();
        } else {
          this.dispose(v, k, "evict");
          if (this.disposeAfter) {
            this.disposed.push([v, k, "evict"]);
          }
        }
        this.removeItemSize(head);
        if (free) {
          this.keyList[head] = null;
          this.valList[head] = null;
          this.free.push(head);
        }
        this.head = this.next[head];
        this.keyMap.delete(k);
        this.size--;
        return head;
      }
      has(k, { updateAgeOnHas = this.updateAgeOnHas } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0) {
          if (!this.isStale(index)) {
            if (updateAgeOnHas) {
              this.updateItemAge(index);
            }
            return true;
          }
        }
        return false;
      }
      // like get(), but without any LRU updating or TTL expiration
      peek(k, { allowStale = this.allowStale } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0 && (allowStale || !this.isStale(index))) {
          return this.valList[index];
        }
      }
      backgroundFetch(k, index, options, context) {
        const v = index === void 0 ? void 0 : this.valList[index];
        if (this.isBackgroundFetch(v)) {
          return v;
        }
        const ac = new AC();
        const fetchOpts = {
          signal: ac.signal,
          options,
          context
        };
        const cb = (v4) => {
          if (!ac.signal.aborted) {
            this.set(k, v4, fetchOpts.options);
          }
          return v4;
        };
        const eb = (er) => {
          if (this.valList[index] === p) {
            const del = !options.noDeleteOnFetchRejection || p.__staleWhileFetching === void 0;
            if (del) {
              this.delete(k);
            } else {
              this.valList[index] = p.__staleWhileFetching;
            }
          }
          if (p.__returned === p) {
            throw er;
          }
        };
        const pcall = (res) => res(this.fetchMethod(k, v, fetchOpts));
        const p = new Promise(pcall).then(cb, eb);
        p.__abortController = ac;
        p.__staleWhileFetching = v;
        p.__returned = null;
        if (index === void 0) {
          this.set(k, p, fetchOpts.options);
          index = this.keyMap.get(k);
        } else {
          this.valList[index] = p;
        }
        return p;
      }
      isBackgroundFetch(p) {
        return p && typeof p === "object" && typeof p.then === "function" && Object.prototype.hasOwnProperty.call(
          p,
          "__staleWhileFetching"
        ) && Object.prototype.hasOwnProperty.call(p, "__returned") && (p.__returned === p || p.__returned === null);
      }
      // this takes the union of get() and set() opts, because it does both
      async fetch(k, {
        // get options
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        noDeleteOnStaleGet = this.noDeleteOnStaleGet,
        // set options
        ttl = this.ttl,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL,
        // fetch exclusive options
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
        fetchContext = this.fetchContext
      } = {}) {
        if (!this.fetchMethod) {
          return this.get(k, { allowStale, updateAgeOnGet, noDeleteOnStaleGet });
        }
        const options = {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet,
          ttl,
          noDisposeOnSet,
          size,
          sizeCalculation,
          noUpdateTTL,
          noDeleteOnFetchRejection
        };
        let index = this.keyMap.get(k);
        if (index === void 0) {
          const p = this.backgroundFetch(k, index, options, fetchContext);
          return p.__returned = p;
        } else {
          const v = this.valList[index];
          if (this.isBackgroundFetch(v)) {
            return allowStale && v.__staleWhileFetching !== void 0 ? v.__staleWhileFetching : v.__returned = v;
          }
          if (!this.isStale(index)) {
            this.moveToTail(index);
            if (updateAgeOnGet) {
              this.updateItemAge(index);
            }
            return v;
          }
          const p = this.backgroundFetch(k, index, options, fetchContext);
          return allowStale && p.__staleWhileFetching !== void 0 ? p.__staleWhileFetching : p.__returned = p;
        }
      }
      get(k, {
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        noDeleteOnStaleGet = this.noDeleteOnStaleGet
      } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0) {
          const value = this.valList[index];
          const fetching = this.isBackgroundFetch(value);
          if (this.isStale(index)) {
            if (!fetching) {
              if (!noDeleteOnStaleGet) {
                this.delete(k);
              }
              return allowStale ? value : void 0;
            } else {
              return allowStale ? value.__staleWhileFetching : void 0;
            }
          } else {
            if (fetching) {
              return void 0;
            }
            this.moveToTail(index);
            if (updateAgeOnGet) {
              this.updateItemAge(index);
            }
            return value;
          }
        }
      }
      connect(p, n) {
        this.prev[n] = p;
        this.next[p] = n;
      }
      moveToTail(index) {
        if (index !== this.tail) {
          if (index === this.head) {
            this.head = this.next[index];
          } else {
            this.connect(this.prev[index], this.next[index]);
          }
          this.connect(this.tail, index);
          this.tail = index;
        }
      }
      get del() {
        deprecatedMethod("del", "delete");
        return this.delete;
      }
      delete(k) {
        let deleted = false;
        if (this.size !== 0) {
          const index = this.keyMap.get(k);
          if (index !== void 0) {
            deleted = true;
            if (this.size === 1) {
              this.clear();
            } else {
              this.removeItemSize(index);
              const v = this.valList[index];
              if (this.isBackgroundFetch(v)) {
                v.__abortController.abort();
              } else {
                this.dispose(v, k, "delete");
                if (this.disposeAfter) {
                  this.disposed.push([v, k, "delete"]);
                }
              }
              this.keyMap.delete(k);
              this.keyList[index] = null;
              this.valList[index] = null;
              if (index === this.tail) {
                this.tail = this.prev[index];
              } else if (index === this.head) {
                this.head = this.next[index];
              } else {
                this.next[this.prev[index]] = this.next[index];
                this.prev[this.next[index]] = this.prev[index];
              }
              this.size--;
              this.free.push(index);
            }
          }
        }
        if (this.disposed) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
        return deleted;
      }
      clear() {
        for (const index of this.rindexes({ allowStale: true })) {
          const v = this.valList[index];
          if (this.isBackgroundFetch(v)) {
            v.__abortController.abort();
          } else {
            const k = this.keyList[index];
            this.dispose(v, k, "delete");
            if (this.disposeAfter) {
              this.disposed.push([v, k, "delete"]);
            }
          }
        }
        this.keyMap.clear();
        this.valList.fill(null);
        this.keyList.fill(null);
        if (this.ttls) {
          this.ttls.fill(0);
          this.starts.fill(0);
        }
        if (this.sizes) {
          this.sizes.fill(0);
        }
        this.head = 0;
        this.tail = 0;
        this.initialFill = 1;
        this.free.length = 0;
        this.calculatedSize = 0;
        this.size = 0;
        if (this.disposed) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
      }
      get reset() {
        deprecatedMethod("reset", "clear");
        return this.clear;
      }
      get length() {
        deprecatedProperty("length", "size");
        return this.size;
      }
      static get AbortController() {
        return AC;
      }
      static get AbortSignal() {
        return AS;
      }
    };
    module2.exports = LRUCache;
  }
});

// assets/scripts/framework/view/WindowPriorityMap.ts
var WindowPriorityMap_exports = {};
__export(WindowPriorityMap_exports, {
  WindowPriorityMap: () => WindowPriorityMap
});
var defaultPriority, WindowPriorityMap;
var init_WindowPriorityMap = __esm({
  "assets/scripts/framework/view/WindowPriorityMap.ts"() {
    defaultPriority = {
      needBeWait: false,
      waitPriority: 0,
      group: 0,
      groupLevel: 0
    };
    WindowPriorityMap = class {
      static add(key, info) {
        info.groupLevel = info.groupLevel || 0;
        info.group = info.group || 0;
        info.waitPriority = info.waitPriority || 0;
        info.needBeWait = info.needBeWait != null ? info.needBeWait : true;
        this._priorityMap[key] = info;
        return this;
      }
      static set(key, info) {
        this.add(key, info);
        return this;
      }
      static get(key) {
        return this._priorityMap[key] || defaultPriority;
      }
      static getBySkin(skin) {
        return this.get(skin.componentName);
      }
      static remove(key) {
        delete this._priorityMap[key];
      }
      static clear() {
        this._priorityMap = {};
      }
    };
    WindowPriorityMap._priorityMap = {};
  }
});

// assets/scripts/framework/view/UIManager.ts
var UIManager_exports = {};
__export(UIManager_exports, {
  UIManager: () => UIManager
});
var import_cc24, import_lru_cache, import_env10, _UIManager, UIManager;
var init_UIManager = __esm({
  "assets/scripts/framework/view/UIManager.ts"() {
    init_ViewHelper();
    init_Skin();
    init_fairygui();
    import_cc24 = require("cc");
    init_Window();
    import_lru_cache = __toESM(require_lru_cache());
    init_Timer();
    init_ViewMap();
    init_fairygui();
    init_FGUIExt();
    init_WindowPriorityMap();
    init_fairygui();
    import_env10 = require("cc/env");
    init_CoroutineUtils();
    Window.prototype["onTouchBegin_1"] = function(evt) {
      let that = this;
      if (that.isShowing && that.bringToFontOnClick) {
        if (GRoot.inst._children[GRoot.inst._children.length - 1] != this) {
          that.bringToFront();
          if (that.data instanceof Window2) {
            UIManager.sortWindow(that.data);
          }
        }
      }
    };
    _UIManager = class _UIManager {
      constructor() {
        this._views = [];
        this._windows = [];
        this._beginCreateTime = -1;
        this._watingModualOpend = false;
        this.onResourcesNotReady = null;
        this._waitWindows = [];
        this._autoShowing = 0;
        this.maxWindowKeep = 7;
        /**
         * 打开时间超过此时间后，打开等待界面(s)
         */
        this.waitingModualTime = 1;
        // 能否显示等待中的窗口
        this.canShowWaitingWindowNow = true;
      }
      get camera() {
        return this._camera;
      }
      static get instance() {
        if (this._instance == null) {
          this._instance = new _UIManager();
        }
        return this._instance;
      }
      initialize(opts = null) {
        this.initializeCanvasNode();
        this.initializeViewHelper(opts);
        this.initializeViews();
        this.initializeLRU();
      }
      initializeCanvasNode() {
        var cnode = import_cc24.director.getScene().getChildByName("Canvas");
        import_cc24.game.addPersistRootNode(cnode);
        this._canvasNode = cnode;
        this._camera = this._canvasNode.getComponent(import_cc24.Canvas).cameraComponent;
        GRoot.create();
      }
      initializeViewHelper(opts) {
        ViewHelper.instance.initialize(opts);
      }
      initializeViews() {
        this._views[0] = [];
        this._views[1] = [];
        this._views[2] = [];
      }
      initializeLRU() {
        this._lru = new import_lru_cache.default({
          max: this.maxWindowKeep,
          dispose: (value, key) => {
            if (!value.visible) {
              ViewHelper.instance.destoryWindow(value.skin);
            }
          }
        });
      }
      topWindow(ignoreTopMost) {
        if (this._windows.length == 0) {
          return null;
        }
        if (ignoreTopMost) {
          return this.findTopNonTopMostWindow();
        }
        return this.findTopWindow();
      }
      findTopNonTopMostWindow() {
        for (let i = this._windows.length - 1; i >= 0; i--) {
          let w = this._windows[i];
          if (!w.topMost) {
            return w;
          }
        }
        return null;
      }
      findTopWindow() {
        return this._windows[this._windows.length - 1];
      }
      allShowWindows() {
        return this._windows;
      }
      /**
       * 检查是否有窗口显示
       * @returns 
       */
      hasWindow() {
        return this.allShowWindows().some((wnd) => wnd._special);
      }
      preloadWindow(viewType) {
        return ViewHelper.instance.getSingleWindowByType(viewType);
      }
      isShowingByType(viewType) {
        return this._windows.some((i) => i instanceof viewType);
      }
      isShowing(window2) {
        if (typeof window2 == "string") {
          return this.isShowingByType(ViewMap.instance.getByName(window2));
        } else if (window2 instanceof Function) {
          return this.isShowingByType(window2);
        }
        return this._windows.includes(window2);
      }
      hidePopup(view5) {
        const gobj = view5 instanceof GComponent ? view5 : view5.component;
        GRoot.inst.hidePopup(gobj);
      }
      /* 
              Description:
              Show a popup view.
      
              Parameters:
              - view: The view to be displayed.
              - pos: The relative position of the view.
              - anchorName: The name of the anchor.
              - target: The target component to display.
              - dir: The direction of the popup.
          */
      showPopup(view5, pos = null, anchorName = null, target = null, dir = PopupDirection.Auto, horAutoAdapt = true) {
        let gobj = view5 instanceof GComponent ? view5 : view5.component;
        let targetPos = pos || new import_cc24.Vec2(0, 0);
        if (target) {
          target.localToGlobal(targetPos.x, targetPos.y, targetPos);
          GRoot.inst.globalToLocal(targetPos.x, targetPos.y, targetPos);
        }
        let anchor = anchorName ? gobj.getChild(anchorName) : null;
        let rawPos = anchor ? anchor.data || new import_cc24.Vec4(anchor.x, anchor.y, anchor.x / gobj.width, anchor.y / gobj.height) : new import_cc24.Vec4(0, 0, gobj.pivotX, gobj.pivotY);
        let offsetX = 0;
        if (horAutoAdapt) {
          let realWidth = gobj.width * gobj.scaleX;
          let lx = targetPos.x - realWidth * rawPos.z;
          let rx = targetPos.x + realWidth * (1 - rawPos.z) - GRoot.inst.width;
          offsetX = rx > 0 ? rx / gobj.scaleX : lx < 0 ? lx / gobj.scaleX : 0;
        }
        if (anchor) {
          anchor.setPosition(rawPos.x + offsetX, rawPos.y);
          gobj.setPivot(anchor.x / gobj.width, anchor.y / gobj.height, true);
          offsetX = 0;
        }
        GRoot.inst.showPopup(gobj, target, dir);
        gobj.setPosition(targetPos.x - offsetX, targetPos.y);
        gobj.node.on(import_cc24.Node.EventType.ACTIVE_IN_HIERARCHY_CHANGED, () => {
          if (!gobj.node.activeInHierarchy) {
            let view6 = gobj["_docker_"];
            if (view6) {
              view6.hide();
            }
          }
        });
      }
      onHideWindow(wnd) {
        if (!wnd) {
          return;
        }
        let idx = this._windows.indexOf(wnd);
        if (idx >= 0) {
          this._windows.splice(idx, 1);
          let topModalWnd = this.topWindow(true);
          if (topModalWnd) {
            topModalWnd.bringToFront();
          }
          if (wnd.canAutoDestory) {
            this._lru.set(wnd.skin.getKey(), wnd);
          }
          this._autoShowing = 0.5;
        }
      }
      /**
       * 延迟弹出等待中的窗口
       * @param delay 
       */
      delayPopWaitWindow(delay) {
        this._autoShowing = delay || 0.5;
      }
      update(dt) {
        this.checkWaitWindow(dt);
      }
      /**
       * 检查是否可以显示等待中的窗口
       * @param dt 
       * @returns 
       */
      checkWaitWindow(dt) {
        if (!this.canShowWaitingWindowNow) {
          return;
        }
        this.updateAutoShowing(dt);
        if (this._waitWindows.length > 0) {
          let group = this._waitWindows[0];
          if (group.length > 0) {
            let waitWnd = group[0];
            if (this.canShowWaitWindow(waitWnd)) {
              this._autoShowing = 0.2;
              group.shift();
              this.showWindowX(waitWnd);
            }
          }
          if (group.length == 0) {
            this._waitWindows.shift();
          }
        }
      }
      updateAutoShowing(dt) {
        if (this._autoShowing > 0) {
          this._autoShowing -= dt;
          this._autoShowing = Math.max(0, this._autoShowing);
        }
      }
      canShowWaitWindow(waitWnd) {
        let backWindow = this._getWaitWindow();
        if (backWindow) {
          let backInfo = WindowPriorityMap.getBySkin(backWindow.skin);
          if (backInfo.group > 0 && backInfo.group == waitWnd.info.group && backInfo.groupLevel < waitWnd.info.groupLevel) {
            return true;
          }
        } else {
          return true;
        }
        return false;
      }
      _getWaitWindow() {
        return this._windows.find((wnd) => wnd.needBeWait) || null;
      }
      _hasWindowInWaitQueue(viewType) {
        if (this._windows.some((window2) => window2 instanceof viewType)) {
          return true;
        }
        if (this._waitWindows.some((group) => group.some((window2) => window2.viewType == viewType))) {
          return true;
        }
        return false;
      }
      static sortWindow(wnd) {
        let that = _UIManager.instance;
        if (that._windows.length > 0) {
          let startIdx = GRoot.inst.getChildIndex(wnd.window);
          for (let i = 0; i < that._windows.length; i++) {
            let w = that._windows[i];
            if (!wnd.topMost && w.topMost || wnd.topMost && w.topMost && wnd.topPriority < w.topPriority) {
              let idx = GRoot.inst.getChildIndex(w.window);
              if (idx < 0) {
                that._windows.splice(i, 1);
                i--;
                continue;
              }
              GRoot.inst.setChildIndex(w.window, startIdx);
            }
            w._index = GRoot.inst.getChildIndex(w.window);
          }
        } else {
          GRoot.inst.bringToFront(wnd.window);
        }
        that._windows.push(wnd);
        that._windows.sort((a, b) => a._index - b._index);
      }
      showWindow(viewType, data = null, modal = true, modalLayerColor = null) {
        if (typeof viewType === "string") {
          viewType = ViewMap.instance.getByName(viewType);
        }
        const wnd = ViewHelper.instance.getSingleWindowByType(viewType);
        return this._showWindow(wnd, data, modal, modalLayerColor);
      }
      getTopModalWindow() {
        const topModalWindow = this._windows.slice().reverse().find((w) => w.modal);
        return topModalWindow || null;
      }
      /**
       * 检查资源是否准备好
       * @param viewType 
       * @param waitResource 
       * @returns 
       */
      async checkResourceReady(viewType, waitResource) {
        var _a;
        const skin = Skin.getSkin(viewType);
        if (!skin) {
          console.error(`skin is null, viewType: ${viewType}`);
          return false;
        }
        const packageExists = UIPackage.getByName(skin.packageName);
        if (!packageExists) {
          return true;
        }
        if (waitResource) {
          await FGUIExt.preloadPackage(skin.packageName, "/");
          return true;
        }
        (_a = this.onResourcesNotReady) == null ? void 0 : _a.call(this, viewType, waitResource);
        return false;
      }
      /**
       * 显示窗口, 如果showNow为false，则会在排序后加入等待队列
       * @param context 
       * @param showNow 
       * @returns 
       */
      async showWindowX(context, showNow = true) {
        let type = context.viewType;
        if (typeof context.viewType == "string") {
          type = ViewMap.instance.getByName(context.viewType);
        }
        if (!type) {
          console.error(`no window type ${context.viewType}`);
          return null;
        }
        if (context.waitOnResNotReady) {
          let res = await _UIManager.instance.checkResourceReady(type, true);
          if (!res) {
            return null;
          }
        }
        if (showNow) {
          return _UIManager.instance.showWindow(type, context.data, context.modal, context.modalLayerColor);
        }
        let wndInfo = WindowPriorityMap.getBySkin(Skin.getSkin(type));
        if (this._hasWindowInWaitQueue(type)) {
          return null;
        }
        let group = this._waitWindows.find((i) => i[0].info.group == wndInfo.group);
        if (!group) {
          group = [];
          this._waitWindows.push(group);
        }
        let insertIndex = group.findIndex((i) => i.info.waitPriority > wndInfo.waitPriority);
        if (insertIndex < 0) {
          group.push(context);
        } else {
          group.splice(insertIndex, 0, context);
        }
        if (import_env10.PREVIEW) {
          for (let i = 0; i < this._waitWindows.length; i++) {
            for (let j = 0; j < this._waitWindows[i].length; j++) {
              const wnd = this._waitWindows[i][j];
              const name = typeof wnd.viewType == "string" ? wnd.viewType : wnd.viewType.name;
              console.log("wait window:", name, wnd.info.waitPriority);
            }
          }
        }
        return null;
      }
      _showWindow(wnd, data = null, modal = true, modalLayerColor = null) {
        var _a;
        if (wnd == null) {
          return null;
        }
        if (this.topWindow() == wnd) {
          return wnd;
        }
        if (this._windows.indexOf(wnd) >= 0) {
          console.error(`dumplicate open window:${(_a = wnd.skin) == null ? void 0 : _a.componentName}`);
          return wnd;
        }
        wnd.modal = modal;
        if (modal) {
          wnd.modalLayerColor.set(modalLayerColor || UIConfig.modalLayerColor);
        }
        wnd.bringToFront();
        wnd.once(Window2.EVENT_WINDOW_HIDE, (w) => {
          let idx = this._windows.indexOf(w);
          if (idx >= 0) {
            this._windows.splice(idx, 1);
          }
          this.onHideWindow(w);
          this.emit(_UIManager.EVENT_WINDOW_CHANGED, w, false);
        }, this);
        wnd.show(data);
        _UIManager.sortWindow(wnd);
        this.emit(_UIManager.EVENT_WINDOW_CHANGED, wnd, true);
        let oldWindow = this.topWindow(true);
        if (oldWindow) {
          oldWindow.overlayBy(wnd);
        }
        return wnd;
      }
      setModalLayerColor(color) {
        this._setModalLayerColor(color);
        this._fadeModelLayerColor();
      }
      _setModalLayerColor(color) {
        GRoot.inst.modalLayer.color.set(color);
        GRoot.inst.modalLayer.drawRect(0, import_cc24.Color.TRANSPARENT, color);
      }
      _setModalLayerAlpha(alpha) {
        let color = GRoot.inst.modalLayer.color;
        if (color.a == alpha) {
          return;
        }
        color.a = alpha;
        this._setModalLayerColor(color);
      }
      _fadeModelLayerColor(from = 0, to = 200, duration = 0.2, windowCount = 0) {
        if (this._windows.length == windowCount) {
          GTween.kill(GRoot.inst.modalLayer);
          GTween.to(from, to, duration).setTarget(GRoot.inst.modalLayer).onUpdate((t) => {
            this._setModalLayerAlpha(t.value.x);
          }, this);
        } else {
          this._setModalLayerAlpha(to);
        }
      }
      hideWindow(viewType, dispose = false, code) {
        if (typeof viewType == "string") {
          viewType = ViewMap.instance.getByName(viewType);
        }
        var wnd = ViewHelper.instance.getSingleWindowByType(viewType);
        if (wnd == null) {
          return;
        }
        wnd.hide(code);
        if (dispose) {
          ViewHelper.instance.destoryWindow(wnd.skin);
        }
      }
      async waitWindow(viewType, data = null, modal = true, modalLayerColor = null) {
        if (typeof viewType == "string") {
          viewType = ViewMap.instance.getByName(viewType);
        }
        let wnd = this.showWindow(viewType, data, modal, modalLayerColor);
        let next = false;
        wnd.once(Window2.EVENT_WINDOW_HIDE, () => {
          next = true;
        }, this);
        await CoroutineUtils.until(() => next);
        return wnd.exitCode;
      }
      hideCurrentWindow(dispose = false, code, ignoreTopMost) {
        const wnd = this.topWindow(ignoreTopMost);
        if (!wnd) {
          return null;
        }
        wnd.hide(code);
        const idx = this._windows.indexOf(wnd);
        if (idx >= 0) {
          this._windows.splice(idx, 1);
          this.onHideWindow(wnd);
        }
        if (dispose) {
          ViewHelper.instance.destoryWindow(wnd.skin);
        }
        return wnd;
      }
      hideAllWindow(code) {
        this._windows.forEach((v) => {
          v.hide(code);
        });
        this._windows.length = 0;
        GRoot.inst.closeAllWindows();
      }
      go(viewType, data, layer = 1 /* UI */) {
        return this.push(viewType, data, layer, true);
      }
      push(viewType, data, layer = 1 /* UI */, popTop = false) {
        if (!viewType) {
          console.error("can not push undefined viewType!");
          return null;
        }
        if (typeof viewType === "string") {
          viewType = ViewMap.instance.getByName(viewType);
        }
        let views = this._views[layer];
        let curView;
        if (views.length > 0) {
          curView = views[views.length - 1];
          if (curView && viewType === curView.constructor) {
            return curView;
          }
        }
        let nextView = ViewHelper.instance.getSingleViewByType(viewType, layer);
        let pause = () => {
          if (curView) {
            if (!popTop) {
              curView.pause();
            } else {
              this._pop(layer, false, true);
            }
          }
        };
        let enter = (data2) => {
          if (nextView != null) {
            views.push(nextView);
            nextView.data = data2;
            if (curView) {
              let nextgo = nextView.viewObject.container;
              nextgo.parent.setChildIndex(nextgo, nextgo.parent.numChildren);
            }
            nextView.enter(data2);
          }
        };
        pause();
        enter(data);
        this.emit(_UIManager.EVENT_ACTIVITY_CHANGED, layer, curView, nextView);
        return nextView;
      }
      popTo(viewType, layer = 1 /* UI */, data = null) {
        let top = this.peekOrNull(layer);
        while (!(top instanceof viewType)) {
          top = this.peekOrNull2();
          this._pop(layer, top instanceof viewType, false, data);
          top = this.peekOrNull(layer);
          if (!top) {
            break;
          }
        }
      }
      _pop(layer = 1 /* UI */, withResume = true, beforePush = false, data = null) {
        let views = this._views[layer];
        if (views.length > 0 || beforePush) {
          let preView = views.pop();
          let preType = preView.skin;
          let exit = () => {
            preView.exit();
            if (preView.disposeOnExit) {
              ViewHelper.instance.destroyView(preType);
            }
          };
          let curView = views.length > 0 ? views[views.length - 1] : null;
          let resume = (data2) => {
            if (curView) {
              curView.resume(data2);
            }
          };
          exit();
          if (withResume) {
            resume(data);
          }
          this.emit(_UIManager.EVENT_ACTIVITY_CHANGED, layer, preView, curView);
          return curView;
        }
      }
      pop(layer = 1 /* UI */, data = null) {
        return this._pop(layer, true, false, data);
      }
      getViewCount(layer = 1 /* UI */) {
        return this._views[layer].length;
      }
      peekOrNull(layer = 1 /* UI */) {
        let views = this._views[layer];
        if (views.length > 0) {
          return views[views.length - 1];
        }
        return null;
      }
      peekOrNull2(layer = 1 /* UI */) {
        let views = this._views[layer];
        if (views.length > 1) {
          return views[views.length - 2];
        }
        return null;
      }
      on(type, listener, target) {
        this._canvasNode.on(type, listener, target);
      }
      once(type, listener, target) {
        this._canvasNode.once(type, listener, target);
      }
      off(type, listener, target) {
        this._canvasNode.off(type, listener, target);
      }
      targetOff(target) {
        this._canvasNode.targetOff(target);
      }
      emit(type, ...data) {
        this._canvasNode.emit(type, ...data);
      }
      onContainerCreate(container) {
        var _a;
        this._currentOpeningContainer = container;
        this._beginCreateTime = Date.now();
        if ((_a = this._currentOpeningContainer) == null ? void 0 : _a.enableWating) {
          Timer.inst.frameLoop(1, this.onContainerChecker, this);
        }
      }
      onCreateEnd() {
        var _a;
        if ((_a = this._currentOpeningContainer) == null ? void 0 : _a.enableWating) {
          this.emit(_UIManager.EVENT_NEED_CLOSE_WATING, this._currentOpeningContainer);
        }
        this._currentOpeningContainer = null;
        this._beginCreateTime = -1;
        this._watingModualOpend = false;
        Timer.inst.clear(this.onContainerChecker, this);
      }
      onContainerChecker() {
        if (this._currentOpeningContainer) {
          if (!this._watingModualOpend) {
            let duration = Date.now() - this._beginCreateTime;
            if (duration >= this.waitingModualTime * 1e3) {
              this.emit(_UIManager.EVENT_NEED_OPEN_WATING, this._currentOpeningContainer);
              this._watingModualOpend = true;
            }
          } else if (this._currentOpeningContainer.isCreated) {
            this.onCreateEnd();
          }
        }
      }
    };
    _UIManager.EVENT_NEED_OPEN_WATING = "uimgr_need_open_wating";
    _UIManager.EVENT_NEED_CLOSE_WATING = "uimgr_need_open_wating";
    _UIManager.EVENT_WINDOW_CHANGED = "uimgr_window_changed";
    _UIManager.EVENT_ACTIVITY_CHANGED = "uimgr_activity_changed";
    _UIManager.onButtonClick = null;
    _UIManager._instance = null;
    UIManager = _UIManager;
  }
});

// assets/scripts/framework/view/Activity.ts
var Activity_exports = {};
__export(Activity_exports, {
  Activity: () => Activity
});
var import_cc25, NAME_REGEX, Activity;
var init_Activity = __esm({
  "assets/scripts/framework/view/Activity.ts"() {
    init_fairygui();
    init_Skin();
    init_ViewObject();
    init_SkinHelper();
    init_ViewHelper();
    init_Container();
    init_Timer();
    init_UIManager();
    init_SoundManager();
    import_cc25 = require("cc");
    NAME_REGEX = /\[((([tbrlwh]|(?:[xy][+-]\d{0,3})){1}(?:\d{0,3},?))+)\](.*)/i;
    Activity = class extends Container {
      constructor() {
        super(...arguments);
        this.disposeOnExit = false;
        this.overflow = false;
        this.injectInfos = {};
        this._updating = false;
        this._secondTicker = 0;
        this._enableUpdate = false;
        this.bgmLoop = true;
      }
      registInfos() {
      }
      get component() {
        return this.viewObject.component;
      }
      get destoried() {
        return this._destoried;
      }
      get skin() {
        if (!this._skin) {
          this._skin = Skin.getSkin(this.constructor);
        }
        return this._skin;
      }
      get visible() {
        return this.component.visible;
      }
      get enableUpdate() {
        return this._enableUpdate;
      }
      set enableUpdate(val) {
        if (this._enableUpdate != val) {
          this._enableUpdate = val;
          if (this._isShown) {
            this.setUpdateEnable(val);
          }
        }
      }
      initial() {
        this.beginCreate();
        UIManager.instance.onContainerCreate(this);
        UIPackage.addPackage(this.skin.path);
        let viewObj = new ViewObject();
        let component = null;
        if (this.skin.autoWarpper) {
          let warpper = new GComponent();
          warpper.node.name = "[AUTO]GComponent";
          viewObj.warpper = warpper;
          let loader = new GLoader();
          viewObj.warpLoader = loader;
          loader.node.name = "[AUTO]GLoader";
          let url = UIPackage.getItemURL(this.skin.packageName, this.skin.componentName);
          loader.url = url;
          component = loader.component;
          warpper.opaque = component.opaque;
          warpper.addChild(loader);
          loader.fill = LoaderFillType.Scale;
          loader.align = AlignType.Center;
          loader.verticalAlign = VertAlignType.Middle;
          loader.autoSize = false;
          warpper.setSize(component.width, component.height);
          loader.setSize(warpper.width, warpper.height);
          loader.setPosition(0, 0);
          loader.addRelation(warpper, RelationType.Size);
          let bg = component.getChild("_bg_");
          let count = 0;
          if (bg != null) {
            warpper.addChildAt(bg, 0);
            bg.addRelation(warpper, RelationType.Size);
            count++;
          }
          let children = component._children.slice();
          children.forEach((child) => {
            let name = child.name;
            if (name.startsWith("_out_")) {
              let defs = [];
              child.relations["_items"].filter((item) => item.target == component).map((item) => {
                defs = defs.concat(item["_defs"]);
              });
              child.removeFromParent();
              child.relations.clearFor(component);
              warpper.addChildAt(child, count);
              defs.forEach((def) => {
                child.addRelation(warpper, def.type, def.percent);
              });
              count++;
            } else {
              let matches = NAME_REGEX.exec(name);
              if (matches) {
                let groups = matches[1].split(",");
                groups.forEach((group) => {
                  let type = group[0].toLocaleLowerCase();
                  let isPosType = type == "x" || type == "y";
                  let startPos = isPosType ? 2 : 1;
                  let sign = 1;
                  if (isPosType) {
                    sign = group[1] == "+" ? 1 : -1;
                  }
                  let precentStr = group.substring(startPos);
                  let precent = !!precentStr ? parseInt(precentStr) / 100 : 1;
                  if (Number.isNaN(precent)) {
                    precent = 1;
                    console.error("precent is not number," + precentStr, name);
                  }
                  let fullWidth = GRoot.inst.width;
                  let fullHeight = GRoot.inst.height;
                  if (type == "t") {
                    child.setPosition(child.x, child.y - (fullHeight - component.height) * 0.5 * precent);
                  } else if (type == "b") {
                    child.setPosition(child.x, child.y + (fullHeight - component.height) * 0.5 * precent);
                  } else if (type == "l") {
                    child.setPosition(child.x - (fullWidth - component.width) * 0.5 * precent, child.y);
                  } else if (type == "r") {
                    child.setPosition(child.x + (fullWidth - component.width) * 0.5 * precent, child.y);
                  } else if (type == "w") {
                    child.setSize(child.width + (fullWidth - component.width) * precent, child.height);
                  } else if (type == "h") {
                    child.setSize(child.width, child.height + (fullHeight - component.height) * precent);
                  } else if (type == "x") {
                    child.setPosition(child.x + (fullWidth - component.width) * 0.5 * sign * precent, child.y);
                  } else if (type == "y") {
                    child.setPosition(child.x, child.y + (fullHeight - component.height) * 0.5 * sign * precent);
                  } else {
                    console.error("unknow type", type);
                  }
                });
                child.name = matches[4];
              }
            }
          });
        } else {
          component = UIPackage.createObject(this.skin.packageName, this.skin.componentName).asCom;
          component.node.name = `[${this.skin.componentName}]`;
        }
        viewObj.go = component;
        viewObj.skin = this.skin;
        this.viewObject = viewObj;
      }
      async create() {
        this.onInitial();
        SkinHelper.InjectView(this.viewObject.go, this);
        let groot = ViewHelper.instance.getLayer(1 /* UI */);
        groot.on(Event.SIZE_CHANGED, this.onSizeChanged, this);
        this.viewObject.container.setSize(groot.width, groot.height);
        let ret = this.onCreate();
        if (ret instanceof Promise) {
          await ret;
        }
        this.endCreate();
      }
      onSizeChanged() {
        let groot = ViewHelper.instance.getLayer(1 /* UI */);
        this.viewObject.container.setSize(groot.width, groot.height);
      }
      enter(data) {
        this.show(true, data);
      }
      async show(isEnter, data) {
        this._isShown = false;
        this.viewObject.container.visible = true;
        this.children.forEach((v) => {
          v.show(data, false);
        });
        let ret = this.onShown(isEnter, data);
        if (ret instanceof Promise) {
          await ret;
        }
        this.endShown();
        this.setUpdateEnable(this._enableUpdate);
        if (this.bgmSouce) {
          SoundManager.instance.playMusic(this.bgmSouce, this.bgmLoop);
        }
      }
      exit() {
        this.hide(true);
      }
      hide(isExit) {
        this.viewObject.container.visible = false;
        this.children.forEach((v) => {
          v.hide(false);
        });
        this.clearEventCenter();
        this.setUpdateEnable(false);
        this.onHide(isExit);
      }
      pause() {
        this.hide(false);
      }
      resume(data) {
        this.show(false, data);
      }
      dispose() {
        if (this._destoried) {
          return;
        }
        this._destoried = true;
        this.clearEventCenter();
        this.children.forEach((v) => {
          v.dispose();
        });
        let groot = ViewHelper.instance.getLayer(1 /* UI */);
        groot.off(Event.SIZE_CHANGED, this.onSizeChanged, this);
        this.viewObject.go.dispose();
        this.onDispose();
      }
      update() {
        let dt = import_cc25.game.deltaTime * 1e3;
        this._secondTicker += dt;
        let seconds = false;
        if (this._secondTicker >= 1e3) {
          seconds = true;
          this._secondTicker = 0;
        }
        this.onUpdate(dt / 1e3, seconds);
      }
      setUpdateEnable(val) {
        if (this._updating == val) {
          return;
        }
        this._updating = val;
        if (val) {
          Timer.inst.frameLoop(1, this.update, this);
        } else {
          Timer.inst.clear(this.update, this);
        }
      }
      //////////////////////////////////////////////////////////////////////////
      onInitial() {
      }
      onCreate() {
      }
      onShown(isEnter, data) {
      }
      onHide(isExit) {
      }
      onDispose() {
      }
      /**
       * 
       * @param dt 间隔时间(s)
       * @param secondTick 
       */
      onUpdate(dt, secondTick) {
      }
    };
  }
});

// assets/scripts/framework/view/Decorators.ts
var Decorators_exports = {};
__export(Decorators_exports, {
  inject: () => inject,
  registSkin: () => registSkin
});
function inject(type, path4, data, optional) {
  return function(target, key) {
    target.__injectInfos = Object.assign({}, target.__injectInfos);
    if (!type) {
      console.error("inject type is null");
    }
    target.__injectInfos[key] = { type, path: path4, data, optional };
  };
}
function registSkin(uiPackage, componentName, data, isWindow, autoWarpper, registNow = false) {
  return function(target) {
    if (registNow) {
      SkinHelper.bindingSkin(target, uiPackage, componentName, data, isWindow, autoWarpper);
    } else {
      SkinHelper.preBindingSkin(target, uiPackage, componentName, data, isWindow, autoWarpper);
    }
  };
}
var init_Decorators = __esm({
  "assets/scripts/framework/view/Decorators.ts"() {
    init_SkinHelper();
  }
});

// assets/scripts/framework/view/GM/GMDocker.ts
var GMDocker_exports = {};
__export(GMDocker_exports, {
  GMDocker: () => GMDocker
});
var import_cc26, GMDocker;
var init_GMDocker = __esm({
  "assets/scripts/framework/view/GM/GMDocker.ts"() {
    import_cc26 = require("cc");
    init_fairygui();
    init_UIManager();
    init_Window();
    init_Decorators();
    GMDocker = class extends Window2 {
      constructor() {
        super(...arguments);
        this._offsetX = 0;
      }
      static get inst() {
        return this._inst;
      }
      onInitial() {
        GMDocker._inst = this;
        this._special = true;
        this.contentAsFrame = true;
        this.topMost = true;
        this.topPriority = 100;
        this.canAutoDestory = false;
      }
      onCreate() {
        this._offsetX = (GRoot.inst.width - import_cc26.view.getVisibleSize().width) / 2;
        this.window.on(Event.DRAG_END, this.onDragEnd, this);
        this.component.draggable = true;
        this.component.onClick(() => {
          this.hide();
          UIManager.instance.showWindow("GMMananger");
        });
        this.window.setPosition(-this.window.width * 0.5 + this._offsetX, 400);
      }
      onDragEnd(evt) {
        let fw = GRoot.inst.width;
        let fh = GRoot.inst.height;
        let w = this.window.width;
        let h = this.window.height;
        let x = this.window.x < this._offsetX ? -w * 0.5 + this._offsetX : this.window.x > fw - w - this._offsetX ? fw - w * 0.5 - this._offsetX : this.window.x;
        let y = this.window.y < 0 ? -h * 0.5 : this.window.y > fh - h ? fh - h * 0.5 : this.window.y;
        this.window.setPosition(x, y);
      }
    };
    GMDocker = __decorateClass([
      registSkin("gm", "GMDocker", null, true)
    ], GMDocker);
  }
});

// assets/scripts/framework/view/GM/GMItem.ts
var GMItem_exports = {};
__export(GMItem_exports, {
  EGMItemType: () => EGMItemType,
  EGMValueType: () => EGMValueType,
  GMEvent: () => GMEvent,
  GMItem: () => GMItem,
  GMItemInfo: () => GMItemInfo
});
var EGMItemType, EGMValueType, GMItemInfo, GMEvent, GMItem;
var init_GMItem = __esm({
  "assets/scripts/framework/view/GM/GMItem.ts"() {
    init_fairygui();
    init_Decorators();
    init_View();
    EGMItemType = /* @__PURE__ */ ((EGMItemType2) => {
      EGMItemType2[EGMItemType2["Input"] = 0] = "Input";
      EGMItemType2[EGMItemType2["Slider"] = 1] = "Slider";
      EGMItemType2[EGMItemType2["Button"] = 2] = "Button";
      EGMItemType2[EGMItemType2["Switch"] = 3] = "Switch";
      EGMItemType2[EGMItemType2["Selector"] = 4] = "Selector";
      return EGMItemType2;
    })(EGMItemType || {});
    EGMValueType = /* @__PURE__ */ ((EGMValueType2) => {
      EGMValueType2[EGMValueType2["int"] = 0] = "int";
      EGMValueType2[EGMValueType2["float"] = 1] = "float";
      EGMValueType2[EGMValueType2["string"] = 2] = "string";
      EGMValueType2[EGMValueType2["boolean"] = 3] = "boolean";
      return EGMValueType2;
    })(EGMValueType || {});
    GMItemInfo = class {
    };
    GMEvent = class {
    };
    GMItem = class extends View2 {
      constructor() {
        super(...arguments);
        this._info = null;
        this._event = new GMEvent();
      }
      onCreate(data) {
        this.input.promptText = "";
        this.input.on(Event.TEXT_CHANGE, this._onTextChanged, this);
        this.slider.on(Event.STATUS_CHANGED, this._onSliderChanged, this);
        this.button.onClick(this._onButtonClick, this);
        this.switcher.onClick(this._onSwitchrClick, this);
        this.selector.on(Event.STATUS_CHANGED, this._onSelectorChanged, this);
      }
      reset(data) {
        this._info = data;
        this._event.category = this._info.category;
        this.title.text = this._event.name = this._info.name;
        this.type.selectedIndex = this._info.type;
        this.selector.items = [];
        if (this._info.type == 1 /* Slider */) {
          this.slider.min = this._info.min;
          this.slider.max = this._info.max;
        }
        switch (data.type) {
          case 0 /* Input */:
            this.input.text = data.defaultValue.toString();
            this._getValueFromInput();
            break;
          case 1 /* Slider */:
            this.slider.value = data.defaultValue;
            this.input.text = (Math.round(this.slider.value * 1e3) / 1e3).toString();
            this._event.value = this.slider.value;
            break;
          case 3 /* Switch */:
            this.switcher.selected = data.defaultValue;
            this._event.value = this.switcher.selected;
            break;
          case 4 /* Selector */:
            this.selector.items = data.defaultValues;
            this.selector.selectedIndex = data.defaultValue;
            break;
        }
        this._onTextChanged();
      }
      _getValueFromInput() {
        switch (this._info.valueType) {
          case 0 /* int */: {
            let val = parseInt(this.input.text);
            if (!Number.isNaN(val)) {
              this._event.value = val;
              if (this._info.type == 1 /* Slider */) {
                this.slider.value = val;
                this.input.text = val.toString();
              }
            }
            break;
          }
          case 1 /* float */: {
            let val = parseFloat(this.input.text);
            if (!Number.isNaN(val)) {
              this._event.value = val;
              if (this._info.type == 1 /* Slider */) {
                this.slider.value = val;
                this.input.text = val.toString();
              }
            }
            break;
          }
          case 2 /* string */: {
            this._event.value = this.input.text;
            break;
          }
        }
      }
      _onTextChanged() {
        this._getValueFromInput();
      }
      _sendMessage() {
        var _a;
        this._info.defaultValue = this._event.value;
        (_a = this._info.callback) == null ? void 0 : _a.call(this._info.thisObj, this._event);
      }
      _onSliderChanged(evt) {
        if (this._info.type == 1 /* Slider */) {
          this.input.text = (Math.round(this.slider.value * 1e3) / 1e3).toString();
          this._event.value = this.slider.value;
          this._sendMessage();
        }
      }
      _onSelectorChanged(evt) {
        this._event.value = this.selector.selectedIndex;
        this._sendMessage();
      }
      _onButtonClick(evt) {
        this._sendMessage();
      }
      _onSwitchrClick(evt) {
        this._event.value = this.switcher.selected;
        this._sendMessage();
      }
    };
    __decorateClass([
      inject(GTextField)
    ], GMItem.prototype, "title", 2);
    __decorateClass([
      inject(GTextInput, "input.input")
    ], GMItem.prototype, "input", 2);
    __decorateClass([
      inject(GSlider)
    ], GMItem.prototype, "slider", 2);
    __decorateClass([
      inject(GButton)
    ], GMItem.prototype, "button", 2);
    __decorateClass([
      inject(GButton)
    ], GMItem.prototype, "switcher", 2);
    __decorateClass([
      inject(GComboBox)
    ], GMItem.prototype, "selector", 2);
    __decorateClass([
      inject(Controller)
    ], GMItem.prototype, "type", 2);
  }
});

// assets/scripts/framework/view/TweenWindow.ts
var TweenWindow_exports = {};
__export(TweenWindow_exports, {
  TweenWindow: () => TweenWindow
});
var TweenWindow;
var init_TweenWindow = __esm({
  "assets/scripts/framework/view/TweenWindow.ts"() {
    init_fairygui();
    init_Window();
    init_CoroutineUtils();
    TweenWindow = class _TweenWindow extends Window2 {
      constructor() {
        super(...arguments);
        this.inDuration = 0.375;
        this.outDuration = 0.25;
        this.inEase = EaseType.BackOut;
        this.outEase = EaseType.BackIn;
      }
      onAfterInitial() {
        this.addTransitionIfNeeded(_TweenWindow.enterTransition, (name) => this.inAnimation = name);
        this.addTransitionIfNeeded(_TweenWindow.exitTransition, (name) => this.outAnimation = name);
      }
      addTransitionIfNeeded(transition, assignName) {
        if (transition && !this[assignName]) {
          this[assignName] = transition.name;
          this.window.contentPane.addTransition(transition);
        }
      }
      async playShowAnimation() {
        this.component.touchable = false;
        if (this.inAnimation) {
          await this.playTransition(this.inAnimation);
        } else {
          this.playDefaultShowAnimation();
          await CoroutineUtils.wait(this.inDuration);
        }
        this.component.touchable = true;
      }
      async playTransition(animationName) {
        let next = false;
        let tr = this.component.getTransition(animationName);
        tr.play(() => {
          next = true;
        });
        await CoroutineUtils.until(() => next);
      }
      playDefaultShowAnimation() {
        GTween.kill(this.component, true, this.component.setScale);
        GTween.to2(0, 0, 1, 1, this.inDuration).setEase(this.inEase).setTarget(this.component, this.component.setScale);
      }
      async playHideAnimation() {
        this.component.touchable = false;
        if (this.outAnimation) {
          await this.playTransitionWithHide(this.outAnimation);
        } else {
          this.playDefaultHideAnimation();
          await CoroutineUtils.wait(this.outDuration);
        }
        this.component.touchable = true;
      }
      async playTransitionWithHide(animationName) {
        let next = false;
        let tr = this.component.getTransition(animationName);
        tr.play(() => {
          this.hideImmediately();
          next = true;
        });
        await CoroutineUtils.until(() => next);
      }
      playDefaultHideAnimation() {
        GTween.kill(this.component, true, this.component.setScale);
        GTween.to2(1, 1, 0, 0, this.outDuration).setEase(this.outEase).setTarget(this.component, this.component.setScale).onComplete(() => {
          this.hideImmediately();
        });
      }
      hideNow(code) {
        this.internalHide(true, code);
      }
      hide(code) {
        this.internalHide(false, code);
      }
      async registTap() {
        if (!this.waitAnimation) {
          await CoroutineUtils.until(() => !this.isShowing);
        }
        super.registTap();
      }
    };
  }
});

// assets/scripts/framework/view/GM/GMMananger.ts
var GMMananger_exports = {};
__export(GMMananger_exports, {
  GMMananger: () => GMMananger
});
var GMManangerName, GMDockerName, GMMananger;
var init_GMMananger = __esm({
  "assets/scripts/framework/view/GM/GMMananger.ts"() {
    init_fairygui();
    init_Decorators();
    init_TweenWindow();
    init_UIManager();
    init_ViewHelper();
    init_GMDocker();
    init_GMItem();
    GMManangerName = "GMMananger";
    GMDockerName = "GMDocker";
    GMMananger = class extends TweenWindow {
      constructor() {
        super(...arguments);
        this._tables = {};
        this._items = {};
        this._first = true;
      }
      static get inst() {
        if (!this._inst) {
          this._inst = ViewHelper.instance.getSingleWindowByType(GMMananger);
        }
        return this._inst;
      }
      static show() {
        UIManager.instance.showWindow("GMMananger");
      }
      static setEnable(value) {
        var _a;
        if (value && !((_a = GMDocker.inst) == null ? void 0 : _a.visible)) {
          UIManager.instance.showWindow(GMDockerName, null, false);
        } else if (!value) {
          UIManager.instance.hideWindow(GMDockerName);
          UIManager.instance.hideWindow(GMManangerName);
        }
      }
      onInitial() {
        this.topMost = true;
        this.topPriority = 100;
      }
      onCreate() {
        GMMananger._inst = this;
        this.tabs.on(Event.CLICK_ITEM, this._onTabClick, this);
        this.btnClose.onClick(() => {
          this.hide();
          UIManager.instance.showWindow(GMDockerName, null, false);
        }, this);
        this.tabs.removeChildrenToPool();
        this.tools.removeChildrenToPool();
      }
      _onTabClick(evt) {
        this._refresh(evt.text);
      }
      _addItem(item) {
        let key = item.category;
        let tb = this._tables[key];
        if (!tb) {
          tb = this.tabs.addItemFromPool();
          this._tables[key] = tb;
          tb.text = item.category;
          this._items[key] = [];
        }
        this._items[key].push(item);
      }
      _updateItem(item) {
        let view5 = this.tools.addItemFromPool();
        let gmitem;
        if (!view5.data) {
          gmitem = new GMItem();
          gmitem.inject(view5, item);
          view5.data = gmitem;
        } else {
          gmitem = view5.data;
        }
        gmitem.reset(item);
      }
      _refresh(key) {
        this.tools.removeChildrenToPool();
        let items = this._items[key];
        items.forEach((item) => {
          this._updateItem(item);
        });
      }
      refresh() {
        if (this.tabs.numChildren > 0) {
          this.tabs.selectedIndex = 0;
          this._refresh(this.tabs.getChildAt(0).text);
        }
      }
      onShown(data) {
        if (this._first) {
          this._first = false;
          this.refresh();
        }
        this.window.makeFullScreen();
        this.window.center();
      }
      addInt(catetory, name, value, callback, thisObj) {
        let itemInfo = new GMItemInfo();
        itemInfo.type = 0 /* Input */;
        itemInfo.category = catetory;
        itemInfo.name = name;
        itemInfo.valueType = 0 /* int */;
        itemInfo.defaultValue = value;
        itemInfo.callback = callback;
        itemInfo.thisObj = thisObj;
        this._addItem(itemInfo);
      }
      addFloat(catetory, name, value, callback, thisObj) {
        let itemInfo = new GMItemInfo();
        itemInfo.type = 0 /* Input */;
        itemInfo.category = catetory;
        itemInfo.name = name;
        itemInfo.valueType = 1 /* float */;
        itemInfo.defaultValue = value;
        itemInfo.callback = callback;
        itemInfo.thisObj = thisObj;
        this._addItem(itemInfo);
      }
      addString(catetory, name, value, callback, thisObj) {
        let itemInfo = new GMItemInfo();
        itemInfo.type = 0 /* Input */;
        itemInfo.category = catetory;
        itemInfo.name = name;
        itemInfo.valueType = 2 /* string */;
        itemInfo.defaultValue = value;
        itemInfo.callback = callback;
        itemInfo.thisObj = thisObj;
        this._addItem(itemInfo);
      }
      addRange(catetory, name, min, max, value, callback, thisObj) {
        let itemInfo = new GMItemInfo();
        itemInfo.type = 1 /* Slider */;
        itemInfo.category = catetory;
        itemInfo.name = name;
        itemInfo.min = min;
        itemInfo.max = max;
        itemInfo.defaultValue = value;
        itemInfo.valueType = 0 /* int */;
        itemInfo.callback = callback;
        itemInfo.thisObj = thisObj;
        this._addItem(itemInfo);
      }
      addRangeF(catetory, name, min, max, value, callback, thisObj) {
        let itemInfo = new GMItemInfo();
        itemInfo.type = 1 /* Slider */;
        itemInfo.category = catetory;
        itemInfo.name = name;
        itemInfo.min = min;
        itemInfo.max = max;
        itemInfo.defaultValue = value;
        itemInfo.valueType = 1 /* float */;
        itemInfo.callback = callback;
        itemInfo.thisObj = thisObj;
        this._addItem(itemInfo);
      }
      addButton(catetory, name, callback, thisObj) {
        let itemInfo = new GMItemInfo();
        itemInfo.type = 2 /* Button */;
        itemInfo.category = catetory;
        itemInfo.name = name;
        itemInfo.callback = callback;
        itemInfo.thisObj = thisObj;
        this._addItem(itemInfo);
      }
      addSwitch(catetory, name, value, callback, thisObj) {
        let itemInfo = new GMItemInfo();
        itemInfo.type = 3 /* Switch */;
        itemInfo.category = catetory;
        itemInfo.name = name;
        itemInfo.valueType = 3 /* boolean */;
        itemInfo.defaultValue = value;
        itemInfo.callback = callback;
        itemInfo.thisObj = thisObj;
        this._addItem(itemInfo);
      }
      addSelector(catetory, name, value, options, callback, thisObj) {
        let itemInfo = new GMItemInfo();
        itemInfo.type = 4 /* Selector */;
        itemInfo.category = catetory;
        itemInfo.name = name;
        itemInfo.valueType = 0 /* int */;
        itemInfo.defaultValue = value;
        itemInfo.defaultValues = options;
        itemInfo.callback = callback;
        itemInfo.thisObj = thisObj;
        this._addItem(itemInfo);
      }
    };
    __decorateClass([
      inject(GList)
    ], GMMananger.prototype, "tabs", 2);
    __decorateClass([
      inject(GList, "content.list")
    ], GMMananger.prototype, "tools", 2);
    __decorateClass([
      inject(GButton)
    ], GMMananger.prototype, "btnClose", 2);
    GMMananger = __decorateClass([
      registSkin("gm", GMManangerName)
    ], GMMananger);
  }
});

// assets/scripts/framework/view/common/CommonToast.ts
var CommonToast_exports = {};
__export(CommonToast_exports, {
  default: () => CommonToast
});
var _CommonToast, CommonToast;
var init_CommonToast = __esm({
  "assets/scripts/framework/view/common/CommonToast.ts"() {
    init_Decorators();
    init_fairygui();
    init_fairygui();
    init_View();
    init_fairygui();
    init_fairygui();
    _CommonToast = class _CommonToast extends View2 {
      constructor() {
        super(...arguments);
        this.title = null;
        this._animation = null;
      }
      static toast(tips, ...args) {
        if (!_CommonToast.I) {
          _CommonToast.initializeInstance();
        }
        let instance = _CommonToast.I;
        _CommonToast.setTips(instance, tips, args);
        _CommonToast.showPopup(instance);
        instance._animation.play(() => {
          GRoot.inst.hidePopup(instance.gObject);
        });
      }
      static initializeInstance() {
        let instance = new _CommonToast();
        instance.inject(UIPackage.createObject("common", "CommonToast"));
        _CommonToast.I = instance;
      }
      static setTips(instance, tips, args) {
        if (typeof tips == "number") {
          instance.title.setText(tips, ...args);
        } else {
          instance.title.text = tips;
        }
      }
      static showPopup(instance) {
        GRoot.inst.showPopup(instance.gObject);
        instance.gObject.setPosition(
          GRoot.inst.x + GRoot.inst.width / 2 - instance.gObject.width / 2,
          GRoot.inst.y + GRoot.inst.height / 2 - instance.gObject.height / 2
        );
      }
    };
    __decorateClass([
      inject(GLabel)
    ], _CommonToast.prototype, "title", 2);
    __decorateClass([
      inject(Transition, "show")
    ], _CommonToast.prototype, "_animation", 2);
    CommonToast = _CommonToast;
  }
});

// assets/scripts/framework/view/common/LocationManager.ts
var LocationManager_exports = {};
__export(LocationManager_exports, {
  LocationManager: () => LocationManager,
  LocationResult: () => LocationResult
});
var import_cc27, LocationResult, result_t, _LocationManager, LocationManager;
var init_LocationManager = __esm({
  "assets/scripts/framework/view/common/LocationManager.ts"() {
    import_cc27 = require("cc");
    init_SpaceUtils();
    LocationResult = class {
      constructor() {
        this.pos = new import_cc27.Vec2();
        this.size = new import_cc27.Size();
        this.auto = true;
      }
      // 自动转为全局坐标
    };
    result_t = new LocationResult();
    _LocationManager = class _LocationManager {
      constructor() {
        this._locations = {};
      }
      static get inst() {
        return this._inst;
      }
      regist(target) {
        target.getLocations().forEach((loc) => {
          this._locations[loc] = [target, ...this._locations[loc] || []];
        });
      }
      unregist(target) {
        target.getLocations().forEach((loc) => {
          if (this._locations[loc]) {
            const index = this._locations[loc].indexOf(target);
            if (index !== -1) {
              this._locations[loc].splice(index, 1);
            }
          }
        });
      }
      getLocation(loc, data, result = result_t) {
        if (!this._locations[loc] || this._locations[loc].length == 0) {
          console.error(`\u672A\u6CE8\u518C\u70B9\u4F4D\uFF1A${loc}`);
          return null;
        }
        result.target = null;
        result.auto = true;
        this._locations[loc][0].getLocation(loc, result, data);
        if (result.target && result.auto) {
          SpaceUtils.getGObjectCenterPos(result.target, result.pos);
          result.target.localToGlobal(result.pos.x, result.pos.y, result.pos);
          result.size.set(result.target.width, result.target.height);
        }
        return result;
      }
    };
    _LocationManager._inst = new _LocationManager();
    LocationManager = _LocationManager;
  }
});

// assets/scripts/framework/view/common/SpineView.ts
var SpineView_exports = {};
__export(SpineView_exports, {
  SpineView: () => SpineView
});
var SpineView;
var init_SpineView = __esm({
  "assets/scripts/framework/view/common/SpineView.ts"() {
    init_fairygui();
    init_View();
    init_CoroutineUtils();
    SpineView = class _SpineView extends View2 {
      constructor() {
        super(...arguments);
        this.replayOnShow = true;
        this._loading = false;
        this._playing = false;
        this._currentAnimation = "";
      }
      get loading() {
        return this._loading;
      }
      registInfos() {
        super.registInfos();
        this.injectInfos = {};
      }
      get currentAnimation() {
        return this._currentAnimation;
      }
      onCreate(data) {
        this.graph = this.gObject;
        this.graph.touchable = false;
        this.component.visible = false;
        this.reset(data);
      }
      getKey(data) {
        if (!data) {
          return "";
        }
        return `${data.res}|${data.ani}|${data.trackIndex}`;
      }
      loadAndPlay(res, ani = 1, loop = false, trackIndex = 0) {
        let data = this._initData || { res };
        data.res = res;
        data.ani = ani;
        data.loop = loop;
        data.trackIndex = trackIndex;
        this.reset(data, true);
      }
      reset(data, play) {
        if (!data || !data.res) {
          return;
        }
        this._initData = data;
        this._initData.load = this._initData.load ?? false;
        this._initData.play = play ?? this._initData.play ?? false;
        this._initData.trackIndex = this._initData.trackIndex ?? 0;
        if (this._lastKey == this.getKey(this._initData)) {
          if (this.spEntity) {
            this.spEntity.skeleton._renderDataFlag = false;
          }
          return;
        }
        this.stop();
        this.replayOnShow = this._initData.replayOnShow ?? this.replayOnShow;
        if (this._initData.load || this._initData.play) {
          this.load();
        }
        if (this._initData.play) {
          this._play();
        }
      }
      async load() {
        var _a, _b, _c, _d;
        if (this.spEntity || !this._initData || !this._initData.res) {
          return;
        }
        if (this._loading) {
          await CoroutineUtils.until(() => !!this.spEntity);
          return;
        }
        this._loading = true;
        let data = this._initData;
        let res = data.res;
        try {
          this.spEntity = await _SpineView.EffectManager.loadEffect(res);
          if (((_b = (_a = this.spEntity) == null ? void 0 : _a.node) == null ? void 0 : _b.isValid) && ((_d = (_c = this.graph) == null ? void 0 : _c.node) == null ? void 0 : _d.isValid)) {
            if (this.graph instanceof GGraph) {
              this.graph.clearGraphics();
            }
            this.graph.node.addChild(this.spEntity.node);
          } else {
            throw new Error("\u52A0\u8F7Dspine\u5931\u8D25");
          }
        } catch (error) {
          console.error(error, this._initData);
        } finally {
          this._loading = false;
        }
      }
      async _play() {
        if (!this._initData || !this._initData.res) {
          return;
        }
        let dt = this._initData;
        await this.play(dt.ani || this._currentAnimation, !!dt.loop, dt.trackIndex ?? 0);
      }
      onShown(data, changeVisiable) {
        if (this._playing) {
          if (this.replayOnShow && this.component.visible) {
            this._play();
          }
        }
      }
      async replay(restart = false) {
        if (restart || !this._playing) {
          this.stop();
          this.show();
          this.visible = true;
          await this._play();
        }
      }
      async stop() {
        var _a;
        if (this.spEntity) {
          if (!((_a = this.spEntity.skeleton) == null ? void 0 : _a.isAnimationCached())) {
            this.spEntity.skeleton.clearTracks();
          }
          _SpineView.EffectManager.removeEffect(this.spEntity);
          this.spEntity = null;
          this._loading = false;
        }
        this._lastKey = null;
        this._playing = false;
        this.component.visible = false;
        this._currentAnimation = "";
      }
      async play(key, loop = false, trackIndex = 0, replaceInitData = false, replay = false) {
        replay = replay || this._currentAnimation !== key;
        if (!replay && this._playing) {
          return;
        }
        if (!this.spEntity) {
          await this.load();
        }
        if (!this.spEntity) {
          this.stop();
          return;
        }
        this._lastKey = this.getKey(this._initData);
        this._playing = true;
        key = key || this._initData.ani;
        let name = typeof key === "string" ? key : "";
        let idx = typeof key === "number" ? key : 1;
        if (!name && this.spEntity.skeleton.skeletonData) {
          let anims = this.spEntity.skeleton.skeletonData.getAnimsEnum();
          let keys = Object.keys(anims);
          if (idx < 0 || idx >= keys.length) {
            idx = 1;
            console.error("spine\u52A8\u753B\u7D22\u5F15\u8D8A\u754C", this._initData);
          }
          name = keys[idx];
        }
        if (!name) {
          console.error("spine\u52A8\u753B\u4E0D\u5B58\u5728", this._initData);
          return;
        }
        if (replaceInitData) {
          this._initData.ani = name;
          this._initData.trackIndex = trackIndex;
          this._initData.loop = loop;
        }
        this._currentAnimation = name;
        this.component.visible = true;
        await CoroutineUtils.until(() => this.spEntity && this.spEntity.node.activeInHierarchy);
        this.spEntity.skeleton.setAnimation(trackIndex, name, loop);
        if (!loop) {
          let next = false;
          this.spEntity.skeleton.setCompleteListener(() => next = true);
          await CoroutineUtils.until(() => next);
          if (!this._initData.stayLast && this.spEntity && name == this.spEntity.skeleton.animation) {
            this.stop();
          }
        }
      }
    };
  }
});

// assets/scripts/framework/view/index.ts
var view_exports = {};
__export(view_exports, {
  default: () => view_default
});
var view_default;
var init_view = __esm({
  "assets/scripts/framework/view/index.ts"() {
    init_UtilsHelper();
    init_UIManager();
    init_Skin();
    init_Activity();
    init_Window();
    init_ViewHelper();
    init_View();
    init_SkinHelper();
    init_PinchGesture();
    init_SwipeGesture();
    init_Decorators();
    init_TweenWindow();
    view_default = {
      UtilsHelper,
      UIManager,
      Skin,
      Window: Window2,
      TweenWindow,
      Activity,
      ELayer,
      View: View2,
      SkinHelper,
      PinchGesture,
      SwipeGesture,
      inject
    };
  }
});

// assets/scripts/framework/view/interface/IActivity.ts
var IActivity_exports = {};
var init_IActivity = __esm({
  "assets/scripts/framework/view/interface/IActivity.ts"() {
  }
});

// assets/scripts/framework/view/interface/IAutoInject.ts
var IAutoInject_exports = {};
var init_IAutoInject = __esm({
  "assets/scripts/framework/view/interface/IAutoInject.ts"() {
  }
});

// assets/scripts/framework/view/interface/IComponent.ts
var IComponent_exports = {};
var init_IComponent = __esm({
  "assets/scripts/framework/view/interface/IComponent.ts"() {
  }
});

// assets/scripts/framework/view/interface/IContainer.ts
var IContainer_exports = {};
var init_IContainer = __esm({
  "assets/scripts/framework/view/interface/IContainer.ts"() {
  }
});

// assets/scripts/framework/view/interface/IInjectInfo.ts
var IInjectInfo_exports = {};
var init_IInjectInfo = __esm({
  "assets/scripts/framework/view/interface/IInjectInfo.ts"() {
  }
});

// assets/scripts/framework/view/interface/IView.ts
var IView_exports = {};
var init_IView = __esm({
  "assets/scripts/framework/view/interface/IView.ts"() {
  }
});

// assets/scripts/framework/view/interface/IWindow.ts
var IWindow_exports = {};
var init_IWindow = __esm({
  "assets/scripts/framework/view/interface/IWindow.ts"() {
  }
});

// assets/scripts/framework/view/utils/fgui_patch.ts
var fgui_patch_exports = {};
__export(fgui_patch_exports, {
  default: () => fgui_patch_default
});
async function setClickCD(gObj, cd = 1) {
  if (gObj["_ck_interval_"]) {
    return;
  }
  gObj["_ck_interval_"] = true;
  await CoroutineUtils.oneframe();
  if (gObj.isDisposed) {
    return;
  }
  delete gObj["_ck_interval_"];
  gObj.touchable = false;
  await CoroutineUtils.wait(cd);
  gObj.touchable = true;
}
var addChildAt, btnClick1, fgui_patch_default;
var init_fgui_patch = __esm({
  "assets/scripts/framework/view/utils/fgui_patch.ts"() {
    init_fairygui();
    init_I18N();
    init_UIManager();
    init_StringUtils();
    init_CoroutineUtils();
    addChildAt = GComponent.prototype.addChildAt;
    GComponent.prototype.addChildAt = function(child, index) {
      let that = this;
      var cld = addChildAt.call(that, child, index);
      if (child && that.parent) {
        child.node.layer = that.parent.node.layer;
      }
      return cld;
    };
    GLoader.prototype["_hitTest"] = function(pt, globalPt) {
      let that = this;
      if (that.node.name.startsWith("[AUTO]") && that.component) {
        return that.component["_hitTest"](pt, globalPt);
      }
      if (!that.touchable) {
        return null;
      }
      if (pt.x >= 0 && pt.y >= 0 && pt.x < this._width && pt.y < this._height)
        return this;
      else
        return null;
    };
    btnClick1 = GButton.prototype["onClick_1"];
    GButton.prototype["onClick_1"] = function() {
      let that = this;
      if (UIManager.onButtonClick) {
        UIManager.onButtonClick(that);
      }
      btnClick1.call(that);
      let clickInterval = this.clickInterval || 0;
      if (clickInterval > 0) {
        setClickCD(that, clickInterval);
      }
    };
    GObject.prototype["setClick"] = function(callback, target) {
      this.offClick(callback, target);
      this.onClick(callback, target);
    };
    GObject.prototype["setTitle"] = function(data, ...args) {
      var _a;
      if (typeof data == "number") {
        let text = ((_a = I18N.inst.getItem(data)) == null ? void 0 : _a.Text) || `[lang${data}]`;
        if (text) {
          text = text.replace(/\\n/g, "\n");
        }
        this.text = StringUtils.format(text, ...args);
      } else {
        this.text = StringUtils.format(data, ...args);
      }
    };
    GObject.prototype["setText"] = function(data, ...args) {
      var _a;
      if (typeof data == "number") {
        let text = ((_a = I18N.inst.getItem(data)) == null ? void 0 : _a.Text) || `[lang${data}]`;
        if (text) {
          text = text.replace(/\\n/g, "\n");
        }
        this.text = StringUtils.format(text, ...args);
      } else {
        this.text = StringUtils.format(data, ...args);
      }
    };
    GComponent.prototype["clone"] = function() {
      let that = this;
      return UIPackage.createObjectFromURL(that.resourceURL);
    };
    ScrollPane["globalTouchEffect"] = true;
    Object.defineProperty(ScrollPane.prototype, "_touchEffect", {
      get: function() {
        return this.touchEffect__ && ScrollPane["globalTouchEffect"];
      },
      set: function(v) {
        this.touchEffect__ = v;
      }
    });
    fgui_patch_default = null;
  }
});

// require("../../**/*") in assets/scripts/framework/patch/ccc_patch.ts
var globRequire;
var init_ = __esm({
  'require("../../**/*") in assets/scripts/framework/patch/ccc_patch.ts'() {
    globRequire = __glob({
      "../../framework.meta": () => require("../../framework.meta"),
      "../../framework/GameSettings.ts": () => (init_GameSettings(), __toCommonJS(GameSettings_exports)),
      "../../framework/GameSettings.ts.meta": () => require("../../framework/GameSettings.ts.meta"),
      "../../framework/activity.meta": () => require("../../framework/activity.meta"),
      "../../framework/activity/controller.meta": () => require("../../framework/activity/controller.meta"),
      "../../framework/activity/controller/ActivityController.ts": () => (init_ActivityController(), __toCommonJS(ActivityController_exports)),
      "../../framework/activity/controller/ActivityController.ts.meta": () => require("../../framework/activity/controller/ActivityController.ts.meta"),
      "../../framework/activity/controller/BaseActivityController.ts": () => (init_BaseActivityController(), __toCommonJS(BaseActivityController_exports)),
      "../../framework/activity/controller/BaseActivityController.ts.meta": () => require("../../framework/activity/controller/BaseActivityController.ts.meta"),
      "../../framework/activity/controller/LoaderHelper.ts.meta": () => require("../../framework/activity/controller/LoaderHelper.ts.meta"),
      "../../framework/activity/proxy.meta": () => require("../../framework/activity/proxy.meta"),
      "../../framework/activity/proxy/AcitivityProxyManager.ts": () => (init_AcitivityProxyManager(), __toCommonJS(AcitivityProxyManager_exports)),
      "../../framework/activity/proxy/AcitivityProxyManager.ts.meta": () => require("../../framework/activity/proxy/AcitivityProxyManager.ts.meta"),
      "../../framework/activity/proxy/AcitivityViewManager.ts.meta": () => require("../../framework/activity/proxy/AcitivityViewManager.ts.meta"),
      "../../framework/activity/proxy/BaseActivityProxy.ts": () => (init_BaseActivityProxy(), __toCommonJS(BaseActivityProxy_exports)),
      "../../framework/activity/proxy/BaseActivityProxy.ts.meta": () => require("../../framework/activity/proxy/BaseActivityProxy.ts.meta"),
      "../../framework/activity/proxy/BaseActivityView.ts.meta": () => require("../../framework/activity/proxy/BaseActivityView.ts.meta"),
      "../../framework/activity/proxy/IActivityProxy.ts": () => (init_IActivityProxy(), __toCommonJS(IActivityProxy_exports)),
      "../../framework/activity/proxy/IActivityProxy.ts.meta": () => require("../../framework/activity/proxy/IActivityProxy.ts.meta"),
      "../../framework/activity/proxy/IActivityView.ts.meta": () => require("../../framework/activity/proxy/IActivityView.ts.meta"),
      "../../framework/common.meta": () => require("../../framework/common.meta"),
      "../../framework/common/CombineTexMaterialMgr.ts": () => require_CombineTexMaterialMgr(),
      "../../framework/common/CombineTexMaterialMgr.ts.meta": () => require("../../framework/common/CombineTexMaterialMgr.ts.meta"),
      "../../framework/common/EncryptHelper.ts": () => (init_EncryptHelper(), __toCommonJS(EncryptHelper_exports)),
      "../../framework/common/EncryptHelper.ts.meta": () => require("../../framework/common/EncryptHelper.ts.meta"),
      "../../framework/common/EventCenter.ts": () => (init_EventCenter(), __toCommonJS(EventCenter_exports)),
      "../../framework/common/EventCenter.ts.meta": () => require("../../framework/common/EventCenter.ts.meta"),
      "../../framework/common/EventHandler.ts": () => (init_EventHandler(), __toCommonJS(EventHandler_exports)),
      "../../framework/common/EventHandler.ts.meta": () => require("../../framework/common/EventHandler.ts.meta"),
      "../../framework/common/FGUIExt.ts.meta": () => require("../../framework/common/FGUIExt.ts.meta"),
      "../../framework/common/LoaderHelper.ts": () => (init_LoaderHelper(), __toCommonJS(LoaderHelper_exports)),
      "../../framework/common/LoaderHelper.ts.meta": () => require("../../framework/common/LoaderHelper.ts.meta"),
      "../../framework/common/Logger.ts": () => (init_Logger(), __toCommonJS(Logger_exports)),
      "../../framework/common/Logger.ts.meta": () => require("../../framework/common/Logger.ts.meta"),
      "../../framework/common/Pool.ts": () => (init_Pool(), __toCommonJS(Pool_exports)),
      "../../framework/common/Pool.ts.meta": () => require("../../framework/common/Pool.ts.meta"),
      "../../framework/common/PoolManager.ts": () => (init_PoolManager(), __toCommonJS(PoolManager_exports)),
      "../../framework/common/PoolManager.ts.meta": () => require("../../framework/common/PoolManager.ts.meta"),
      "../../framework/common/Pools.ts": () => (init_Pools(), __toCommonJS(Pools_exports)),
      "../../framework/common/Pools.ts.meta": () => require("../../framework/common/Pools.ts.meta"),
      "../../framework/common/ResManager.ts": () => (init_ResManager(), __toCommonJS(ResManager_exports)),
      "../../framework/common/ResManager.ts.meta": () => require("../../framework/common/ResManager.ts.meta"),
      "../../framework/common/SoundManager.ts": () => (init_SoundManager(), __toCommonJS(SoundManager_exports)),
      "../../framework/common/SoundManager.ts.meta": () => require("../../framework/common/SoundManager.ts.meta"),
      "../../framework/common/StorageManager.ts": () => (init_StorageManager(), __toCommonJS(StorageManager_exports)),
      "../../framework/common/StorageManager.ts.meta": () => require("../../framework/common/StorageManager.ts.meta"),
      "../../framework/common/TaskManager.ts": () => (init_TaskManager(), __toCommonJS(TaskManager_exports)),
      "../../framework/common/TaskManager.ts.meta": () => require("../../framework/common/TaskManager.ts.meta"),
      "../../framework/common/TimeWatcher.ts": () => (init_TimeWatcher(), __toCommonJS(TimeWatcher_exports)),
      "../../framework/common/TimeWatcher.ts.meta": () => require("../../framework/common/TimeWatcher.ts.meta"),
      "../../framework/common/Timer.ts": () => (init_Timer(), __toCommonJS(Timer_exports)),
      "../../framework/common/Timer.ts.meta": () => require("../../framework/common/Timer.ts.meta"),
      "../../framework/core.meta": () => require("../../framework/core.meta"),
      "../../framework/libs.meta": () => require("../../framework/libs.meta"),
      "../../framework/libs/md5.ts": () => (init_md5(), __toCommonJS(md5_exports)),
      "../../framework/libs/md5.ts.meta": () => require("../../framework/libs/md5.ts.meta"),
      "../../framework/macro.ts": () => (init_macro(), __toCommonJS(macro_exports)),
      "../../framework/macro.ts.meta": () => require("../../framework/macro.ts.meta"),
      "../../framework/modules.meta": () => require("../../framework/modules.meta"),
      "../../framework/modules/Bridge.ts": () => (init_Bridge(), __toCommonJS(Bridge_exports)),
      "../../framework/modules/Bridge.ts.meta": () => require("../../framework/modules/Bridge.ts.meta"),
      "../../framework/modules/ControllerManager.ts": () => (init_ControllerManager(), __toCommonJS(ControllerManager_exports)),
      "../../framework/modules/ControllerManager.ts.meta": () => require("../../framework/modules/ControllerManager.ts.meta"),
      "../../framework/modules/ModelMapper.ts": () => (init_ModelMapper(), __toCommonJS(ModelMapper_exports)),
      "../../framework/modules/ModelMapper.ts.meta": () => require("../../framework/modules/ModelMapper.ts.meta"),
      "../../framework/modules/base.meta": () => require("../../framework/modules/base.meta"),
      "../../framework/modules/base/BaseController.ts": () => (init_BaseController(), __toCommonJS(BaseController_exports)),
      "../../framework/modules/base/BaseController.ts.meta": () => require("../../framework/modules/base/BaseController.ts.meta"),
      "../../framework/modules/base/BaseDAO.ts": () => (init_BaseDAO(), __toCommonJS(BaseDAO_exports)),
      "../../framework/modules/base/BaseDAO.ts.meta": () => require("../../framework/modules/base/BaseDAO.ts.meta"),
      "../../framework/modules/base/BaseModel.ts": () => (init_BaseModel(), __toCommonJS(BaseModel_exports)),
      "../../framework/modules/base/BaseModel.ts.meta": () => require("../../framework/modules/base/BaseModel.ts.meta"),
      "../../framework/modules/base/SecretController.ts": () => (init_SecretController(), __toCommonJS(SecretController_exports)),
      "../../framework/modules/base/SecretController.ts.meta": () => require("../../framework/modules/base/SecretController.ts.meta"),
      "../../framework/modules/base/SecretDAO.ts": () => (init_SecretDAO(), __toCommonJS(SecretDAO_exports)),
      "../../framework/modules/base/SecretDAO.ts.meta": () => require("../../framework/modules/base/SecretDAO.ts.meta"),
      "../../framework/modules/base/SecretModel.ts": () => (init_SecretModel(), __toCommonJS(SecretModel_exports)),
      "../../framework/modules/base/SecretModel.ts.meta": () => require("../../framework/modules/base/SecretModel.ts.meta"),
      "../../framework/modules/base/types.ts": () => (init_types(), __toCommonJS(types_exports)),
      "../../framework/modules/base/types.ts.meta": () => require("../../framework/modules/base/types.ts.meta"),
      "../../framework/modules/system.meta": () => require("../../framework/modules/system.meta"),
      "../../framework/modules/system/SystemController.ts": () => (init_SystemController(), __toCommonJS(SystemController_exports)),
      "../../framework/modules/system/SystemController.ts.meta": () => require("../../framework/modules/system/SystemController.ts.meta"),
      "../../framework/patch.meta": () => require("../../framework/patch.meta"),
      "../../framework/patch/ccc_patch.ts": () => (init_ccc_patch(), __toCommonJS(ccc_patch_exports)),
      "../../framework/patch/ccc_patch.ts.meta": () => require("../../framework/patch/ccc_patch.ts.meta"),
      "../../framework/patch/ccc_pref_renderer.ts": () => (init_ccc_pref_renderer(), __toCommonJS(ccc_pref_renderer_exports)),
      "../../framework/patch/ccc_pref_renderer.ts.meta": () => require("../../framework/patch/ccc_pref_renderer.ts.meta"),
      "../../framework/patch/fgui_patch.ts.meta": () => require("../../framework/patch/fgui_patch.ts.meta"),
      "../../framework/platform.meta": () => require("../../framework/platform.meta"),
      "../../framework/platform/Platform.ts": () => (init_Platform(), __toCommonJS(Platform_exports)),
      "../../framework/platform/Platform.ts.meta": () => require("../../framework/platform/Platform.ts.meta"),
      "../../framework/platform/PlatformSDK.ts": () => (init_PlatformSDK(), __toCommonJS(PlatformSDK_exports)),
      "../../framework/platform/PlatformSDK.ts.meta": () => require("../../framework/platform/PlatformSDK.ts.meta"),
      "../../framework/plugins.meta": () => require("../../framework/plugins.meta"),
      "../../framework/plugins/capture.meta": () => require("../../framework/plugins/capture.meta"),
      "../../framework/plugins/capture/CanvasPool.ts": () => (init_CanvasPool(), __toCommonJS(CanvasPool_exports)),
      "../../framework/plugins/capture/CanvasPool.ts.meta": () => require("../../framework/plugins/capture/CanvasPool.ts.meta"),
      "../../framework/plugins/capture/CaptureHelper.ts": () => (init_CaptureHelper(), __toCommonJS(CaptureHelper_exports)),
      "../../framework/plugins/capture/CaptureHelper.ts.meta": () => require("../../framework/plugins/capture/CaptureHelper.ts.meta"),
      "../../framework/plugins/config.meta": () => require("../../framework/plugins/config.meta"),
      "../../framework/plugins/config/DataAccess.ts": () => (init_DataAccess(), __toCommonJS(DataAccess_exports)),
      "../../framework/plugins/config/DataAccess.ts.meta": () => require("../../framework/plugins/config/DataAccess.ts.meta"),
      "../../framework/plugins/config/I18N.ts": () => (init_I18N(), __toCommonJS(I18N_exports)),
      "../../framework/plugins/config/I18N.ts.meta": () => require("../../framework/plugins/config/I18N.ts.meta"),
      "../../framework/plugins/config/Lang.ts": () => (init_Lang(), __toCommonJS(Lang_exports)),
      "../../framework/plugins/config/Lang.ts.meta": () => require("../../framework/plugins/config/Lang.ts.meta"),
      "../../framework/plugins/fsm.meta": () => require("../../framework/plugins/fsm.meta"),
      "../../framework/plugins/fsm/FSM.ts": () => (init_FSM(), __toCommonJS(FSM_exports)),
      "../../framework/plugins/fsm/FSM.ts.meta": () => require("../../framework/plugins/fsm/FSM.ts.meta"),
      "../../framework/plugins/gesture.meta": () => require("../../framework/plugins/gesture.meta"),
      "../../framework/plugins/gesture/Gesture.ts": () => (init_Gesture(), __toCommonJS(Gesture_exports)),
      "../../framework/plugins/gesture/Gesture.ts.meta": () => require("../../framework/plugins/gesture/Gesture.ts.meta"),
      "../../framework/plugins/gesture/LongTouchGesture.ts": () => (init_LongTouchGesture(), __toCommonJS(LongTouchGesture_exports)),
      "../../framework/plugins/gesture/LongTouchGesture.ts.meta": () => require("../../framework/plugins/gesture/LongTouchGesture.ts.meta"),
      "../../framework/plugins/gesture/PinchGesture.ts": () => (init_PinchGesture(), __toCommonJS(PinchGesture_exports)),
      "../../framework/plugins/gesture/PinchGesture.ts.meta": () => require("../../framework/plugins/gesture/PinchGesture.ts.meta"),
      "../../framework/plugins/gesture/SwipeGesture.ts": () => (init_SwipeGesture(), __toCommonJS(SwipeGesture_exports)),
      "../../framework/plugins/gesture/SwipeGesture.ts.meta": () => require("../../framework/plugins/gesture/SwipeGesture.ts.meta"),
      "../../framework/plugins/reddot.meta": () => require("../../framework/plugins/reddot.meta"),
      "../../framework/plugins/reddot/RedDotManager.ts": () => (init_RedDotManager(), __toCommonJS(RedDotManager_exports)),
      "../../framework/plugins/reddot/RedDotManager.ts.meta": () => require("../../framework/plugins/reddot/RedDotManager.ts.meta"),
      "../../framework/plugins/reddot/RedDotNode.ts": () => (init_RedDotNode(), __toCommonJS(RedDotNode_exports)),
      "../../framework/plugins/reddot/RedDotNode.ts.meta": () => require("../../framework/plugins/reddot/RedDotNode.ts.meta"),
      "../../framework/plugins/reddot/RedDotTree.ts": () => (init_RedDotTree(), __toCommonJS(RedDotTree_exports)),
      "../../framework/plugins/reddot/RedDotTree.ts.meta": () => require("../../framework/plugins/reddot/RedDotTree.ts.meta"),
      "../../framework/plugins/reddot/serialize.ts": () => (init_serialize(), __toCommonJS(serialize_exports)),
      "../../framework/plugins/reddot/serialize.ts.meta": () => require("../../framework/plugins/reddot/serialize.ts.meta"),
      "../../framework/utils.meta": () => require("../../framework/utils.meta"),
      "../../framework/utils/CoroutineUtils.ts": () => (init_CoroutineUtils(), __toCommonJS(CoroutineUtils_exports)),
      "../../framework/utils/CoroutineUtils.ts.meta": () => require("../../framework/utils/CoroutineUtils.ts.meta"),
      "../../framework/utils/MathUtils.ts": () => (init_MathUtils(), __toCommonJS(MathUtils_exports)),
      "../../framework/utils/MathUtils.ts.meta": () => require("../../framework/utils/MathUtils.ts.meta"),
      "../../framework/utils/SpaceUtils.ts": () => (init_SpaceUtils(), __toCommonJS(SpaceUtils_exports)),
      "../../framework/utils/SpaceUtils.ts.meta": () => require("../../framework/utils/SpaceUtils.ts.meta"),
      "../../framework/utils/StringUtils.ts": () => (init_StringUtils(), __toCommonJS(StringUtils_exports)),
      "../../framework/utils/StringUtils.ts.meta": () => require("../../framework/utils/StringUtils.ts.meta"),
      "../../framework/utils/TimeUtils.ts": () => (init_TimeUtils(), __toCommonJS(TimeUtils_exports)),
      "../../framework/utils/TimeUtils.ts.meta": () => require("../../framework/utils/TimeUtils.ts.meta"),
      "../../framework/utils/UtilsHelper.ts": () => (init_UtilsHelper(), __toCommonJS(UtilsHelper_exports)),
      "../../framework/utils/UtilsHelper.ts.meta": () => require("../../framework/utils/UtilsHelper.ts.meta"),
      "../../framework/view.meta": () => require("../../framework/view.meta"),
      "../../framework/view/Activity.ts": () => (init_Activity(), __toCommonJS(Activity_exports)),
      "../../framework/view/Activity.ts.meta": () => require("../../framework/view/Activity.ts.meta"),
      "../../framework/view/Container.ts": () => (init_Container(), __toCommonJS(Container_exports)),
      "../../framework/view/Container.ts.meta": () => require("../../framework/view/Container.ts.meta"),
      "../../framework/view/Decorators.ts": () => (init_Decorators(), __toCommonJS(Decorators_exports)),
      "../../framework/view/Decorators.ts.meta": () => require("../../framework/view/Decorators.ts.meta"),
      "../../framework/view/GM.meta": () => require("../../framework/view/GM.meta"),
      "../../framework/view/GM/GMDocker.ts": () => (init_GMDocker(), __toCommonJS(GMDocker_exports)),
      "../../framework/view/GM/GMDocker.ts.meta": () => require("../../framework/view/GM/GMDocker.ts.meta"),
      "../../framework/view/GM/GMItem.ts": () => (init_GMItem(), __toCommonJS(GMItem_exports)),
      "../../framework/view/GM/GMItem.ts.meta": () => require("../../framework/view/GM/GMItem.ts.meta"),
      "../../framework/view/GM/GMMananger.ts": () => (init_GMMananger(), __toCommonJS(GMMananger_exports)),
      "../../framework/view/GM/GMMananger.ts.meta": () => require("../../framework/view/GM/GMMananger.ts.meta"),
      "../../framework/view/Skin.ts": () => (init_Skin(), __toCommonJS(Skin_exports)),
      "../../framework/view/Skin.ts.meta": () => require("../../framework/view/Skin.ts.meta"),
      "../../framework/view/SkinHelper.ts": () => (init_SkinHelper(), __toCommonJS(SkinHelper_exports)),
      "../../framework/view/SkinHelper.ts.meta": () => require("../../framework/view/SkinHelper.ts.meta"),
      "../../framework/view/TweenWindow.ts": () => (init_TweenWindow(), __toCommonJS(TweenWindow_exports)),
      "../../framework/view/TweenWindow.ts.meta": () => require("../../framework/view/TweenWindow.ts.meta"),
      "../../framework/view/UIManager.ts": () => (init_UIManager(), __toCommonJS(UIManager_exports)),
      "../../framework/view/UIManager.ts.meta": () => require("../../framework/view/UIManager.ts.meta"),
      "../../framework/view/View.ts": () => (init_View(), __toCommonJS(View_exports)),
      "../../framework/view/View.ts.meta": () => require("../../framework/view/View.ts.meta"),
      "../../framework/view/ViewHelper.ts": () => (init_ViewHelper(), __toCommonJS(ViewHelper_exports)),
      "../../framework/view/ViewHelper.ts.meta": () => require("../../framework/view/ViewHelper.ts.meta"),
      "../../framework/view/ViewMap.ts": () => (init_ViewMap(), __toCommonJS(ViewMap_exports)),
      "../../framework/view/ViewMap.ts.meta": () => require("../../framework/view/ViewMap.ts.meta"),
      "../../framework/view/ViewObject.ts": () => (init_ViewObject(), __toCommonJS(ViewObject_exports)),
      "../../framework/view/ViewObject.ts.meta": () => require("../../framework/view/ViewObject.ts.meta"),
      "../../framework/view/Window.ts": () => (init_Window(), __toCommonJS(Window_exports)),
      "../../framework/view/Window.ts.meta": () => require("../../framework/view/Window.ts.meta"),
      "../../framework/view/WindowPriorityMap.ts": () => (init_WindowPriorityMap(), __toCommonJS(WindowPriorityMap_exports)),
      "../../framework/view/WindowPriorityMap.ts.meta": () => require("../../framework/view/WindowPriorityMap.ts.meta"),
      "../../framework/view/common.meta": () => require("../../framework/view/common.meta"),
      "../../framework/view/common/CommonToast.ts": () => (init_CommonToast(), __toCommonJS(CommonToast_exports)),
      "../../framework/view/common/CommonToast.ts.meta": () => require("../../framework/view/common/CommonToast.ts.meta"),
      "../../framework/view/common/LocationManager.ts": () => (init_LocationManager(), __toCommonJS(LocationManager_exports)),
      "../../framework/view/common/LocationManager.ts.meta": () => require("../../framework/view/common/LocationManager.ts.meta"),
      "../../framework/view/common/SpineView.ts": () => (init_SpineView(), __toCommonJS(SpineView_exports)),
      "../../framework/view/common/SpineView.ts.meta": () => require("../../framework/view/common/SpineView.ts.meta"),
      "../../framework/view/index.ts": () => (init_view(), __toCommonJS(view_exports)),
      "../../framework/view/index.ts.meta": () => require("../../framework/view/index.ts.meta"),
      "../../framework/view/interface.meta": () => require("../../framework/view/interface.meta"),
      "../../framework/view/interface/IActivity.ts": () => (init_IActivity(), __toCommonJS(IActivity_exports)),
      "../../framework/view/interface/IActivity.ts.meta": () => require("../../framework/view/interface/IActivity.ts.meta"),
      "../../framework/view/interface/IAutoInject.ts": () => (init_IAutoInject(), __toCommonJS(IAutoInject_exports)),
      "../../framework/view/interface/IAutoInject.ts.meta": () => require("../../framework/view/interface/IAutoInject.ts.meta"),
      "../../framework/view/interface/IComponent.ts": () => (init_IComponent(), __toCommonJS(IComponent_exports)),
      "../../framework/view/interface/IComponent.ts.meta": () => require("../../framework/view/interface/IComponent.ts.meta"),
      "../../framework/view/interface/IContainer.ts": () => (init_IContainer(), __toCommonJS(IContainer_exports)),
      "../../framework/view/interface/IContainer.ts.meta": () => require("../../framework/view/interface/IContainer.ts.meta"),
      "../../framework/view/interface/IInjectInfo.ts": () => (init_IInjectInfo(), __toCommonJS(IInjectInfo_exports)),
      "../../framework/view/interface/IInjectInfo.ts.meta": () => require("../../framework/view/interface/IInjectInfo.ts.meta"),
      "../../framework/view/interface/IView.ts": () => (init_IView(), __toCommonJS(IView_exports)),
      "../../framework/view/interface/IView.ts.meta": () => require("../../framework/view/interface/IView.ts.meta"),
      "../../framework/view/interface/IWindow.ts": () => (init_IWindow(), __toCommonJS(IWindow_exports)),
      "../../framework/view/interface/IWindow.ts.meta": () => require("../../framework/view/interface/IWindow.ts.meta"),
      "../../framework/view/utils.meta": () => require("../../framework/view/utils.meta"),
      "../../framework/view/utils/FGUIExt.ts": () => (init_FGUIExt(), __toCommonJS(FGUIExt_exports)),
      "../../framework/view/utils/FGUIExt.ts.meta": () => require("../../framework/view/utils/FGUIExt.ts.meta"),
      "../../framework/view/utils/fgui_patch.ts": () => (init_fgui_patch(), __toCommonJS(fgui_patch_exports)),
      "../../framework/view/utils/fgui_patch.ts.meta": () => require("../../framework/view/utils/fgui_patch.ts.meta"),
      "../../framework/wxsdk.meta": () => require("../../framework/wxsdk.meta")
    });
  }
});

// assets/scripts/framework/patch/ccc_patch.ts
var ccc_patch_exports = {};
__export(ccc_patch_exports, {
  PackageVersionMap: () => PackageVersionMap,
  clearUselessCache: () => clearUselessCache,
  default: () => ccc_patch_default
});
var import_cc28, import_env11, layer2D, setParent, PackageVersionMap, clearUselessCache, suffix, ccc_patch_default;
var init_ccc_patch = __esm({
  "assets/scripts/framework/patch/ccc_patch.ts"() {
    import_cc28 = require("cc");
    import_env11 = require("cc/env");
    init_fairygui();
    init_();
    if (!import_env11.EDITOR) {
      layer2D = UIConfig.defaultUILayer;
      setParent = import_cc28.Node.prototype.setParent;
      import_cc28.Node.prototype.setParent = function(value, keepWorldTransform) {
        let that = this;
        setParent.call(that, value, keepWorldTransform);
        if (value && value.$gobj && value.layer == layer2D) {
          that.layer = value.layer;
        }
      };
    }
    PackageVersionMap = {};
    clearUselessCache = function(version) {
    };
    if (import_env11.MINIGAME) {
      let existsAsync = function(file) {
        try {
          fs.accessSync(file);
          return true;
        } catch (e) {
          return false;
        }
      }, copyDirsSync = function(srcDir, destDir) {
        let files = fs.readdirSync(srcDir);
        files.forEach((filename) => {
          let srcPath = import_cc28.path.join(srcDir, filename);
          let destPath = import_cc28.path.join(destDir, filename);
          let stat = fs.statSync(srcPath);
          if (stat.isFile()) {
            fs.copyFileSync(srcPath, destPath);
          } else if (stat.isDirectory()) {
            if (!existsAsync(destPath)) {
              makeDirSync(destPath, true);
            }
            copyDirsSync(srcPath, destPath);
          }
        });
      }, handleZip = function(url, options, onComplete) {
        let cachedUnzip = cacheManager.cachedFiles.get(url);
        if (cachedUnzip) {
          cacheManager.updateLastTime(url);
          onComplete && onComplete(null, cachedUnzip.url);
        } else if (ASSET_MGR_REGEX.test(url)) {
          console.log(`unzip file ${url}`);
          downloadFile(url, null, options.header, options.onFileProgress, function(err, downloadedZipPath) {
            if (err) {
              console.error(`download ${url} failed : ${err.message}`);
              onComplete && onComplete(err);
              return;
            }
            cacheManager.unzipAndCacheBundle(url, downloadedZipPath, options.__cacheBundleRoot__, onComplete);
          });
        } else {
          cacheManager.unzipAndCacheBundle(url, url, options.__cacheBundleRoot__, onComplete);
        }
      }, getZipUrl = function(pkg, url, zipVersion) {
        let defaultUrl = `${url}/res.${zipVersion ? zipVersion + "." : ""}zip`;
        if (!pkg || typeof pkg !== "object" || pkg.formats == null || pkg.formats.length === 0) {
          return defaultUrl;
        }
        let device = import_cc28.director.root.device;
        let ext = "";
        if (device) {
          for (let i = 0; i < pkg.formats.length; i++) {
            let tmpExt = pkg.formats[i];
            if (tmpExt === "astc" && device.getFormatFeatures(import_cc28.gfx.Format.ASTC_RGBA_4X4)) {
              ext = ".astc";
              break;
            } else if (tmpExt === "pvr" && (device.getFormatFeatures(import_cc28.gfx.Format.PVRTC_RGB2) || device.getFormatFeatures(import_cc28.gfx.Format.PVRTC_RGBA2))) {
              ext = ".pvr";
              break;
            } else if (tmpExt === "pkm" && device.getFormatFeatures(import_cc28.gfx.Format.ETC_RGB8)) {
              ext = ".pkm";
              break;
            } else if (tmpExt === "webp" && import_cc28.sys.hasFeature(import_cc28.sys.Feature.WEBP)) {
              ext = ".webp";
              break;
            }
          }
        }
        if (!ext) {
          return defaultUrl;
        }
        return `${url}/res.${(zipVersion ? zipVersion : "") + ext + "."}zip`;
      }, clearUselessCacheF = function(version) {
        console.log("clearUselessCache", version);
        let caches = import_cc28.assetManager.cacheManager.cachedFiles;
        let curVersion = `/${version}/`;
        let versionRegex = /\/((debug\d?)|((\d.*?\.?){1,4}))\//gi;
        let regex = /https?:\/\/.*?\/remote\/(.*?)\/.*?/gi;
        caches.forEach((value, key) => {
          let arr = regex.exec(key);
          if (value && key && arr && arr.length > 1 && arr[1]) {
            let exits = false;
            let pkgName = arr[1];
            let dotSplits = key.split(".");
            let hashValue = dotSplits[dotSplits.length - 2];
            var pkg = PackageVersionMap[pkgName];
            if (pkg) {
              if (pkg == hashValue) {
                exits = true;
              } else if (pkg.files) {
                let fn = import_cc28.path.basename(key);
                if (!!pkg.files[fn]) {
                  exits = true;
                }
              } else {
                exits = pkg.hash == hashValue || pkg.zipHash == hashValue;
              }
            }
            if (!exits) {
              console.log("\u5220\u9664:", value.url, key);
              import_cc28.assetManager.cacheManager.removeCache(key);
            } else if (key.indexOf(curVersion) < 0) {
              console.log("\u66FF\u6362:", value.url, key);
              import_cc28.assetManager.cacheManager.cachedFiles.remove(key);
              import_cc28.assetManager.cacheManager.cachedFiles.add(key.replace(versionRegex, curVersion), value);
            }
          }
        });
        import_cc28.assetManager.cacheManager["writeCacheFile"]();
      };
      if (typeof wx != "undefined" && wx.onMemoryWarning) {
        wx.onMemoryWarning && wx.onMemoryWarning(() => {
          wx.triggerGC();
          console.log("\u5185\u5B58\u8B66\u544A");
        });
      }
      const { fs } = window.fsUtils;
      const ASSET_MGR_REGEX = /^https?:\/\/.*/;
      const cacheManager = import_cc28.assetManager.cacheManager;
      const downloader = import_cc28.assetManager.downloader;
      const downloadJson = downloader["_downloaders"][".json"];
      const downloadBundle = downloader["_downloaders"]["bundle"];
      const subpackages = {};
      const subpacks = import_cc28.settings.querySettings("assets", "subpackages");
      subpacks && subpacks.forEach((x) => subpackages[x] = `subpackages/${x}`);
      const makeDirSync = window.fsUtils.makeDirSync = function(path4, recursive) {
        try {
          if (!existsAsync(path4)) {
            fs.mkdirSync(path4, recursive);
          }
          return null;
        } catch (e) {
          console.warn(`Make directory failed: path: ${path4} message: ${e.message}`);
          return new Error(e.message);
        }
      };
      const { downloadFile, readText, readArrayBuffer, readJson, loadSubpackage, getUserDataPath, exists, unzip, rmdirSync, isOutOfStorage } = window.fsUtils;
      const unzipCacheBundle = cacheManager.unzipAndCacheBundle;
      cacheManager.makeBundleFolder = function(bundleName) {
        let dir = this.cacheDir + "/" + bundleName;
        if (!existsAsync(dir)) {
          makeDirSync(dir, true);
        }
      };
      suffix = 0;
      cacheManager.unzipAndCacheBundle = function(id, zipFilePath, cacheBundleRoot, onComplete, targetPath = null) {
        if (!import_env11.ALIPAY) {
          unzipCacheBundle.call(this, id, zipFilePath, cacheBundleRoot, onComplete, targetPath);
          return;
        }
        let needCopy = true;
        if (!targetPath) {
          needCopy = false;
          let time2 = Date.now().toString();
          targetPath = "".concat(this.cacheDir, "/").concat(cacheBundleRoot, "/").concat(time2).concat("" + suffix++).concat("/");
        }
        let time = Date.now().toString();
        let self2 = this;
        let tempDir = needCopy ? targetPath + "/temp_" + time + suffix++ + "/" : targetPath.endsWith("/") ? targetPath : targetPath + "/";
        makeDirSync(tempDir, true);
        unzip(zipFilePath, tempDir, function(err) {
          if (err) {
            rmdirSync(targetPath, true);
            if (needCopy) {
              rmdirSync(tempDir, true);
            }
            if (isOutOfStorage(err.message)) {
              self2.outOfStorage = true;
              self2.autoClear && self2.clearLRU();
            }
            self2.cachedFiles.remove(id);
            onComplete && onComplete(err);
            return;
          } else {
            if (needCopy) {
              copyDirsSync(tempDir, targetPath);
              rmdirSync(tempDir, true);
            }
            self2.cachedFiles.add(id, { bundle: cacheBundleRoot, url: targetPath, lastTime: time });
          }
          self2.writeCacheFile();
          onComplete && onComplete(null, targetPath);
        });
      };
      import_cc28.assetManager.downloader.register("bundle", (nameOrUrl, options, onComplete) => {
        console.log("bundle", nameOrUrl, options);
        let pkg = PackageVersionMap[nameOrUrl];
        if (!pkg) {
          downloadBundle(nameOrUrl, options, onComplete);
          return;
        }
        let bundleName = import_cc28.path.basename(nameOrUrl);
        let version = options.version || import_cc28.assetManager.downloader.bundleVers[bundleName];
        let suffix2 = version ? version + "." : "";
        let localVersion = import_cc28.assetManager.downloader.bundleVers[bundleName];
        let localSuffix = localVersion ? localVersion + "." : "";
        function getConfigPathForSubPackage() {
          if (import_cc28.sys.platform === import_cc28.sys.Platform.TAOBAO_MINI_GAME) {
            return `${bundleName}/config.${suffix2}json`;
          }
          return `subpackages/${bundleName}/config.${localSuffix}json`;
        }
        function appendBaseToJsonData(data) {
          if (!data) return;
          if (import_cc28.sys.platform === import_cc28.sys.Platform.TAOBAO_MINI_GAME) {
            data.base = `${bundleName}/`;
          } else {
            data.base = `subpackages/${bundleName}/`;
          }
        }
        if (subpackages[bundleName]) {
          const config = getConfigPathForSubPackage();
          loadSubpackage(bundleName, options.onFileProgress, (err) => {
            if (err) {
              onComplete(err, null);
              return;
            }
            downloadJson(config, options, (err2, data) => {
              appendBaseToJsonData(data);
              onComplete(err2, data);
            });
          });
        } else {
          let js;
          let url;
          if (ASSET_MGR_REGEX.test(nameOrUrl) || nameOrUrl.startsWith(getUserDataPath())) {
            url = nameOrUrl;
            js = `src/bundle-scripts/${bundleName}/index.${localSuffix}js`;
            cacheManager.makeBundleFolder(bundleName);
          } else if (downloader.remoteBundles.indexOf(bundleName) !== -1) {
            url = `${downloader.remoteServerAddress}remote/${bundleName}`;
            js = `src/bundle-scripts/${bundleName}/index.${localSuffix}js`;
            cacheManager.makeBundleFolder(bundleName);
          } else {
            url = `assets/${bundleName}`;
            js = `assets/${bundleName}/index.${localSuffix}js`;
          }
          try {
            if (import_cc28.sys.platform === import_cc28.sys.Platform.TAOBAO_MINI_GAME) {
              require(`/../../${js}`);
            } else if (import_cc28.sys.platform !== import_cc28.sys.Platform.TAOBAO_CREATIVE_APP) {
              globRequire(`../../${js}`);
            }
          } catch (e) {
            console.error("require error:" + e);
          }
          options.__cacheBundleRoot__ = bundleName;
          const config = `${url}/config.${suffix2}json`;
          downloadJson(config, options, function(err, data) {
            if (err) {
              onComplete && onComplete(err);
              return;
            }
            if (data.isZip) {
              let zipVersion = data.zipVersion;
              let zipUrl = getZipUrl(pkg, url, zipVersion);
              console.log(`zipUrl: ${zipUrl}`);
              handleZip(zipUrl, options, (err2, unzipPath) => {
                if (!err2) {
                  data.base = unzipPath + "/res/";
                  if (import_cc28.sys.platform === import_cc28.sys.Platform.ALIPAY_MINI_GAME && import_cc28.sys.os === import_cc28.sys.OS.ANDROID) {
                    let resPath = unzipPath + "res/";
                    if (fs.accessSync({ path: resPath })) {
                      data.base = resPath;
                    }
                  }
                  if (!options) {
                    options = {};
                  }
                  options._targetPath = unzipPath;
                } else {
                  console.error(err2);
                }
                onComplete && onComplete(err2, data);
              });
            } else {
              data.base = url + "/";
              onComplete && onComplete(null, data);
            }
          });
        }
      });
      clearUselessCache = clearUselessCacheF;
    }
    ccc_patch_default = null;
  }
});

// assets/scripts/framework/common/ResManager.ts
var ResManager_exports = {};
__export(ResManager_exports, {
  ResManager: () => ResManager
});
var import_cc29, RESOURCES, ResManager;
var init_ResManager = __esm({
  "assets/scripts/framework/common/ResManager.ts"() {
    import_cc29 = require("cc");
    init_ccc_patch();
    init_fairygui();
    init_FGUIExt();
    RESOURCES = "resources";
    ResManager = class {
      static async preload(uuid, progress) {
        return new Promise((resolve, reject) => {
          import_cc29.assetManager.preloadAny(uuid, (p) => {
            progress && progress(p);
          }, (err, res) => {
            resolve(res);
          });
        });
      }
      static async loadBundle(abName) {
        if (abName == RESOURCES || !abName) {
          return true;
        }
        let pkg = PackageVersionMap[abName];
        let version = pkg && typeof pkg == "object" ? pkg.hash : pkg;
        let config = {
          version
        };
        try {
          let bundle = await new Promise((resolve, reject) => {
            import_cc29.assetManager.loadBundle(abName, config, (err, bundle2) => {
              if (err) {
                reject(err);
              } else {
                resolve(bundle2);
              }
            });
          });
          let loaders = bundle.deps.map((dep) => this.loadBundle(dep));
          if (loaders.length > 0) {
            await Promise.all(loaders);
          }
          return true;
        } catch (err) {
          console.error("\u4E0B\u8F7D\u5931\u8D25", abName);
          return false;
        }
      }
      static getBundle(abName, check = true) {
        if (!abName || abName == RESOURCES) {
          return import_cc29.resources;
        }
        let ab = import_cc29.assetManager.getBundle(abName);
        if (!ab && check) {
          console.error(`can not find asset bundle named ${abName}`);
        }
        return ab;
      }
      static get(abName, url, type) {
        let ab = this.getBundle(abName, true);
        if (!ab) {
          throw new Error(`Cannot find asset bundle named ${abName}`);
        }
        if (typeof url == "string") {
          return ab.get(url, type);
        } else {
          return url.map((u) => ab.get(u, type));
        }
      }
      static async getAsync(abName, url, type) {
        let ab = this.getBundle(abName, false);
        if (!ab) {
          await this.loadBundle(abName);
        }
        let res = this.get(abName, url, type);
        if (res) {
          return res;
        }
        try {
          res = await this.load(abName, url, type);
        } catch (e) {
          throw new Error(`load ${abName}:${url} data err:${e}`);
        }
        return res;
      }
      static async load(abName, url, type, onProgress) {
        let ab = this.getBundle(abName);
        if (!ab) {
          throw new Error(`Cannot find asset bundle named ${abName}`);
        }
        return new Promise((resolve, reject) => {
          ab.load(url, type, onProgress, (err, res) => {
            if (err) {
              reject(err);
            } else {
              resolve(res);
            }
          });
        });
      }
      static async loadDir(abName, url, onProgress) {
        url = url || "";
        let ab = this.getBundle(abName);
        if (!ab) {
          throw new Error(`can not find asset bundle named ${abName}`);
        }
        return new Promise((resolve, reject) => {
          ab.loadDir(url, onProgress, (err, res) => {
            if (err) {
              reject(err);
            } else {
              resolve(res);
            }
          });
        });
      }
      static destory(asset) {
        asset.destroy();
      }
      static async loadFUIBundle(bundle, pkg, progress, delay) {
        if (!this.isValidBundleAndPackage(bundle, pkg)) {
          return false;
        }
        await this.loadBundle(bundle);
        return await FGUIExt.preloadPackage(bundle, pkg, progress, delay);
      }
      static unloadFUIBundle(bundle, pkg) {
        if (!this.isValidBundleAndPackage(bundle, pkg)) {
          return;
        }
        UIPackage.removePackage(pkg);
        let b = this.getBundle(bundle);
        b.releaseAll();
        import_cc29.assetManager.removeBundle(b);
      }
      static isValidBundleAndPackage(bundle, pkg) {
        if (!pkg || UIPackage.getByName(pkg)) {
          return false;
        }
        if (!bundle || !this.getBundle(bundle)) {
          return false;
        }
        return true;
      }
      static getById(id, type) {
        return null;
      }
      static async getByIdAsync(id, type) {
        return null;
      }
    };
  }
});

// assets/scripts/framework/common/LoaderHelper.ts
var LoaderHelper_exports = {};
__export(LoaderHelper_exports, {
  LoaderHelper: () => LoaderHelper
});
var _LoaderHelper, LoaderHelper;
var init_LoaderHelper = __esm({
  "assets/scripts/framework/common/LoaderHelper.ts"() {
    init_ResManager();
    _LoaderHelper = class _LoaderHelper {
      constructor(abName, pkgName, callback, thisObj) {
        this._loaded = false;
        this._loading = false;
        this._callback = null;
        this.abName = abName;
        this.pkgName = pkgName;
        if (callback) {
          this._callback = { callback, thisObj };
        }
      }
      static tick() {
        if (_LoaderHelper._loaders.length == 0 || _LoaderHelper._loadingCount >= _LoaderHelper.MAX_LOAD_COUNT) {
          return;
        }
        let loader = _LoaderHelper._loaders.shift();
        if (loader && !loader._loading) {
          loader.doLoad();
        }
      }
      async load() {
        if (this._loaded) {
          this.onResReady();
          return;
        }
        if (this._loading) {
          return;
        }
        if (_LoaderHelper._loadingCount >= _LoaderHelper.MAX_LOAD_COUNT) {
          _LoaderHelper._loaders.push(this);
          return;
        }
        this.doLoad();
      }
      doLoad() {
        if (this._loading) return;
        this._loading = true;
        _LoaderHelper._loadingCount++;
        ResManager.loadFUIBundle(this.abName, this.pkgName, null, true).then(() => {
          this._loading = false;
          _LoaderHelper._loadingCount--;
          this.onResReady();
        });
      }
      loadRes(callback, thisObj) {
        if (this._loaded) {
          if (callback) {
            callback.call(thisObj);
          }
          return;
        }
        ResManager.loadFUIBundle(this.abName, this.pkgName, null, true).then(() => {
          if (callback) {
            callback.call(thisObj);
          }
        });
      }
      onResReady() {
        this._loaded = true;
        if (this._callback) {
          this._callback.callback.call(this._callback.thisObj);
        }
      }
      get loaded() {
        return this._loaded;
      }
      get loading() {
        return this._loading;
      }
      dispose() {
        this._callback = null;
        ResManager.unloadFUIBundle(this.abName, this.pkgName);
      }
    };
    _LoaderHelper.MAX_LOAD_COUNT = 2;
    _LoaderHelper._loadingCount = 0;
    _LoaderHelper._loaders = [];
    LoaderHelper = _LoaderHelper;
  }
});

// assets/scripts/framework/activity/controller/BaseActivityController.ts
var BaseActivityController_exports = {};
__export(BaseActivityController_exports, {
  BaseActivityController: () => BaseActivityController,
  EActivityStatus: () => EActivityStatus
});
var EActivityStatus, _BaseActivityController, BaseActivityController;
var init_BaseActivityController = __esm({
  "assets/scripts/framework/activity/controller/BaseActivityController.ts"() {
    init_EventHandler();
    init_EventCenter();
    init_LoaderHelper();
    EActivityStatus = /* @__PURE__ */ ((EActivityStatus2) => {
      EActivityStatus2[EActivityStatus2["NotOpen"] = 0] = "NotOpen";
      EActivityStatus2[EActivityStatus2["PreLimit"] = 1] = "PreLimit";
      EActivityStatus2[EActivityStatus2["PreOpen"] = 2] = "PreOpen";
      EActivityStatus2[EActivityStatus2["Opening"] = 3] = "Opening";
      EActivityStatus2[EActivityStatus2["PreEnd"] = 4] = "PreEnd";
      EActivityStatus2[EActivityStatus2["End"] = 5] = "End";
      return EActivityStatus2;
    })(EActivityStatus || {});
    _BaseActivityController = class _BaseActivityController {
      constructor(name) {
        this.beforeCreate = new EventHandler();
        this._status = 0 /* NotOpen */;
        this._realStatus = 0 /* NotOpen */;
        this._oldStatus = 0 /* NotOpen */;
        this._needCheck = true;
        this._first = true;
        this.name = name;
      }
      get config() {
        return this._config;
      }
      get loading() {
        return this._loader.loading;
      }
      get loaded() {
        return this._loader.loaded;
      }
      create(config) {
        this.beforeCreate.fire();
        this._config = config || {};
        if (this._config.disposeOnClose == void 0) {
          this._config.disposeOnClose = true;
        }
        if (this._config.hasPay == void 0) {
          this._config.hasPay = true;
        }
        this._loader = new LoaderHelper(this._config.abName, this._config.pkgName, this.sendChangeEvent, this);
      }
      get status() {
        return this._status;
      }
      doRegist() {
        this.onRegist();
        EventCenter.I.emit(_BaseActivityController.ACTIVITY_CONTROLLER_REGISTED, this);
      }
      onRegist() {
      }
      setStatus(status) {
        this._status = status;
      }
      update(dt, secondTick) {
        this.checkState();
        if (secondTick) {
          LoaderHelper.tick();
        }
      }
      doLoad() {
        this._realStatus = this.status;
        if (this.needLoadRes()) {
          this._loader.load();
        } else {
          this.sendChangeEvent();
        }
      }
      checkState() {
        if (!this._needCheck) {
          return;
        }
        if (this._config.hasPay) {
          return;
        }
        let oldStatus = this._oldStatus;
        this.onUpdateStatus();
        if (this._first) {
          this._realStatus = this.status;
          this._oldStatus = this.status;
          this._first = false;
          if (oldStatus == 0 /* NotOpen */ && this._realStatus != 0 /* NotOpen */ && this._realStatus != 5 /* End */) {
            this.doLoad();
          }
        } else {
          if (oldStatus != this.status) {
            this.doLoad();
          }
        }
      }
      loadRes(callback, thisObj) {
        this._loader.loadRes(callback, thisObj);
      }
      onUpdateStatus() {
      }
      needLoadRes() {
        return this.status != 0 /* NotOpen */ && this.status != 5 /* End */;
      }
      sendChangeEvent() {
        this.onRealStateChange(this._realStatus, this._oldStatus);
        this._status = this._realStatus;
        this._oldStatus = this._realStatus;
        EventCenter.I.emit(_BaseActivityController.ACTIVITY_STATUS_CHANGE, this, this._realStatus, this._oldStatus);
        if (this._status == 5 /* End */) {
          this.onClose();
        } else if (this._status == 3 /* Opening */) {
          if (this._config.onceCheck) {
            this._needCheck = false;
          }
        }
      }
      onRealStateChange(status, oldStatus) {
      }
      onClose() {
        if (this._config.disposeOnClose) {
          this._loader.dispose();
        }
      }
    };
    _BaseActivityController.ACTIVITY_STATUS_CHANGE = "ACTIVITY_STATUS_CHANGE";
    _BaseActivityController.ACTIVITY_CONTROLLER_REGISTED = "ACTIVITY_CONTROLLER_REGISTED";
    BaseActivityController = _BaseActivityController;
  }
});

// index.ts
init_ActivityController();
init_BaseActivityController();
init_AcitivityProxyManager();
init_BaseActivityProxy();
init_EncryptHelper();
init_EventCenter();
init_EventHandler();
init_LoaderHelper();
init_Logger();
init_Pool();
init_PoolManager();
init_Pools();
init_ResManager();
init_SoundManager();
init_StorageManager();
init_TaskManager();
init_Timer();
init_TimeWatcher();
init_GameSettings();
init_md5();
init_macro();
init_BaseController();
init_BaseDAO();
init_BaseModel();
init_SecretController();
init_SecretDAO();
init_SecretModel();
init_Bridge();
init_ControllerManager();
init_ModelMapper();
init_SystemController();
init_ccc_patch();
init_ccc_pref_renderer();
init_Platform();
init_PlatformSDK();
init_CanvasPool();
init_CaptureHelper();
init_DataAccess();
init_I18N();
init_Lang();
init_FSM();
init_Gesture();
init_LongTouchGesture();
init_PinchGesture();
init_SwipeGesture();
init_RedDotManager();
init_RedDotNode();
init_RedDotTree();
init_serialize();
init_CoroutineUtils();
init_MathUtils();
init_SpaceUtils();
init_StringUtils();
init_TimeUtils();
init_UtilsHelper();
init_Activity();
init_CommonToast();
init_LocationManager();
init_SpineView();
init_Container();
init_Decorators();
init_GMDocker();
init_GMItem();
init_GMMananger();
init_view();
init_Skin();
init_SkinHelper();
init_TweenWindow();
init_UIManager();
init_FGUIExt();
init_fgui_patch();
init_View();
init_ViewHelper();
init_ViewMap();
init_ViewObject();
init_Window();
init_WindowPriorityMap();
